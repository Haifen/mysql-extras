diff -urN mysql-old/client/mysqlbinlog.cc mysql/client/mysqlbinlog.cc
--- mysql-old/client/mysqlbinlog.cc	2009-12-10 00:54:18.744801535 -0100
+++ mysql/client/mysqlbinlog.cc	2009-12-10 00:57:22.925800633 -0100
@@ -34,6 +34,7 @@
 #include "mysql_priv.h" 
 #include "log_event.h"
 #include "sql_common.h"
+#include "my_global.h"
 
 #define BIN_LOG_HEADER_SIZE	4
 #define PROBE_HEADER_LEN	(EVENT_LEN_OFFSET+4)
@@ -1924,7 +1925,7 @@
       my_off_t length,tmp;
       for (length= start_position_mot ; length > 0 ; length-=tmp)
       {
-	tmp=min(length,sizeof(buff));
+	tmp=MYSQL_MIN(length,sizeof(buff));
 	if (my_b_read(file, buff, (uint) tmp))
         {
           error("Failed reading from file.");
diff -urN mysql-old/client/mysql.cc mysql/client/mysql.cc
--- mysql-old/client/mysql.cc	2009-12-10 00:54:18.744801535 -0100
+++ mysql/client/mysql.cc	2009-12-10 00:57:22.926584989 -0100
@@ -3281,9 +3281,9 @@
   {
     uint length= column_names ? field->name_length : 0;
     if (quick)
-      length=max(length,field->length);
+      length=MYSQL_MAX(length,field->length);
     else
-      length=max(length,field->max_length);
+      length=MYSQL_MAX(length,field->max_length);
     if (length < 4 && !IS_NOT_NULL(field->flags))
       length=4;					// Room for "NULL"
     field->max_length=length;
@@ -3303,7 +3303,7 @@
                                                   field->name,
                                                   field->name + name_length);
       uint display_length= field->max_length + name_length - numcells;
-      tee_fprintf(PAGER, " %-*s |",(int) min(display_length,
+      tee_fprintf(PAGER, " %-*s |",(int) MYSQL_MIN(display_length,
                                             MAX_COLUMN_LENGTH),
                   field->name);
       num_flag[off]= IS_NUM(field->type);
diff -urN mysql-old/client/mysqldump.c mysql/client/mysqldump.c
--- mysql-old/client/mysqldump.c	2009-12-10 00:54:18.743800406 -0100
+++ mysql/client/mysqldump.c	2009-12-10 00:57:22.929800060 -0100
@@ -808,7 +808,7 @@
                                     &err_ptr, &err_len);
       if (err_len)
       {
-        strmake(buff, err_ptr, min(sizeof(buff), err_len));
+        strmake(buff, err_ptr, MYSQL_MIN(sizeof(buff), err_len));
         fprintf(stderr, "Invalid mode to --compatible: %s\n", buff);
         exit(1);
       }
@@ -4486,7 +4486,7 @@
 
       for (; pos != end && *pos != ','; pos++) ;
       var_len= (uint) (pos - start);
-      strmake(buff, start, min(sizeof(buff), var_len));
+      strmake(buff, start, MYSQL_MIN(sizeof(buff), var_len));
       find= find_type(buff, lib, var_len);
       if (!find)
       {
diff -urN mysql-old/client/mysqltest.cc mysql/client/mysqltest.cc
--- mysql-old/client/mysqltest.cc	2009-12-10 00:54:18.743800406 -0100
+++ mysql/client/mysqltest.cc	2009-12-10 00:57:22.933924977 -0100
@@ -5302,9 +5302,9 @@
       }
       else if ((c == '{' &&
                 (!my_strnncoll_simple(charset_info, (const uchar*) "while", 5,
-                                      (uchar*) buf, min(5, p - buf), 0) ||
+                                      (uchar*) buf, MYSQL_MIN(5, p - buf), 0) ||
                  !my_strnncoll_simple(charset_info, (const uchar*) "if", 2,
-                                      (uchar*) buf, min(2, p - buf), 0))))
+                                      (uchar*) buf, MYSQL_MIN(2, p - buf), 0))))
       {
         /* Only if and while commands can be terminated by { */
         *p++= c;
diff -urN mysql-old/client/mysql_upgrade.c mysql/client/mysql_upgrade.c
--- mysql-old/client/mysql_upgrade.c	2009-12-10 00:54:18.744801535 -0100
+++ mysql/client/mysql_upgrade.c	2009-12-10 00:57:22.937549888 -0100
@@ -502,7 +502,7 @@
   if ((value_end= strchr(value_start, '\n')) == NULL)
     return 1; /* Unexpected result */
 
-  strncpy(value, value_start, min(FN_REFLEN, value_end-value_start));
+  strncpy(value, value_start, MYSQL_MIN(FN_REFLEN, value_end-value_start));
   return 0;
 }
 
diff -urN mysql-old/client/sql_string.cc mysql/client/sql_string.cc
--- mysql-old/client/sql_string.cc	2009-12-10 00:54:18.744801535 -0100
+++ mysql/client/sql_string.cc	2009-12-10 00:57:22.937549888 -0100
@@ -659,7 +659,7 @@
 {
   if (Alloced_length < str_length + space_needed)
   {
-    if (realloc(Alloced_length + max(space_needed, grow_by) - 1))
+    if (realloc(Alloced_length + MYSQL_MAX(space_needed, grow_by) - 1))
       return TRUE;
   }
   return FALSE;
@@ -745,7 +745,7 @@
 
 int stringcmp(const String *s,const String *t)
 {
-  uint32 s_len=s->length(),t_len=t->length(),len=min(s_len,t_len);
+  uint32 s_len=s->length(),t_len=t->length(),len=MYSQL_MIN(s_len,t_len);
   int cmp= memcmp(s->ptr(), t->ptr(), len);
   return (cmp) ? cmp : (int) (s_len - t_len);
 }
@@ -762,7 +762,7 @@
   }
   if (to->realloc(from_length))
     return from;				// Actually an error
-  if ((to->str_length=min(from->str_length,from_length)))
+  if ((to->str_length=MYSQL_MIN(from->str_length,from_length)))
     memcpy(to->Ptr,from->Ptr,to->str_length);
   to->str_charset=from->str_charset;
   return to;
diff -urN mysql-old/dbug/dbug.c mysql/dbug/dbug.c
--- mysql-old/dbug/dbug.c	2009-12-10 00:54:18.750801052 -0100
+++ mysql/dbug/dbug.c	2009-12-10 00:57:22.939550060 -0100
@@ -1202,7 +1202,7 @@
     if (TRACING)
     {
       Indent(cs, cs->level + 1);
-      pos= min(max(cs->level-cs->stack->sub_level,0)*INDENT,80);
+      pos= MYSQL_MIN(MYSQL_MAX(cs->level-cs->stack->sub_level,0)*INDENT,80);
     }
     else
     {
@@ -1687,7 +1687,7 @@
 {
   REGISTER int count;
 
-  indent= max(indent-1-cs->stack->sub_level,0)*INDENT;
+  indent= MYSQL_MAX(indent-1-cs->stack->sub_level,0)*INDENT;
   for (count= 0; count < indent ; count++)
   {
     if ((count % INDENT) == 0)
diff -urN mysql-old/extra/yassl/src/handshake.cpp mysql/extra/yassl/src/handshake.cpp
--- mysql-old/extra/yassl/src/handshake.cpp	2009-12-10 00:54:18.747800268 -0100
+++ mysql/extra/yassl/src/handshake.cpp	2009-12-10 00:57:22.940550053 -0100
@@ -26,6 +26,7 @@
 #include "runtime.hpp"
 #include "handshake.hpp"
 #include "yassl_int.hpp"
+#include "my_global.h"
 
 
 namespace yaSSL {
@@ -936,7 +937,7 @@
     int sent = 0;
 
     for (;;) {
-        int len = min(sz - sent, MAX_RECORD_SIZE);
+        int len = MYSQL_MIN(sz - sent, MAX_RECORD_SIZE);
         output_buffer out;
         input_buffer tmp;
 
diff -urN mysql-old/extra/yassl/src/ssl.cpp mysql/extra/yassl/src/ssl.cpp
--- mysql-old/extra/yassl/src/ssl.cpp	2009-12-10 00:54:18.747800268 -0100
+++ mysql/extra/yassl/src/ssl.cpp	2009-12-10 00:57:22.941550523 -0100
@@ -38,6 +38,7 @@
 #include "file.hpp"             // for TaoCrypt Source
 #include "coding.hpp"           // HexDecoder
 #include "helpers.hpp"          // for placement new hack
+#include "my_global.h"
 #include <stdio.h>
 
 #ifdef _WIN32
@@ -113,7 +114,7 @@
                 // use file's salt for key derivation, but not real iv
                 TaoCrypt::Source source(info.iv, info.ivSz);
                 TaoCrypt::HexDecoder dec(source);
-                memcpy(info.iv, source.get_buffer(), min((uint)sizeof(info.iv),
+                memcpy(info.iv, source.get_buffer(), MYSQL_MIN((uint)sizeof(info.iv),
                                                          source.size()));
                 EVP_BytesToKey(info.name, "MD5", info.iv, (byte*)password,
                                passwordSz, 1, key, iv);
@@ -320,7 +321,7 @@
 
 int SSL_read(SSL* ssl, void* buffer, int sz)
 {
-    Data data(min(sz, MAX_RECORD_SIZE), static_cast<opaque*>(buffer));
+    Data data(MYSQL_MIN(sz, MAX_RECORD_SIZE), static_cast<opaque*>(buffer));
     return receiveData(*ssl, data);
 }
 
@@ -618,7 +619,7 @@
     if (!name->GetName()) return buffer;
 
     int len    = (int)strlen(name->GetName()) + 1;
-    int copySz = min(len, sz);
+    int copySz = MYSQL_MIN(len, sz);
 
     if (!buffer) {
         buffer = (char*)malloc(len);
@@ -1080,7 +1081,7 @@
         }
 
         if (keyLeft) {
-            int store = min(keyLeft, static_cast<int>(digestSz));
+            int store = MYSQL_MIN(keyLeft, static_cast<int>(digestSz));
             memcpy(&key[keyLen - keyLeft], digest, store);
 
             keyOutput  += store;
@@ -1089,7 +1090,7 @@
         }
 
         if (ivLeft && digestLeft) {
-            int store = min(ivLeft, digestLeft);
+            int store = MYSQL_MIN(ivLeft, digestLeft);
             memcpy(&iv[ivLen - ivLeft], &digest[digestSz - digestLeft], store);
 
             keyOutput += store;
@@ -1414,7 +1415,7 @@
 
 int SSL_peek(SSL* ssl, void* buffer, int sz)
 {
-    Data data(min(sz, MAX_RECORD_SIZE), static_cast<opaque*>(buffer));
+    Data data(MYSQL_MIN(sz, MAX_RECORD_SIZE), static_cast<opaque*>(buffer));
     return receiveData(*ssl, data, true);
 }
 
diff -urN mysql-old/extra/yassl/src/yassl_imp.cpp mysql/extra/yassl/src/yassl_imp.cpp
--- mysql-old/extra/yassl/src/yassl_imp.cpp	2009-12-10 00:54:18.747800268 -0100
+++ mysql/extra/yassl/src/yassl_imp.cpp	2009-12-10 00:57:22.942549730 -0100
@@ -22,6 +22,7 @@
 #include "runtime.hpp"
 #include "yassl_int.hpp"
 #include "handshake.hpp"
+#include "my_global.h"
 
 #include "asn.hpp"  // provide crypto wrapper??
 
@@ -1435,7 +1436,7 @@
     tmp[1] = input[AUTO];
     ato16(tmp, len);
 
-    hello.suite_len_ = min(len, static_cast<uint16>(MAX_SUITE_SZ));
+    hello.suite_len_ = MYSQL_MIN(len, static_cast<uint16>(MAX_SUITE_SZ));
     input.read(hello.cipher_suites_, hello.suite_len_);
     if (len > hello.suite_len_) // ignore extra suites
         input.set_current(input.get_current() + len -  hello.suite_len_);
diff -urN mysql-old/extra/yassl/src/yassl_int.cpp mysql/extra/yassl/src/yassl_int.cpp
--- mysql-old/extra/yassl/src/yassl_int.cpp	2009-12-10 00:54:18.747800268 -0100
+++ mysql/extra/yassl/src/yassl_int.cpp	2009-12-10 00:57:22.944549884 -0100
@@ -25,6 +25,7 @@
 #include "yassl_int.hpp"
 #include "handshake.hpp"
 #include "timer.hpp"
+#include "my_global.h"
 
 #ifdef _POSIX_THREADS
     #include "pthread.h"
@@ -1052,12 +1053,12 @@
     size_t elements = buffers_.getData().size();
 
     data.set_length(0);                         // output, actual data filled
-    dataSz = min(dataSz, bufferedData());
+    dataSz = MYSQL_MIN(dataSz, bufferedData());
 
     for (size_t i = 0; i < elements; i++) {
         input_buffer* front = buffers_.getData().front();
         uint frontSz = front->get_remaining();
-        uint readSz  = min(dataSz - data.get_length(), frontSz);
+        uint readSz  = MYSQL_MIN(dataSz - data.get_length(), frontSz);
 
         front->read(data.set_buffer() + data.get_length(), readSz);
         data.set_length(data.get_length() + readSz);
@@ -1082,13 +1083,13 @@
     size_t elements = buffers_.getData().size();
 
     data.set_length(0);                         // output, actual data filled
-    dataSz = min(dataSz, bufferedData());
+    dataSz = MYSQL_MIN(dataSz, bufferedData());
 
     Buffers::inputList::iterator front = buffers_.useData().begin();
 
     while (elements) {
         uint frontSz = (*front)->get_remaining();
-        uint readSz  = min(dataSz - data.get_length(), frontSz);
+        uint readSz  = MYSQL_MIN(dataSz - data.get_length(), frontSz);
         uint before  = (*front)->get_current();
 
         (*front)->read(data.set_buffer() + data.get_length(), readSz);
@@ -1977,9 +1978,9 @@
         haystack = strstr(haystack, needle);
 
         if (!haystack)    // last cipher
-            len = min(sizeof(name), strlen(prev));
+            len = MYSQL_MIN(sizeof(name), strlen(prev));
         else
-            len = min(sizeof(name), (size_t)(haystack - prev));
+            len = MYSQL_MIN(sizeof(name), (size_t)(haystack - prev));
 
         strncpy(name, prev, len);
         name[(len == sizeof(name)) ? len - 1 : len] = 0;
diff -urN mysql-old/extra/yassl/taocrypt/src/algebra.cpp mysql/extra/yassl/taocrypt/src/algebra.cpp
--- mysql-old/extra/yassl/taocrypt/src/algebra.cpp	2009-12-10 00:54:18.749800229 -0100
+++ mysql/extra/yassl/taocrypt/src/algebra.cpp	2009-12-10 00:57:22.945550049 -0100
@@ -22,6 +22,7 @@
 
 #include "runtime.hpp"
 #include "algebra.hpp"
+#include "my_global.h"
 #ifdef USE_SYS_STL
     #include <vector>
 #else
@@ -109,7 +110,7 @@
 Integer AbstractGroup::CascadeScalarMultiply(const Element &x,
                   const Integer &e1, const Element &y, const Integer &e2) const
 {
-    const unsigned expLen = max(e1.BitCount(), e2.BitCount());
+    const unsigned expLen = MYSQL_MAX(e1.BitCount(), e2.BitCount());
     if (expLen==0)
         return Identity();
 
diff -urN mysql-old/extra/yassl/taocrypt/src/dh.cpp mysql/extra/yassl/taocrypt/src/dh.cpp
--- mysql-old/extra/yassl/taocrypt/src/dh.cpp	2009-12-10 00:54:18.749800229 -0100
+++ mysql/extra/yassl/taocrypt/src/dh.cpp	2009-12-10 00:57:22.945550049 -0100
@@ -23,6 +23,7 @@
 #include "runtime.hpp"
 #include "dh.hpp"
 #include "asn.hpp"
+#include "my_global.h"
 #include <math.h>
 
 namespace TaoCrypt {
@@ -54,7 +55,7 @@
 // Generate private value
 void DH::GeneratePrivate(RandomNumberGenerator& rng, byte* priv)
 {
-    Integer x(rng, Integer::One(), min(p_ - 1,
+    Integer x(rng, Integer::One(), MYSQL_MIN(p_ - 1,
         Integer::Power2(2*DiscreteLogWorkFactor(p_.BitCount())) ) );
     x.Encode(priv, p_.ByteCount());
 }
diff -urN mysql-old/extra/yassl/taocrypt/src/hash.cpp mysql/extra/yassl/taocrypt/src/hash.cpp
--- mysql-old/extra/yassl/taocrypt/src/hash.cpp	2009-12-10 00:54:18.749800229 -0100
+++ mysql/extra/yassl/taocrypt/src/hash.cpp	2009-12-10 00:57:22.946550129 -0100
@@ -22,6 +22,7 @@
 #include "runtime.hpp"
 #include <string.h>
 #include <assert.h>
+#include "my_global.h"
 
 #include "hash.hpp"
 
@@ -53,7 +54,7 @@
     byte*  local   = reinterpret_cast<byte*>(buffer_);
 
     while (len) {
-        word32 add = min(len, blockSz - buffLen_);
+        word32 add = MYSQL_MIN(len, blockSz - buffLen_);
         memcpy(&local[buffLen_], data, add);
 
         buffLen_ += add;
@@ -135,7 +136,7 @@
     byte*  local   = reinterpret_cast<byte*>(buffer_);
 
     while (len) {
-        word32 add = min(len, blockSz - buffLen_);
+        word32 add = MYSQL_MIN(len, blockSz - buffLen_);
         memcpy(&local[buffLen_], data, add);
 
         buffLen_ += add;
diff -urN mysql-old/extra/yassl/taocrypt/src/integer.cpp mysql/extra/yassl/taocrypt/src/integer.cpp
--- mysql-old/extra/yassl/taocrypt/src/integer.cpp	2009-12-10 00:54:18.748800554 -0100
+++ mysql/extra/yassl/taocrypt/src/integer.cpp	2009-12-10 00:57:22.947549909 -0100
@@ -24,7 +24,7 @@
 #include "integer.hpp"
 #include "modarith.hpp"
 #include "asn.hpp"
-
+#include "my_global.h"
 
 
 #ifdef __DECCXX
@@ -2675,7 +2675,7 @@
     else
     {
         // take two's complement of *this
-        Integer temp = Integer::Power2(8*max(ByteCount(), outputLen)) + *this;
+        Integer temp = Integer::Power2(8*MYSQL_MAX(ByteCount(), outputLen)) + *this;
         for (unsigned i=0; i<outputLen; i++)
             output[idx++] = temp.GetByte(outputLen-i-1);
     }
@@ -3009,7 +3009,7 @@
 
 unsigned int Integer::MinEncodedSize(Signedness signedness) const
 {
-    unsigned int outputLen = max(1U, ByteCount());
+    unsigned int outputLen = MYSQL_MAX(1U, ByteCount());
     if (signedness == UNSIGNED)
         return outputLen;
     if (NotNegative() && (GetByte(outputLen-1) & 0x80))
@@ -3138,7 +3138,7 @@
 
 Integer Integer::Plus(const Integer& b) const
 {
-    Integer sum((word)0, max(reg_.size(), b.reg_.size()));
+    Integer sum((word)0, MYSQL_MAX(reg_.size(), b.reg_.size()));
     if (NotNegative())
     {
         if (b.NotNegative())
@@ -3162,7 +3162,7 @@
 
 Integer Integer::Minus(const Integer& b) const
 {
-    Integer diff((word)0, max(reg_.size(), b.reg_.size()));
+    Integer diff((word)0, MYSQL_MAX(reg_.size(), b.reg_.size()));
     if (NotNegative())
     {
         if (b.NotNegative())
diff -urN mysql-old/extra/yassl/taocrypt/src/md5.cpp mysql/extra/yassl/taocrypt/src/md5.cpp
--- mysql-old/extra/yassl/taocrypt/src/md5.cpp	2009-12-10 00:54:18.748800554 -0100
+++ mysql/extra/yassl/taocrypt/src/md5.cpp	2009-12-10 00:57:22.948549881 -0100
@@ -92,7 +92,7 @@
 
     // remove buffered data if possible
     if (buffLen_)  {   
-        word32 add = min(len, BLOCK_SIZE - buffLen_);
+        word32 add = MYSQL_MIN(len, BLOCK_SIZE - buffLen_);
         memcpy(&local[buffLen_], data, add);
 
         buffLen_ += add;
diff -urN mysql-old/extra/yassl/taocrypt/src/ripemd.cpp mysql/extra/yassl/taocrypt/src/ripemd.cpp
--- mysql-old/extra/yassl/taocrypt/src/ripemd.cpp	2009-12-10 00:54:18.748800554 -0100
+++ mysql/extra/yassl/taocrypt/src/ripemd.cpp	2009-12-10 00:57:22.949549895 -0100
@@ -94,7 +94,7 @@
 
     // remove buffered data if possible
     if (buffLen_)  {   
-        word32 add = min(len, BLOCK_SIZE - buffLen_);
+        word32 add = MYSQL_MIN(len, BLOCK_SIZE - buffLen_);
         memcpy(&local[buffLen_], data, add);
 
         buffLen_ += add;
diff -urN mysql-old/extra/yassl/taocrypt/src/sha.cpp mysql/extra/yassl/taocrypt/src/sha.cpp
--- mysql-old/extra/yassl/taocrypt/src/sha.cpp	2009-12-10 00:54:18.748800554 -0100
+++ mysql/extra/yassl/taocrypt/src/sha.cpp	2009-12-10 00:57:22.950549861 -0100
@@ -327,7 +327,7 @@
 
     // remove buffered data if possible
     if (buffLen_)  {   
-        word32 add = min(len, BLOCK_SIZE - buffLen_);
+        word32 add = MYSQL_MIN(len, BLOCK_SIZE - buffLen_);
         memcpy(&local[buffLen_], data, add);
 
         buffLen_ += add;
diff -urN mysql-old/include/my_global.h mysql/include/my_global.h
--- mysql-old/include/my_global.h	2009-12-10 00:54:18.779802347 -0100
+++ mysql/include/my_global.h	2009-12-10 00:57:22.951607937 -0100
@@ -578,10 +578,8 @@
 #endif
 
 /* Define some useful general macros */
-#if !defined(max)
-#define max(a, b)	((a) > (b) ? (a) : (b))
-#define min(a, b)	((a) < (b) ? (a) : (b))
-#endif
+#define MYSQL_MAX(a, b)	((a) > (b) ? (a) : (b))
+#define MYSQL_MIN(a, b)	((a) < (b) ? (a) : (b))
 
 #if !defined(HAVE_UINT)
 #undef HAVE_UINT
@@ -1542,8 +1540,8 @@
 
 /* Define some useful general macros (should be done after all headers). */
 #if !defined(max)
-#define max(a, b)	((a) > (b) ? (a) : (b))
-#define min(a, b)	((a) < (b) ? (a) : (b))
+#define MYSQL_MAX(a, b)	((a) > (b) ? (a) : (b))
+#define MYSQL_MIN(a, b)	((a) < (b) ? (a) : (b))
 #endif  
 /*
   Only Linux is known to need an explicit sync of the directory to make sure a
diff -urN mysql-old/libmysql/libmysql.c mysql/libmysql/libmysql.c
--- mysql-old/libmysql/libmysql.c	2009-12-10 00:54:18.744801535 -0100
+++ mysql/libmysql/libmysql.c	2009-12-10 00:57:22.953925237 -0100
@@ -1570,7 +1570,7 @@
   my_net_set_read_timeout(net, CLIENT_NET_READ_TIMEOUT);
   my_net_set_write_timeout(net, CLIENT_NET_WRITE_TIMEOUT);
   net->retry_count=  1;
-  net->max_packet_size= max(net_buffer_length, max_allowed_packet);
+  net->max_packet_size= MYSQL_MAX(net_buffer_length, max_allowed_packet);
 }
 
 /*
@@ -3603,7 +3603,7 @@
       copy_length= end - start;
       /* We've got some data beyond offset: copy up to buffer_length bytes */
       if (param->buffer_length)
-        memcpy(buffer, start, min(copy_length, param->buffer_length));
+        memcpy(buffer, start, MYSQL_MIN(copy_length, param->buffer_length));
     }
     else
       copy_length= 0;
@@ -3836,9 +3836,9 @@
         precisions. This will ensure that on the same machine you get the
         same value as a string independent of the protocol you use.
       */
-      sprintf(buff, "%-*.*g", (int) min(sizeof(buff)-1,
+      sprintf(buff, "%-*.*g", (int) MYSQL_MIN(sizeof(buff)-1,
                                         param->buffer_length),
-              min(DBL_DIG, width), value);
+              MYSQL_MIN(DBL_DIG, width), value);
       end= strcend(buff, ' ');
       *end= 0;
     }
@@ -4156,7 +4156,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   *param->length= length;
   *param->error= copy_length < length;
@@ -4168,7 +4168,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   /* Add an end null if there is room in the buffer */
   if (copy_length != param->buffer_length)
diff -urN mysql-old/libmysqld/lib_sql.cc mysql/libmysqld/lib_sql.cc
--- mysql-old/libmysqld/lib_sql.cc	2009-12-10 00:54:18.661800728 -0100
+++ mysql/libmysqld/lib_sql.cc	2009-12-10 00:57:22.955848803 -0100
@@ -821,7 +821,7 @@
     is cleared between substatements, and mysqltest gets confused
   */
   thd->cur_data->embedded_info->warning_count=
-    (thd->spcont ? 0 : min(total_warn_count, 65535));
+    (thd->spcont ? 0 : MYSQL_MIN(total_warn_count, 65535));
   return FALSE;
 }
 
diff -urN mysql-old/mysys/array.c mysql/mysys/array.c
--- mysql-old/mysys/array.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/array.c	2009-12-10 00:57:22.956690677 -0100
@@ -47,7 +47,7 @@
   DBUG_ENTER("init_dynamic_array");
   if (!alloc_increment)
   {
-    alloc_increment=max((8192-MALLOC_OVERHEAD)/element_size,16);
+    alloc_increment=MYSQL_MAX((8192-MALLOC_OVERHEAD)/element_size,16);
     if (init_alloc > 8 && alloc_increment > init_alloc * 2)
       alloc_increment=init_alloc*2;
   }
@@ -341,7 +341,7 @@
 
 void freeze_size(DYNAMIC_ARRAY *array)
 {
-  uint elements=max(array->elements,1);
+  uint elements=MYSQL_MAX(array->elements,1);
 
   /*
     Do nothing if we are using a static buffer
diff -urN mysql-old/mysys/default.c mysql/mysys/default.c
--- mysql-old/mysys/default.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/default.c	2009-12-10 00:57:22.956690677 -0100
@@ -793,7 +793,7 @@
       for ( ; my_isspace(&my_charset_latin1,end[-1]) ; end--) ;
       end[0]=0;
 
-      strmake(curr_gr, ptr, min((size_t) (end-ptr)+1, sizeof(curr_gr)-1));
+      strmake(curr_gr, ptr, MYSQL_MIN((size_t) (end-ptr)+1, sizeof(curr_gr)-1));
 
       /* signal that a new group is found */
       opt_handler(handler_ctx, curr_gr, NULL);
diff -urN mysql-old/mysys/mf_dirname.c mysql/mysys/mf_dirname.c
--- mysql-old/mysys/mf_dirname.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/mf_dirname.c	2009-12-10 00:57:22.957925185 -0100
@@ -82,7 +82,7 @@
   SYNPOSIS
     convert_dirname()
     to				Store result here. Must be at least of size
-    				min(FN_REFLEN, strlen(from) + 1) to make room
+    				MYSQL_MIN(FN_REFLEN, strlen(from) + 1) to make room
     				for adding FN_LIBCHAR at the end.
     from			Original filename. May be == to
     from_end			Pointer at end of filename (normally end \0)
diff -urN mysql-old/mysys/mf_format.c mysql/mysys/mf_format.c
--- mysql-old/mysys/mf_format.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/mf_format.c	2009-12-10 00:57:22.957925185 -0100
@@ -83,7 +83,7 @@
     tmp_length= strlength(startpos);
     DBUG_PRINT("error",("dev: '%s'  ext: '%s'  length: %u",dev,ext,
                         (uint) length));
-    (void) strmake(to,startpos,min(tmp_length,FN_REFLEN-1));
+    (void) strmake(to,startpos,MYSQL_MIN(tmp_length,FN_REFLEN-1));
   }
   else
   {
diff -urN mysql-old/mysys/mf_iocache.c mysql/mysys/mf_iocache.c
--- mysql-old/mysys/mf_iocache.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/mf_iocache.c	2009-12-10 00:57:22.958901705 -0100
@@ -1097,7 +1097,7 @@
   */
   while (write_length)
   {
-    size_t copy_length= min(write_length, write_cache->buffer_length);
+    size_t copy_length= MYSQL_MIN(write_length, write_cache->buffer_length);
     int  __attribute__((unused)) rc;
 
     rc= lock_io_cache(write_cache, write_cache->pos_in_file);
@@ -1256,7 +1256,7 @@
       TODO: figure out if the assert below is needed or correct.
     */
     DBUG_ASSERT(pos_in_file == info->end_of_file);
-    copy_len=min(Count, len_in_buff);
+    copy_len=MYSQL_MIN(Count, len_in_buff);
     memcpy(Buffer, info->append_read_pos, copy_len);
     info->append_read_pos += copy_len;
     Count -= copy_len;
@@ -1365,7 +1365,7 @@
     }
 #endif
 	/* Copy found bytes to buffer */
-    length=min(Count,read_length);
+    length=MYSQL_MIN(Count,read_length);
     memcpy(Buffer,info->read_pos,(size_t) length);
     Buffer+=length;
     Count-=length;
@@ -1399,7 +1399,7 @@
       if ((read_length=my_read(info->file,info->request_pos,
 			       read_length, info->myflags)) == (size_t) -1)
         return info->error= -1;
-      use_length=min(Count,read_length);
+      use_length=MYSQL_MIN(Count,read_length);
       memcpy(Buffer,info->request_pos,(size_t) use_length);
       info->read_pos=info->request_pos+Count;
       info->read_end=info->request_pos+read_length;
diff -urN mysql-old/mysys/my_alloc.c mysql/mysys/my_alloc.c
--- mysql-old/mysys/my_alloc.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/my_alloc.c	2009-12-10 00:57:22.959925357 -0100
@@ -196,7 +196,7 @@
   {						/* Time to alloc new block */
     block_size= mem_root->block_size * (mem_root->block_num >> 2);
     get_size= length+ALIGN_SIZE(sizeof(USED_MEM));
-    get_size= max(get_size, block_size);
+    get_size= MYSQL_MAX(get_size, block_size);
 
     if (!(next = (USED_MEM*) my_malloc(get_size,MYF(MY_WME))))
     {
diff -urN mysql-old/mysys/my_bitmap.c mysql/mysys/my_bitmap.c
--- mysql-old/mysys/my_bitmap.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/my_bitmap.c	2009-12-10 00:57:22.960925083 -0100
@@ -365,7 +365,7 @@
 
   DBUG_ASSERT(map->bitmap && map2->bitmap);
 
-  end= to+min(len,len2);
+  end= to+MYSQL_MIN(len,len2);
   *map2->last_word_ptr&= ~map2->last_word_mask; /*Clear last bits in map2*/
   while (to < end)
     *to++ &= *from++;
diff -urN mysql-old/mysys/my_compress.c mysql/mysys/my_compress.c
--- mysql-old/mysys/my_compress.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/my_compress.c	2009-12-10 00:57:22.961925361 -0100
@@ -244,7 +244,7 @@
 
    if (ver != 1)
      DBUG_RETURN(1);
-   if (!(data= my_malloc(max(orglen, complen), MYF(MY_WME))))
+   if (!(data= my_malloc(MYSQL_MAX(orglen, complen), MYF(MY_WME))))
      DBUG_RETURN(2);
    memcpy(data, pack_data + BLOB_HEADER, complen);
 
diff -urN mysql-old/mysys/my_conio.c mysql/mysys/my_conio.c
--- mysql-old/mysys/my_conio.c	2009-12-10 00:54:18.750801052 -0100
+++ mysql/mysys/my_conio.c	2009-12-10 00:57:22.962639993 -0100
@@ -165,13 +165,13 @@
     though it is known it should not be more than 64K               
     so we cut 64K and try first size of screen buffer               
     if it is still to large we cut half of it and try again         
-    later we may want to cycle from min(clen, 65535) to allowed size
+    later we may want to cycle from MYSQL_MIN(clen, 65535) to allowed size
     with small decrement to determine exact allowed buffer           
   */
-  clen= min(clen, 65535);
+  clen= MYSQL_MIN(clen, 65535);
   do
   {
-    clen= min(clen, (size_t) csbi.dwSize.X*csbi.dwSize.Y);
+    clen= MYSQL_MIN(clen, (size_t) csbi.dwSize.X*csbi.dwSize.Y);
     if (!ReadConsole((HANDLE)my_coninpfh, (LPVOID)buffer, (DWORD) clen - 1, &plen_res,
                      NULL))
     {
diff -urN mysql-old/mysys/my_file.c mysql/mysys/my_file.c
--- mysql-old/mysys/my_file.c	2009-12-10 00:54:18.753800571 -0100
+++ mysql/mysys/my_file.c	2009-12-10 00:57:22.962639993 -0100
@@ -75,7 +75,7 @@
 static int set_max_open_files(uint max_file_limit)
 {
   /* We don't know the limit. Return best guess */
-  return min(max_file_limit, OS_FILE_LIMIT);
+  return MYSQL_MIN(max_file_limit, OS_FILE_LIMIT);
 }
 #endif
 
@@ -97,7 +97,7 @@
   DBUG_ENTER("my_set_max_open_files");
   DBUG_PRINT("enter",("files: %u  my_file_limit: %u", files, my_file_limit));
 
-  files= set_max_open_files(min(files, OS_FILE_LIMIT));
+  files= set_max_open_files(MYSQL_MIN(files, OS_FILE_LIMIT));
   if (files <= MY_NFILE)
     DBUG_RETURN(files);
 
@@ -107,9 +107,9 @@
 
   /* Copy any initialized files */
   memcpy((char*) tmp, (char*) my_file_info,
-         sizeof(*tmp) * min(my_file_limit, files));
+         sizeof(*tmp) * MYSQL_MIN(my_file_limit, files));
   bzero((char*) (tmp + my_file_limit),
-        max((int) (files- my_file_limit), 0)*sizeof(*tmp));
+        MYSQL_MAX((int) (files- my_file_limit), 0)*sizeof(*tmp));
   my_free_open_file_info();			/* Free if already allocated */
   my_file_info= tmp;
   my_file_limit= files;
diff -urN mysql-old/mysys/my_getopt.c mysql/mysys/my_getopt.c
--- mysql-old/mysys/my_getopt.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/my_getopt.c	2009-12-10 00:57:22.963651365 -0100
@@ -973,7 +973,7 @@
   }
   if (optp->max_value && num > (double) optp->max_value)
     num= (double) optp->max_value;
-  return max(num, (double) optp->min_value);
+  return MYSQL_MAX(num, (double) optp->min_value);
 }
 
 /*
diff -urN mysql-old/mysys/my_handler.c mysql/mysys/my_handler.c
--- mysql-old/mysys/my_handler.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/my_handler.c	2009-12-10 00:57:22.964925212 -0100
@@ -38,7 +38,7 @@
 static int compare_bin(uchar *a, uint a_length, uchar *b, uint b_length,
                        my_bool part_key, my_bool skip_end_space)
 {
-  uint length= min(a_length,b_length);
+  uint length= MYSQL_MIN(a_length,b_length);
   uchar *end= a+ length;
   int flag;
 
@@ -166,7 +166,7 @@
         continue;                               /* To next key part */
       }
     }
-    end= a+ min(keyseg->length,key_length);
+    end= a+ MYSQL_MIN(keyseg->length,key_length);
     next_key_length=key_length-keyseg->length;
 
     switch ((enum ha_base_keytype) keyseg->type) {
diff -urN mysql-old/mysys/my_static.h mysql/mysys/my_static.h
--- mysql-old/mysys/my_static.h	2009-12-10 00:54:18.753800571 -0100
+++ mysql/mysys/my_static.h	2009-12-10 00:57:22.965774449 -0100
@@ -22,7 +22,7 @@
 #include <signal.h>
 
 #define MAX_SIGNALS	10		/* Max signals under a dont-allow */
-#define MIN_KEYBLOCK	(min(IO_SIZE,1024))
+#define MIN_KEYBLOCK	(MYSQL_MIN(IO_SIZE,1024))
 #define MAX_KEYBLOCK	8192		/* Max keyblocklength == 8*IO_SIZE */
 #define MAX_BLOCK_TYPES MAX_KEYBLOCK/MIN_KEYBLOCK
 
diff -urN mysql-old/mysys/safemalloc.c mysql/mysys/safemalloc.c
--- mysql-old/mysys/safemalloc.c	2009-12-10 00:54:18.752800365 -0100
+++ mysql/mysys/safemalloc.c	2009-12-10 00:57:22.965774449 -0100
@@ -238,7 +238,7 @@
 
   if ((data= _mymalloc(size,filename,lineno,MyFlags))) /* Allocate new area */
   {
-    size=min(size, irem->datasize);		/* Move as much as possibly */
+    size=MYSQL_MIN(size, irem->datasize);		/* Move as much as possibly */
     memcpy((uchar*) data, ptr, (size_t) size);	/* Copy old data */
     _myfree(ptr, filename, lineno, 0);		/* Free not needed area */
   }
diff -urN mysql-old/mysys/stacktrace.c mysql/mysys/stacktrace.c
--- mysql-old/mysys/stacktrace.c	2009-12-10 00:54:18.751800772 -0100
+++ mysql/mysys/stacktrace.c	2009-12-10 00:57:22.966774370 -0100
@@ -210,7 +210,7 @@
 
   if (!stack_bottom || (uchar*) stack_bottom > (uchar*) &fp)
   {
-    ulong tmp= min(0x10000,thread_stack);
+    ulong tmp= MYSQL_MIN(0x10000,thread_stack);
     /* Assume that the stack starts at the previous even 65K */
     stack_bottom= (uchar*) (((ulong) &fp + tmp) &
 			  ~(ulong) 0xFFFF);
diff -urN mysql-old/server-tools/instance-manager/buffer.cc mysql/server-tools/instance-manager/buffer.cc
--- mysql-old/server-tools/instance-manager/buffer.cc	2009-12-10 00:54:18.529924821 -0100
+++ mysql/server-tools/instance-manager/buffer.cc	2009-12-10 00:57:22.966774370 -0100
@@ -83,8 +83,8 @@
   if (position + len_arg >= buffer_size)
   {
     buffer= (uchar*) my_realloc(buffer,
-                                min(MAX_BUFFER_SIZE,
-                                    max((uint) (buffer_size*1.5),
+                                MYSQL_MIN(MAX_BUFFER_SIZE,
+                                    MYSQL_MAX((uint) (buffer_size*1.5),
                                         position + len_arg)), MYF(0));
     if (!(buffer))
       goto err;
diff -urN mysql-old/server-tools/instance-manager/listener.cc mysql/server-tools/instance-manager/listener.cc
--- mysql-old/server-tools/instance-manager/listener.cc	2009-12-10 00:54:18.529924821 -0100
+++ mysql/server-tools/instance-manager/listener.cc	2009-12-10 00:57:22.967925092 -0100
@@ -103,7 +103,7 @@
 
   /* II. Listen sockets and spawn childs */
   for (i= 0; i < num_sockets; i++)
-    n= max(n, sockets[i]);
+    n= MYSQL_MAX(n, sockets[i]);
   n++;
 
   timeval tv;
diff -urN mysql-old/sql/field.cc mysql/sql/field.cc
--- mysql-old/sql/field.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/field.cc	2009-12-10 00:57:22.970925047 -0100
@@ -54,7 +54,7 @@
 #define LONGLONG_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define DECIMAL_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define BLOB_PACK_LENGTH_TO_MAX_LENGH(arg) \
-((ulong) ((LL(1) << min(arg, 4) * 8) - LL(1)))
+((ulong) ((LL(1) << MYSQL_MIN(arg, 4) * 8) - LL(1)))
 
 #define ASSERT_COLUMN_MARKED_FOR_READ DBUG_ASSERT(!table || (!table->read_set || bitmap_is_set(table->read_set, field_index)))
 #define ASSERT_COLUMN_MARKED_FOR_WRITE DBUG_ASSERT(!table || (!table->write_set || bitmap_is_set(table->write_set, field_index)))
@@ -2071,7 +2071,7 @@
     tmp_uint=tmp_dec+(uint)(int_digits_end-int_digits_from);
   else if (expo_sign_char == '-') 
   {
-    tmp_uint=min(exponent,(uint)(int_digits_end-int_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(int_digits_end-int_digits_from));
     frac_digits_added_zeros=exponent-tmp_uint;
     int_digits_end -= tmp_uint;
     frac_digits_head_end=int_digits_end+tmp_uint;
@@ -2079,7 +2079,7 @@
   }
   else // (expo_sign_char=='+') 
   {
-    tmp_uint=min(exponent,(uint)(frac_digits_end-frac_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(frac_digits_end-frac_digits_from));
     int_digits_added_zeros=exponent-tmp_uint;
     int_digits_tail_from=frac_digits_from;
     frac_digits_from=frac_digits_from+tmp_uint;
@@ -2559,7 +2559,7 @@
   }
   else
   {
-    uint room= min(DECIMAL_MAX_PRECISION - intg, DECIMAL_MAX_SCALE);
+    uint room= MYSQL_MIN(DECIMAL_MAX_PRECISION - intg, DECIMAL_MAX_SCALE);
     if (scale > room)
       scale= room;
   }
@@ -3130,7 +3130,7 @@
   ASSERT_COLUMN_MARKED_FOR_READ;
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,5*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,5*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
 
@@ -3342,7 +3342,7 @@
   ASSERT_COLUMN_MARKED_FOR_READ;
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,7*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,7*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   short j;
@@ -3559,7 +3559,7 @@
   ASSERT_COLUMN_MARKED_FOR_READ;
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,10*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,10*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   long j= unsigned_flag ? (long) uint3korr(ptr) : sint3korr(ptr);
@@ -3778,7 +3778,7 @@
   ASSERT_COLUMN_MARKED_FOR_READ;
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,12*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,12*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   int32 j;
@@ -4019,7 +4019,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,22*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,22*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   longlong j;
@@ -4242,7 +4242,7 @@
 #endif
     memcpy_fixed((uchar*) &nr,ptr,sizeof(nr));
 
-  uint to_length=max(field_length,70);
+  uint to_length=MYSQL_MAX(field_length,70);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -4600,7 +4600,7 @@
 #endif
     doubleget(nr,ptr);
 
-  uint to_length=max(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
+  uint to_length=MYSQL_MAX(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -6494,13 +6494,13 @@
     calculate the maximum number of significant digits if the 'f'-format
     would be used (+1 for decimal point if the number has a fractional part).
   */
-  digits= max(1, (int) max_length - fractional);
+  digits= MYSQL_MAX(1, (int) max_length - fractional);
   /*
     If the exponent is negative, decrease digits by the number of leading zeros
     after the decimal point that do not count as significant digits.
   */
   if (exp < 0)
-    digits= max(1, (int) digits + exp);
+    digits= MYSQL_MAX(1, (int) digits + exp);
   /*
     'e'-format is used only if the exponent is less than -4 or greater than or
     equal to the precision. In this case we need to adjust the number of
@@ -6508,7 +6508,7 @@
     We also have to reserve one additional character if abs(exp) >= 100.
   */
   if (exp >= (int) digits || exp < -4)
-    digits= max(1, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
+    digits= MYSQL_MAX(1, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
 
   /* Limit precision to DBL_DIG to avoid garbage past significant digits */
   set_if_smaller(digits, DBL_DIG);
@@ -6776,7 +6776,7 @@
                           uint max_length,
                           bool low_byte_first __attribute__((unused)))
 {
-  uint length=      min(field_length,max_length);
+  uint length=      MYSQL_MIN(field_length,max_length);
   uint local_char_length= max_length/field_charset->mbmaxlen;
   if (length > local_char_length)
     local_char_length= my_charpos(field_charset, from, from+length,
@@ -7771,7 +7771,7 @@
     from= tmpstr.ptr();
   }
 
-  new_length= min(max_data_length(), field_charset->mbmaxlen * length);
+  new_length= MYSQL_MIN(max_data_length(), field_charset->mbmaxlen * length);
   if (value.alloc(new_length))
     goto oom_error;
 
@@ -7931,7 +7931,7 @@
   b_length=get_length(b_ptr);
   if (b_length > max_length)
     b_length=max_length;
-  diff=memcmp(a,b,min(a_length,b_length));
+  diff=memcmp(a,b,MYSQL_MIN(a_length,b_length));
   return diff ? diff : (int) (a_length - b_length);
 }
 
@@ -8127,7 +8127,7 @@
     length given is smaller than the actual length of the blob, we
     just store the initial bytes of the blob.
   */
-  store_length(to, packlength, min(length, max_length), low_byte_first);
+  store_length(to, packlength, MYSQL_MIN(length, max_length), low_byte_first);
 
   /*
     Store the actual blob data, which will occupy 'length' bytes.
@@ -9120,7 +9120,7 @@
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   char buff[sizeof(longlong)];
-  uint length= min(pack_length(), sizeof(longlong));
+  uint length= MYSQL_MIN(pack_length(), sizeof(longlong));
   ulonglong bits= val_int();
   mi_int8store(buff,bits);
 
@@ -9206,7 +9206,7 @@
     *buff++= bits;
     length--;
   }
-  uint data_length = min(length, bytes_in_rec);
+  uint data_length = MYSQL_MIN(length, bytes_in_rec);
   memcpy(buff, ptr, data_length);
   return data_length + 1;
 }
@@ -9323,7 +9323,7 @@
     uchar bits= get_rec_bits(bit_ptr + (from - ptr), bit_ofs, bit_len);
     *to++= bits;
   }
-  length= min(bytes_in_rec, max_length - (bit_len > 0));
+  length= MYSQL_MIN(bytes_in_rec, max_length - (bit_len > 0));
   memcpy(to, from, length);
   return to + length;
 }
@@ -9778,9 +9778,9 @@
         shrink it to MAX_DATETIME_COMPRESSED_WIDTH.
       */
       DBUG_ASSERT(MAX_DATETIME_COMPRESSED_WIDTH < UINT_MAX);
-      if (length != UINT_MAX)  /* avoid overflow; is safe because of min() */
+      if (length != UINT_MAX)  /* avoid overflow; is safe because of MYSQL_MIN() */
         length= ((length+1)/2)*2;
-      length= min(length, MAX_DATETIME_COMPRESSED_WIDTH);
+      length= MYSQL_MIN(length, MAX_DATETIME_COMPRESSED_WIDTH);
     }
     flags|= ZEROFILL_FLAG | UNSIGNED_FLAG;
     /*
diff -urN mysql-old/sql/filesort.cc mysql/sql/filesort.cc
--- mysql-old/sql/filesort.cc	2009-12-10 00:54:18.671801382 -0100
+++ mysql/sql/filesort.cc	2009-12-10 00:57:22.974779086 -0100
@@ -191,7 +191,7 @@
 #ifdef CAN_TRUST_RANGE
   if (select && select->quick && select->quick->records > 0L)
   {
-    records=min((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
+    records=MYSQL_MIN((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
 		table->file->stats.records)+EXTRA_RECORDS;
     selected_records_file=0;
   }
@@ -213,12 +213,12 @@
     goto err;
 
   memavl= thd->variables.sortbuff_size;
-  min_sort_memory= max(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
+  min_sort_memory= MYSQL_MAX(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
   while (memavl >= min_sort_memory)
   {
     ulong old_memavl;
     ulong keys= memavl/(param.rec_length+sizeof(char*));
-    param.keys=(uint) min(records+1, keys);
+    param.keys=(uint) MYSQL_MIN(records+1, keys);
     if ((table_sort.sort_keys=
 	 (uchar **) make_char_array((char **) table_sort.sort_keys,
                                     param.keys, param.rec_length, MYF(0))))
@@ -1113,7 +1113,7 @@
   register uint count;
   uint length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(uchar*) buffpek->base,
 		 (length= rec_length*count),buffpek->file_pos,MYF_RW))
@@ -1376,7 +1376,7 @@
          != -1 && error != 0);
 
 end:
-  lastbuff->count= min(org_max_rows-max_rows, param->max_rows);
+  lastbuff->count= MYSQL_MIN(org_max_rows-max_rows, param->max_rows);
   lastbuff->file_pos= to_start_filepos;
 err:
   delete_queue(&queue);
diff -urN mysql-old/sql/ha_ndbcluster.cc mysql/sql/ha_ndbcluster.cc
--- mysql-old/sql/ha_ndbcluster.cc	2009-12-10 00:54:18.679801871 -0100
+++ mysql/sql/ha_ndbcluster.cc	2009-12-10 00:57:22.977924887 -0100
@@ -800,7 +800,7 @@
 
       DBUG_PRINT("value", ("set blob ptr: 0x%lx  len: %u",
                            (long) blob_ptr, blob_len));
-      DBUG_DUMP("value", blob_ptr, min(blob_len, 26));
+      DBUG_DUMP("value", blob_ptr, MYSQL_MIN(blob_len, 26));
 
       if (set_blob_value)
         *set_blob_value= TRUE;
diff -urN mysql-old/sql/handler.h mysql/sql/handler.h
--- mysql-old/sql/handler.h	2009-12-10 00:54:18.682800813 -0100
+++ mysql/sql/handler.h	2009-12-10 00:57:22.981809305 -0100
@@ -1590,15 +1590,15 @@
   { return (HA_ERR_WRONG_COMMAND); }
 
   uint max_record_length() const
-  { return min(HA_MAX_REC_LENGTH, max_supported_record_length()); }
+  { return MYSQL_MIN(HA_MAX_REC_LENGTH, max_supported_record_length()); }
   uint max_keys() const
-  { return min(MAX_KEY, max_supported_keys()); }
+  { return MYSQL_MIN(MAX_KEY, max_supported_keys()); }
   uint max_key_parts() const
-  { return min(MAX_REF_PARTS, max_supported_key_parts()); }
+  { return MYSQL_MIN(MAX_REF_PARTS, max_supported_key_parts()); }
   uint max_key_length() const
-  { return min(MAX_KEY_LENGTH, max_supported_key_length()); }
+  { return MYSQL_MIN(MAX_KEY_LENGTH, max_supported_key_length()); }
   uint max_key_part_length() const
-  { return min(MAX_KEY_LENGTH, max_supported_key_part_length()); }
+  { return MYSQL_MIN(MAX_KEY_LENGTH, max_supported_key_part_length()); }
 
   virtual uint max_supported_record_length() const { return HA_MAX_REC_LENGTH; }
   virtual uint max_supported_keys() const { return 0; }
diff -urN mysql-old/sql/item_buff.cc mysql/sql/item_buff.cc
--- mysql-old/sql/item_buff.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_buff.cc	2009-12-10 00:57:22.983708902 -0100
@@ -58,7 +58,7 @@
 */
 
 Cached_item_str::Cached_item_str(THD *thd, Item *arg)
-  :item(arg), value(min(arg->max_length, thd->variables.max_sort_length))
+  :item(arg), value(MYSQL_MIN(arg->max_length, thd->variables.max_sort_length))
 {}
 
 bool Cached_item_str::cmp(void)
@@ -67,7 +67,7 @@
   bool tmp;
 
   if ((res=item->val_str(&tmp_value)))
-    res->length(min(res->length(), value.alloced_length()));
+    res->length(MYSQL_MIN(res->length(), value.alloced_length()));
   if (null_value != item->null_value)
   {
     if ((null_value= item->null_value))
diff -urN mysql-old/sql/item.cc mysql/sql/item.cc
--- mysql-old/sql/item.cc	2009-12-10 00:54:18.678802160 -0100
+++ mysql/sql/item.cc	2009-12-10 00:57:22.985550189 -0100
@@ -25,6 +25,7 @@
 #include "sp_head.h"
 #include "sql_trigger.h"
 #include "sql_select.h"
+#include "my_global.h"
 
 const String my_null_string("NULL", 4, default_charset_info);
 
@@ -74,7 +75,7 @@
 Hybrid_type_traits_decimal::fix_length_and_dec(Item *item, Item *arg) const
 {
   item->decimals= arg->decimals;
-  item->max_length= min(arg->max_length + DECIMAL_LONGLONG_DIGITS,
+  item->max_length= MYSQL_MIN(arg->max_length + DECIMAL_LONGLONG_DIGITS,
                         DECIMAL_MAX_STR_LENGTH);
 }
 
@@ -748,7 +749,7 @@
 				   &res_length);
   }
   else
-    name= sql_strmake(str, (name_length= min(length,MAX_ALIAS_NAME)));
+    name= sql_strmake(str, (name_length= MYSQL_MIN(length,MAX_ALIAS_NAME)));
 }
 
 
@@ -5356,7 +5357,7 @@
   // following assert is redundant, because fixed=1 assigned in constructor
   DBUG_ASSERT(fixed == 1);
   char *end=(char*) str_value.ptr()+str_value.length(),
-       *ptr=end-min(str_value.length(),sizeof(longlong));
+       *ptr=end-MYSQL_MIN(str_value.length(),sizeof(longlong));
 
   ulonglong value=0;
   for (; ptr != end ; ptr++)
@@ -5411,7 +5412,7 @@
 void Item_hex_string::print(String *str, enum_query_type query_type)
 {
   char *end= (char*) str_value.ptr() + str_value.length(),
-       *ptr= end - min(str_value.length(), sizeof(longlong));
+       *ptr= end - MYSQL_MIN(str_value.length(), sizeof(longlong));
   str->append("0x");
   for (; ptr != end ; ptr++)
   {
@@ -7331,14 +7332,14 @@
     /* fix variable decimals which always is NOT_FIXED_DEC */
     if (Field::result_merge_type(fld_type) == INT_RESULT)
       item_decimals= 0;
-    decimals= max(decimals, item_decimals);
+    decimals= MYSQL_MAX(decimals, item_decimals);
   }
   if (Field::result_merge_type(fld_type) == DECIMAL_RESULT)
   {
-    decimals= min(max(decimals, item->decimals), DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(MYSQL_MAX(decimals, item->decimals), DECIMAL_MAX_SCALE);
     int item_int_part= item->decimal_int_part();
-    int item_prec = max(prev_decimal_int_part, item_int_part) + decimals;
-    int precision= min(item_prec, DECIMAL_MAX_PRECISION);
+    int item_prec = MYSQL_MAX(prev_decimal_int_part, item_int_part) + decimals;
+    int precision= MYSQL_MIN(item_prec, DECIMAL_MAX_PRECISION);
     unsigned_flag&= item->unsigned_flag;
     max_length= my_decimal_precision_to_length_no_truncation(precision,
                                                              decimals,
@@ -7369,7 +7370,7 @@
      */
     if (collation.collation != &my_charset_bin)
     {
-      max_length= max(old_max_chars * collation.collation->mbmaxlen,
+      max_length= MYSQL_MAX(old_max_chars * collation.collation->mbmaxlen,
                       display_length(item) /
                       item->collation.collation->mbmaxlen *
                       collation.collation->mbmaxlen);
@@ -7391,7 +7392,7 @@
       {
         int delta1= max_length_orig - decimals_orig;
         int delta2= item->max_length - item->decimals;
-        max_length= max(delta1, delta2) + decimals;
+        max_length= MYSQL_MAX(delta1, delta2) + decimals;
         if (fld_type == MYSQL_TYPE_FLOAT && max_length > FLT_DIG + 2)
         {
           max_length= MAX_FLOAT_STR_LENGTH;
@@ -7409,7 +7410,7 @@
     break;
   }
   default:
-    max_length= max(max_length, display_length(item));
+    max_length= MYSQL_MAX(max_length, display_length(item));
   };
   maybe_null|= item->maybe_null;
   get_full_info(item);
diff -urN mysql-old/sql/item_cmpfunc.cc mysql/sql/item_cmpfunc.cc
--- mysql-old/sql/item_cmpfunc.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_cmpfunc.cc	2009-12-10 00:57:22.989549921 -0100
@@ -613,7 +613,7 @@
   {
     if ((*a)->decimals < NOT_FIXED_DEC && (*b)->decimals < NOT_FIXED_DEC)
     {
-      precision= 5 / log_10[max((*a)->decimals, (*b)->decimals) + 1];
+      precision= 5 / log_10[MYSQL_MAX((*a)->decimals, (*b)->decimals) + 1];
       if (func == &Arg_comparator::compare_real)
         func= &Arg_comparator::compare_real_fixed;
       else if (func == &Arg_comparator::compare_e_real)
@@ -1119,7 +1119,7 @@
       owner->null_value= 0;
       uint res1_length= res1->length();
       uint res2_length= res2->length();
-      int cmp= memcmp(res1->ptr(), res2->ptr(), min(res1_length,res2_length));
+      int cmp= memcmp(res1->ptr(), res2->ptr(), MYSQL_MIN(res1_length,res2_length));
       return cmp ? cmp : (int) (res1_length - res2_length);
     }
   }
@@ -2142,7 +2142,7 @@
 {
   agg_result_type(&hybrid_type, args, 2);
   maybe_null=args[1]->maybe_null;
-  decimals= max(args[0]->decimals, args[1]->decimals);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
   unsigned_flag= args[0]->unsigned_flag && args[1]->unsigned_flag;
 
   if (hybrid_type == DECIMAL_RESULT || hybrid_type == INT_RESULT) 
@@ -2153,10 +2153,10 @@
     int len1= args[1]->max_length - args[1]->decimals
       - (args[1]->unsigned_flag ? 0 : 1);
 
-    max_length= max(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
+    max_length= MYSQL_MAX(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[0]->max_length, args[1]->max_length);
+    max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 
   switch (hybrid_type) {
   case STRING_RESULT:
@@ -2180,7 +2180,7 @@
 {
   int arg0_int_part= args[0]->decimal_int_part();
   int arg1_int_part= args[1]->decimal_int_part();
-  int max_int_part= max(arg0_int_part, arg1_int_part);
+  int max_int_part= MYSQL_MAX(arg0_int_part, arg1_int_part);
   int precision= max_int_part + decimals;
   return precision;
 }
@@ -2310,7 +2310,7 @@
 Item_func_if::fix_length_and_dec()
 {
   maybe_null=args[1]->maybe_null || args[2]->maybe_null;
-  decimals= max(args[1]->decimals, args[2]->decimals);
+  decimals= MYSQL_MAX(args[1]->decimals, args[2]->decimals);
   unsigned_flag=args[1]->unsigned_flag && args[2]->unsigned_flag;
 
   enum Item_result arg1_type=args[1]->result_type();
@@ -2354,10 +2354,10 @@
     int len2= args[2]->max_length - args[2]->decimals
       - (args[2]->unsigned_flag ? 0 : 1);
 
-    max_length=max(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
+    max_length=MYSQL_MAX(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[1]->max_length, args[2]->max_length);
+    max_length= MYSQL_MAX(args[1]->max_length, args[2]->max_length);
 }
 
 
@@ -2365,7 +2365,7 @@
 {
   int arg1_prec= args[1]->decimal_int_part();
   int arg2_prec= args[2]->decimal_int_part();
-  int precision=max(arg1_prec,arg2_prec) + decimals;
+  int precision=MYSQL_MAX(arg1_prec,arg2_prec) + decimals;
   return precision;
 }
 
@@ -4662,7 +4662,7 @@
       else
       {
 	if (i < g)
-	  g = i; // g = min(i, g)
+	  g = i; // g = MYSQL_MIN(i, g)
 	f = i;
 	while (g >= 0 && pattern[g] == pattern[g + plm1 - f])
 	  g--;
@@ -4681,7 +4681,7 @@
       else
       {
 	if (i < g)
-	  g = i; // g = min(i, g)
+	  g = i; // g = MYSQL_MIN(i, g)
 	f = i;
 	while (g >= 0 &&
 	       likeconv(cs, pattern[g]) == likeconv(cs, pattern[g + plm1 - f]))
@@ -4802,14 +4802,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) (uchar) text[i + j]] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
@@ -4833,14 +4833,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) likeconv(cs, text[i + j])] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
diff -urN mysql-old/sql/item_func.cc mysql/sql/item_func.cc
--- mysql-old/sql/item_func.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_func.cc	2009-12-10 00:57:22.991631422 -0100
@@ -541,7 +541,7 @@
     set_if_bigger(max_int_part, args[i]->decimal_int_part());
     set_if_smaller(unsigned_flag, args[i]->unsigned_flag);
   }
-  int precision= min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  int precision= MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length_no_truncation(precision, decimals,
                                                            unsigned_flag);
 }
@@ -1135,10 +1135,10 @@
 */
 void Item_func_additive_op::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
   int arg1_int= args[0]->decimal_precision() - args[0]->decimals;
   int arg2_int= args[1]->decimal_precision() - args[1]->decimals;
-  int precision= max(arg1_int, arg2_int) + 1 + decimals;
+  int precision= MYSQL_MAX(arg1_int, arg2_int) + 1 + decimals;
 
   /* Integer operations keep unsigned_flag if one of arguments is unsigned */
   if (result_type() == INT_RESULT)
@@ -1248,9 +1248,9 @@
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
+  decimals= MYSQL_MIN(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
   uint est_prec = args[0]->decimal_precision() + args[1]->decimal_precision();
-  uint precision= min(est_prec, DECIMAL_MAX_PRECISION);
+  uint precision= MYSQL_MIN(est_prec, DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length_no_truncation(precision, decimals,
                                                            unsigned_flag);
 }
@@ -1298,7 +1298,7 @@
 
 void Item_func_div::result_precision()
 {
-  uint precision=min(args[0]->decimal_precision() + 
+  uint precision=MYSQL_MIN(args[0]->decimal_precision() + 
                      args[1]->decimals + prec_increment,
                      DECIMAL_MAX_PRECISION);
 
@@ -1307,7 +1307,7 @@
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+  decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
   max_length= my_decimal_precision_to_length_no_truncation(precision, decimals,
                                                            unsigned_flag);
 }
@@ -1321,7 +1321,7 @@
   switch(hybrid_type) {
   case REAL_RESULT:
   {
-    decimals=max(args[0]->decimals,args[1]->decimals)+prec_increment;
+    decimals=MYSQL_MAX(args[0]->decimals,args[1]->decimals)+prec_increment;
     set_if_smaller(decimals, NOT_FIXED_DEC);
     max_length=args[0]->max_length - args[0]->decimals + decimals;
     uint tmp=float_length(decimals);
@@ -1443,8 +1443,8 @@
 
 void Item_func_mod::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
-  max_length= max(args[0]->max_length, args[1]->max_length);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
+  max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 }
 
 
@@ -1962,7 +1962,7 @@
 
   if (args[0]->decimals == NOT_FIXED_DEC)
   {
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     max_length= float_length(decimals);
     hybrid_type= REAL_RESULT;
     return;
@@ -1972,7 +1972,7 @@
   case REAL_RESULT:
   case STRING_RESULT:
     hybrid_type= REAL_RESULT;
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     max_length= float_length(decimals);
     break;
   case INT_RESULT:
@@ -1989,13 +1989,13 @@
   case DECIMAL_RESULT:
   {
     hybrid_type= DECIMAL_RESULT;
-    decimals_to_set= min(DECIMAL_MAX_SCALE, decimals_to_set);
+    decimals_to_set= MYSQL_MIN(DECIMAL_MAX_SCALE, decimals_to_set);
     int decimals_delta= args[0]->decimals - decimals_to_set;
     int precision= args[0]->decimal_precision();
     int length_increase= ((decimals_delta <= 0) || truncate) ? 0:1;
 
     precision-= decimals_delta - length_increase;
-    decimals= min(decimals_to_set, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(decimals_to_set, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length_no_truncation(precision,
                                                              decimals,
                                                              unsigned_flag);
@@ -2096,7 +2096,7 @@
   my_decimal val, *value= args[0]->val_decimal(&val);
   longlong dec= args[1]->val_int();
   if (dec >= 0 || args[1]->unsigned_flag)
-    dec= min((ulonglong) dec, decimals);
+    dec= MYSQL_MIN((ulonglong) dec, decimals);
   else if (dec < INT_MIN)
     dec= INT_MIN;
     
@@ -2955,7 +2955,7 @@
       free_udf(u_d);
       DBUG_RETURN(TRUE);
     }
-    func->max_length=min(initid.max_length,MAX_BLOB_WIDTH);
+    func->max_length=MYSQL_MIN(initid.max_length,MAX_BLOB_WIDTH);
     func->maybe_null=initid.maybe_null;
     const_item_cache=initid.const_item;
     /* 
@@ -2964,7 +2964,7 @@
     */  
     if (!const_item_cache && !used_tables_cache)
       used_tables_cache= RAND_TABLE_BIT;
-    func->decimals=min(initid.decimals,NOT_FIXED_DEC);
+    func->decimals=MYSQL_MIN(initid.decimals,NOT_FIXED_DEC);
   }
   initialized=1;
   if (error)
diff -urN mysql-old/sql/item_func.h mysql/sql/item_func.h
--- mysql-old/sql/item_func.h	2009-12-10 00:54:18.683801106 -0100
+++ mysql/sql/item_func.h	2009-12-10 00:57:22.994795850 -0100
@@ -363,7 +363,7 @@
   const char *func_name() const { return "cast_as_unsigned"; }
   void fix_length_and_dec()
   {
-    max_length= min(args[0]->max_length, DECIMAL_MAX_PRECISION + 2);
+    max_length= MYSQL_MIN(args[0]->max_length, DECIMAL_MAX_PRECISION + 2);
     unsigned_flag=1;
   }
   longlong val_int();
diff -urN mysql-old/sql/item_strfunc.cc mysql/sql/item_strfunc.cc
--- mysql-old/sql/item_strfunc.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_strfunc.cc	2009-12-10 00:57:22.996753758 -0100
@@ -384,7 +384,7 @@
           }
           else
           {
-            uint new_len = max(tmp_value.alloced_length() * 2, concat_len);
+            uint new_len = MYSQL_MAX(tmp_value.alloced_length() * 2, concat_len);
 
             if (tmp_value.realloc(new_len))
               goto null;
@@ -738,7 +738,7 @@
         }
         else
         {
-          uint new_len = max(tmp_value.alloced_length() * 2, concat_len);
+          uint new_len = MYSQL_MAX(tmp_value.alloced_length() * 2, concat_len);
 
           if (tmp_value.realloc(new_len))
             goto null;
@@ -1220,7 +1220,7 @@
 
   length= res->charpos((int) length, (uint32) start);
   tmp_length= res->length() - start;
-  length= min(length, tmp_length);
+  length= MYSQL_MIN(length, tmp_length);
 
   if (!start && (longlong) res->length() == length)
     return res;
@@ -1240,7 +1240,7 @@
     if (start < 0)
       max_length= ((uint)(-start) > max_length) ? 0 : (uint)(-start);
     else
-      max_length-= min((uint)(start - 1), max_length);
+      max_length-= MYSQL_MIN((uint)(start - 1), max_length);
   }
   if (arg_count == 3 && args[2]->const_item())
   {
@@ -1934,7 +1934,7 @@
   if ((null_value= args[0]->null_value))
     return 0; /* purecov: inspected */
 
-  if (tmp_value.alloc(max(res->length(), 4 * cs->mbminlen)))
+  if (tmp_value.alloc(MYSQL_MAX(res->length(), 4 * cs->mbminlen)))
     return str; /* purecov: inspected */
   char *to= (char *) tmp_value.ptr();
   char *to_end= to + tmp_value.alloced_length();
@@ -3065,11 +3065,11 @@
 
 void Item_func_export_set::fix_length_and_dec()
 {
-  uint length=max(args[1]->max_length,args[2]->max_length);
+  uint length=MYSQL_MAX(args[1]->max_length,args[2]->max_length);
   uint sep_length=(arg_count > 3 ? args[3]->max_length : 1);
   max_length=length*64+sep_length*63;
 
-  if (agg_arg_charsets(collation, args+1, min(4,arg_count)-1,
+  if (agg_arg_charsets(collation, args+1, MYSQL_MIN(4,arg_count)-1,
                        MY_COLL_ALLOW_CONV, 1))
     return;
 }
@@ -3475,7 +3475,7 @@
       /*
         -1 so we won't make tv= uuid_time for nanoseq >= (tv - uuid_time)
       */
-      ulong delta= min(nanoseq, (ulong) (tv - uuid_time -1));
+      ulong delta= MYSQL_MIN(nanoseq, (ulong) (tv - uuid_time -1));
       tv-= delta;
       nanoseq-= delta;
     }
diff -urN mysql-old/sql/item_sum.cc mysql/sql/item_sum.cc
--- mysql-old/sql/item_sum.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_sum.cc	2009-12-10 00:57:22.998800288 -0100
@@ -1169,7 +1169,7 @@
     AVG() will divide val by count. We need to reserve digits
     after decimal point as the result can be fractional.
   */
-  decimals= min(decimals + prec_increment, NOT_FIXED_DEC);
+  decimals= MYSQL_MIN(decimals + prec_increment, NOT_FIXED_DEC);
 }
 
 
@@ -1232,16 +1232,16 @@
   if (hybrid_type == DECIMAL_RESULT)
   {
     int precision= args[0]->decimal_precision() + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length_no_truncation(precision,
                                                              decimals,
                                                              unsigned_flag);
-    f_precision= min(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
+    f_precision= MYSQL_MIN(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
     f_scale=  args[0]->decimals;
     dec_bin_size= my_decimal_get_binary_size(f_precision, f_scale);
   }
   else {
-    decimals= min(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
     max_length= args[0]->max_length + prec_increment;
   }
 }
@@ -1433,13 +1433,13 @@
   switch (args[0]->result_type()) {
   case REAL_RESULT:
   case STRING_RESULT:
-    decimals= min(args[0]->decimals + 4, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + 4, NOT_FIXED_DEC);
     break;
   case INT_RESULT:
   case DECIMAL_RESULT:
   {
     int precision= args[0]->decimal_precision()*2 + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length_no_truncation(precision,
                                                              decimals,
                                                              unsigned_flag);
@@ -3519,7 +3519,7 @@
       syntax of this function). If there is no ORDER BY clause, we don't
       create this tree.
     */
-    init_tree(tree, (uint) min(thd->variables.max_heap_table_size,
+    init_tree(tree, (uint) MYSQL_MIN(thd->variables.max_heap_table_size,
                                thd->variables.sortbuff_size/16), 0,
               tree_key_length, 
               group_concat_key_cmp_with_order , 0, NULL, (void*) this);
diff -urN mysql-old/sql/item_timefunc.cc mysql/sql/item_timefunc.cc
--- mysql-old/sql/item_timefunc.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/item_timefunc.cc	2009-12-10 00:57:23.000552809 -0100
@@ -313,14 +313,14 @@
       switch (*++ptr) {
 	/* Year */
       case 'Y':
-	tmp= (char*) val + min(4, val_len);
+	tmp= (char*) val + MYSQL_MIN(4, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
         if ((int) (tmp-val) <= 2)
           l_time->year= year_2000_handling(l_time->year);
 	val= tmp;
 	break;
       case 'y':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
         l_time->year= year_2000_handling(l_time->year);
@@ -329,7 +329,7 @@
 	/* Month */
       case 'm':
       case 'c':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->month= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -346,15 +346,15 @@
 	/* Day */
       case 'd':
       case 'e':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
       case 'D':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	/* Skip 'st, 'nd, 'th .. */
-	val= tmp + min((int) (val_end-tmp), 2);
+	val= tmp + MYSQL_MIN((int) (val_end-tmp), 2);
 	break;
 
 	/* Hour */
@@ -365,14 +365,14 @@
 	/* fall through */
       case 'k':
       case 'H':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->hour= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
 
 	/* Minute */
       case 'i':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->minute= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -380,7 +380,7 @@
 	/* Second */
       case 's':
       case 'S':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->second= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -432,7 +432,7 @@
 	val= tmp;
 	break;
       case 'j':
-	tmp= (char*) val + min(val_len, 3);
+	tmp= (char*) val + MYSQL_MIN(val_len, 3);
 	yearday= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -444,7 +444,7 @@
       case 'u':
         sunday_first_n_first_week_non_iso= (*ptr=='U' || *ptr== 'V');
         strict_week_number= (*ptr=='V' || *ptr=='v');
-	tmp= (char*) val + min(val_len, 2);
+	tmp= (char*) val + MYSQL_MIN(val_len, 2);
 	if ((week_number= (int) my_strtoll10(val, &tmp, &error)) < 0 ||
             (strict_week_number && !week_number) ||
             week_number > 53)
@@ -456,7 +456,7 @@
       case 'X':
       case 'x':
         strict_week_number_year_type= (*ptr=='X');
-        tmp= (char*) val + min(4, val_len);
+        tmp= (char*) val + MYSQL_MIN(4, val_len);
         strict_week_number_year= (int) my_strtoll10(val, &tmp, &error);
         val= tmp;
         break;
@@ -601,7 +601,7 @@
 err:
   {
     char buff[128];
-    strmake(buff, val_begin, min(length, sizeof(buff)-1));
+    strmake(buff, val_begin, MYSQL_MIN(length, sizeof(buff)-1));
     push_warning_printf(current_thd, MYSQL_ERROR::WARN_LEVEL_ERROR,
                         ER_WRONG_VALUE_FOR_TYPE, ER(ER_WRONG_VALUE_FOR_TYPE),
                         date_time_type, buff, "str_to_date");
@@ -1838,7 +1838,7 @@
   else
   {
     fixed_length=0;
-    max_length=min(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
+    max_length=MYSQL_MIN(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
                    collation.collation->mbmaxlen;
     set_if_smaller(max_length,MAX_BLOB_WIDTH);
   }
diff -urN mysql-old/sql/key.cc mysql/sql/key.cc
--- mysql-old/sql/key.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/key.cc	2009-12-10 00:57:23.001924865 -0100
@@ -125,13 +125,13 @@
         key_part->key_part_flag & HA_VAR_LENGTH_PART)
     {
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       key_part->field->get_key_image(to_key, length, Field::itRAW);
       to_key+= HA_KEY_BLOB_LENGTH;
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       Field *field= key_part->field;
       CHARSET_INFO *cs= field->charset();
       uint bytes= field->get_key_image(to_key, length, Field::itRAW);
@@ -215,7 +215,7 @@
       my_ptrdiff_t ptrdiff= to_record - field->table->record[0];
       field->move_field_offset(ptrdiff);
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       old_map= dbug_tmp_use_all_columns(field->table, field->table->write_set);
       field->set_key_image(from_key, length);
       dbug_tmp_restore_column_map(field->table->write_set, old_map);
@@ -224,7 +224,7 @@
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       /* skip the byte with 'uneven' bits, if used */
       memcpy(to_record + key_part->offset, from_key + used_uneven_bits
              , (size_t) length - used_uneven_bits);
@@ -285,7 +285,7 @@
 	return 1;
       continue;
     }
-    length= min((uint) (key_end-key), store_length);
+    length= MYSQL_MIN((uint) (key_end-key), store_length);
     if (!(key_part->key_type & (FIELDFLAG_NUMBER+FIELDFLAG_BINARY+
                                 FIELDFLAG_PACK)))
     {
@@ -351,7 +351,7 @@
     {
       field->val_str(&tmp);
       if (key_part->length < field->pack_length())
-	tmp.length(min(tmp.length(),key_part->length));
+	tmp.length(MYSQL_MIN(tmp.length(),key_part->length));
       to->append(tmp);
     }
     else
diff -urN mysql-old/sql/log.cc mysql/sql/log.cc
--- mysql-old/sql/log.cc	2009-12-10 00:54:18.673801019 -0100
+++ mysql/sql/log.cc	2009-12-10 00:57:23.112778227 -0100
@@ -594,11 +594,11 @@
     t.neg= 0;
 
     /* fill in query_time field */
-    calc_time_from_sec(&t, (long) min(query_time, (longlong) TIME_MAX_VALUE_SECONDS), 0);
+    calc_time_from_sec(&t, (long) MYSQL_MIN(query_time, (longlong) TIME_MAX_VALUE_SECONDS), 0);
     if (table->field[2]->store_time(&t, MYSQL_TIMESTAMP_TIME))
       goto err;
     /* lock_time */
-    calc_time_from_sec(&t, (long) min(lock_time, (longlong) TIME_MAX_VALUE_SECONDS), 0);
+    calc_time_from_sec(&t, (long) MYSQL_MIN(lock_time, (longlong) TIME_MAX_VALUE_SECONDS), 0);
     if (table->field[3]->store_time(&t, MYSQL_TIMESTAMP_TIME))
       goto err;
     /* rows_sent */
@@ -2402,7 +2402,7 @@
   {
     char *p= fn_ext(log_name);
     uint length= (uint) (p - log_name);
-    strmake(buff, log_name, min(length, FN_REFLEN));
+    strmake(buff, log_name, MYSQL_MIN(length, FN_REFLEN));
     return (const char*)buff;
   }
   return log_name;
@@ -4859,7 +4859,7 @@
   DBUG_ENTER("print_buffer_to_nt_eventlog");
 
   /* Add ending CR/LF's to string, overwrite last chars if necessary */
-  strmov(buffptr+min(length, buffLen-5), "\r\n\r\n");
+  strmov(buffptr+MYSQL_MIN(length, buffLen-5), "\r\n\r\n");
 
   setup_windows_event_source();
   if ((event= RegisterEventSource(NULL,"MySQL")))
diff -urN mysql-old/sql/log_event.cc mysql/sql/log_event.cc
--- mysql-old/sql/log_event.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/log_event.cc	2009-12-10 00:57:23.117925330 -0100
@@ -1070,7 +1070,7 @@
     of 13 bytes, whereas LOG_EVENT_MINIMAL_HEADER_LEN is 19 bytes (it's
     "minimal" over the set {MySQL >=4.0}).
   */
-  uint header_size= min(description_event->common_header_len,
+  uint header_size= MYSQL_MIN(description_event->common_header_len,
                         LOG_EVENT_MINIMAL_HEADER_LEN);
 
   LOCK_MUTEX;
@@ -2576,7 +2576,7 @@
       be even bigger, but this will suffice to catch most corruption
       errors that can lead to a crash.
     */
-    if (status_vars_len > min(data_len, MAX_SIZE_LOG_EVENT_STATUS))
+    if (status_vars_len > MYSQL_MIN(data_len, MAX_SIZE_LOG_EVENT_STATUS))
     {
       DBUG_PRINT("info", ("status_vars_len (%u) > data_len (%lu); query= 0",
                           status_vars_len, data_len));
@@ -5411,7 +5411,7 @@
   char buf[UV_NAME_LEN_SIZE];
   char buf1[UV_VAL_IS_NULL + UV_VAL_TYPE_SIZE + 
 	    UV_CHARSET_NUMBER_SIZE + UV_VAL_LEN_SIZE];
-  uchar buf2[max(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
+  uchar buf2[MYSQL_MAX(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
   uint buf1_length;
   ulong event_length;
 
@@ -7135,7 +7135,7 @@
     trigger false warnings.
    */
 #ifndef HAVE_purify
-  DBUG_DUMP("row_data", row_data, min(length, 32));
+  DBUG_DUMP("row_data", row_data, MYSQL_MIN(length, 32));
 #endif
 
   DBUG_ASSERT(m_rows_buf <= m_rows_cur);
diff -urN mysql-old/sql/log_event_old.cc mysql/sql/log_event_old.cc
--- mysql-old/sql/log_event_old.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/log_event_old.cc	2009-12-10 00:57:23.164686969 -0100
@@ -1405,7 +1405,7 @@
     trigger false warnings.
    */
 #ifndef HAVE_purify
-  DBUG_DUMP("row_data", row_data, min(length, 32));
+  DBUG_DUMP("row_data", row_data, MYSQL_MIN(length, 32));
 #endif
 
   DBUG_ASSERT(m_rows_buf <= m_rows_cur);
diff -urN mysql-old/sql/mysqld.cc mysql/sql/mysqld.cc
--- mysql-old/sql/mysqld.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/mysqld.cc	2009-12-10 00:57:23.167925364 -0100
@@ -3298,7 +3298,7 @@
       can't get max_connections*5 but still got no less than was
       requested (value of wanted_files).
     */
-    max_open_files= max(max(wanted_files, max_connections*5),
+    max_open_files= MYSQL_MAX(MYSQL_MAX(wanted_files, max_connections*5),
                         open_files_limit);
     files= my_set_max_open_files(max_open_files);
 
@@ -3310,15 +3310,15 @@
           If we have requested too much file handles than we bring
           max_connections in supported bounds.
         */
-        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,
+        max_connections= (ulong) MYSQL_MIN(files-10-TABLE_OPEN_CACHE_MIN*2,
                                      max_connections);
         /*
           Decrease table_cache_size according to max_connections, but
-          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we
+          not below TABLE_OPEN_CACHE_MIN.  Outer MYSQL_MIN() ensures that we
           never increase table_cache_size automatically (that could
           happen if max_connections is decreased above).
         */
-        table_cache_size= (ulong) min(max((files-10-max_connections)/2,
+        table_cache_size= (ulong) MYSQL_MIN(MYSQL_MAX((files-10-max_connections)/2,
                                           TABLE_OPEN_CACHE_MIN),
                                       table_cache_size);
 	DBUG_PRINT("warning",
@@ -4967,7 +4967,7 @@
 {
   my_socket sock,new_sock;
   uint error_count=0;
-  uint max_used_connection= (uint) (max(ip_sock,unix_sock)+1);
+  uint max_used_connection= (uint) (MYSQL_MAX(ip_sock,unix_sock)+1);
   fd_set readFDs,clientFDs;
   THD *thd;
   struct sockaddr_in cAddr;
diff -urN mysql-old/sql/net_serv.cc mysql/sql/net_serv.cc
--- mysql-old/sql/net_serv.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/net_serv.cc	2009-12-10 00:57:23.172885103 -0100
@@ -756,7 +756,7 @@
   {
     while (remain > 0)
     {
-      size_t length= min(remain, net->max_packet);
+      size_t length= MYSQL_MIN(remain, net->max_packet);
       if (net_safe_read(net, net->buff, length, alarmed))
 	DBUG_RETURN(1);
       update_statistics(thd_increment_bytes_received(length));
@@ -941,7 +941,7 @@
 	len=uint3korr(net->buff+net->where_b);
 	if (!len)				/* End of big multi-packet */
 	  goto end;
-	helping = max(len,*complen) + net->where_b;
+	helping = MYSQL_MAX(len,*complen) + net->where_b;
 	/* The necessary size of net->buff */
 	if (helping >= net->max_packet)
 	{
diff -urN mysql-old/sql/opt_range.cc mysql/sql/opt_range.cc
--- mysql-old/sql/opt_range.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/opt_range.cc	2009-12-10 00:57:23.175925139 -0100
@@ -2352,7 +2352,7 @@
     group_trp= get_best_group_min_max(&param, tree);
     if (group_trp)
     {
-      param.table->quick_condition_rows= min(group_trp->records,
+      param.table->quick_condition_rows= MYSQL_MIN(group_trp->records,
                                              head->file->stats.records);
       if (group_trp->read_cost < best_read_time)
       {
@@ -3828,7 +3828,7 @@
     {
       imerge_trp->read_cost= imerge_cost;
       imerge_trp->records= non_cpk_scan_records + cpk_scan_records;
-      imerge_trp->records= min(imerge_trp->records,
+      imerge_trp->records= MYSQL_MIN(imerge_trp->records,
                                param->table->file->stats.records);
       imerge_trp->range_scans= range_scans;
       imerge_trp->range_scans_end= range_scans + n_child_scans;
@@ -7341,7 +7341,7 @@
       param->table->quick_key_parts[key]=param->max_key_part+1;
       param->table->quick_n_ranges[key]= param->n_ranges;
       param->table->quick_condition_rows=
-        min(param->table->quick_condition_rows, records);
+        MYSQL_MIN(param->table->quick_condition_rows, records);
     }
     /*
       Need to save quick_rows in any case as it is used when calculating
@@ -7410,7 +7410,7 @@
   uchar *tmp_min_key, *tmp_max_key;
   uint8 save_first_null_comp= param->first_null_comp;
 
-  param->max_key_part=max(param->max_key_part,key_tree->part);
+  param->max_key_part=MYSQL_MAX(param->max_key_part,key_tree->part);
   if (key_tree->left != &null_element)
   {
     /*
@@ -8325,13 +8325,13 @@
   /* Do not allocate the buffers twice. */
   if (multi_range_length)
   {
-    DBUG_ASSERT(multi_range_length == min(multi_range_count, ranges.elements));
+    DBUG_ASSERT(multi_range_length == MYSQL_MIN(multi_range_count, ranges.elements));
     DBUG_RETURN(0);
   }
 
   /* Allocate the ranges array. */
   DBUG_ASSERT(ranges.elements);
-  multi_range_length= min(multi_range_count, ranges.elements);
+  multi_range_length= MYSQL_MIN(multi_range_count, ranges.elements);
   DBUG_ASSERT(multi_range_length > 0);
   while (multi_range_length && ! (multi_range= (KEY_MULTI_RANGE*)
                                   my_malloc(multi_range_length *
@@ -8350,7 +8350,7 @@
   /* Allocate the handler buffer if necessary.  */
   if (file->ha_table_flags() & HA_NEED_READ_RANGE_BUFFER)
   {
-    mrange_bufsiz= min(multi_range_bufsiz,
+    mrange_bufsiz= MYSQL_MIN(multi_range_bufsiz,
                        ((uint)QUICK_SELECT_I::records + 1)* head->s->reclength);
 
     while (mrange_bufsiz &&
@@ -8433,7 +8433,7 @@
         goto end;
     }
 
-    uint count= min(multi_range_length, ranges.elements -
+    uint count= MYSQL_MIN(multi_range_length, ranges.elements -
                     (cur_range - (QUICK_RANGE**) ranges.buffer));
     if (count == 0)
     {
@@ -8546,13 +8546,13 @@
     last_range= *(cur_range++);
 
     start_key.key=    (const uchar*) last_range->min_key;
-    start_key.length= min(last_range->min_length, prefix_length);
+    start_key.length= MYSQL_MIN(last_range->min_length, prefix_length);
     start_key.keypart_map= last_range->min_keypart_map & keypart_map;
     start_key.flag=   ((last_range->flag & NEAR_MIN) ? HA_READ_AFTER_KEY :
 		       (last_range->flag & EQ_RANGE) ?
 		       HA_READ_KEY_EXACT : HA_READ_KEY_OR_NEXT);
     end_key.key=      (const uchar*) last_range->max_key;
-    end_key.length=   min(last_range->max_length, prefix_length);
+    end_key.length=   MYSQL_MIN(last_range->max_length, prefix_length);
     end_key.keypart_map= last_range->max_keypart_map & keypart_map;
     /*
       We use READ_AFTER_KEY here because if we are reading on a key
@@ -9161,7 +9161,7 @@
 
   TODO
   - What happens if the query groups by the MIN/MAX field, and there is no
-    other field as in: "select min(a) from t1 group by a" ?
+    other field as in: "select MYSQL_MIN(a) from t1 group by a" ?
   - We assume that the general correctness of the GROUP-BY query was checked
     before this point. Is this correct, or do we have to check it completely?
   - Lift the limitation in condition (B3), that is, make this access method 
@@ -9387,7 +9387,7 @@
         cur_group_prefix_len+= cur_part->store_length;
         used_key_parts_map.set_bit(key_part_nr);
         ++cur_group_key_parts;
-        max_key_part= max(max_key_part,key_part_nr);
+        max_key_part= MYSQL_MAX(max_key_part,key_part_nr);
       }
       /*
         Check that used key parts forms a prefix of the index.
@@ -10019,9 +10019,9 @@
     {
       double blocks_per_group= (double) num_blocks / (double) num_groups;
       p_overlap= (blocks_per_group * (keys_per_subgroup - 1)) / keys_per_group;
-      p_overlap= min(p_overlap, 1.0);
+      p_overlap= MYSQL_MIN(p_overlap, 1.0);
     }
-    io_cost= (double) min(num_groups * (1 + p_overlap), num_blocks);
+    io_cost= (double) MYSQL_MIN(num_groups * (1 + p_overlap), num_blocks);
   }
   else
     io_cost= (keys_per_group > keys_per_block) ?
diff -urN mysql-old/sql/protocol.cc mysql/sql/protocol.cc
--- mysql-old/sql/protocol.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/protocol.cc	2009-12-10 00:57:23.180803105 -0100
@@ -167,7 +167,7 @@
     pos+=2;
 
     /* We can only return up to 65535 warnings in two bytes */
-    uint tmp= min(total_warn_count, 65535);
+    uint tmp= MYSQL_MIN(total_warn_count, 65535);
     int2store(pos, tmp);
     pos+= 2;
   }
@@ -262,7 +262,7 @@
       Don't send warn count during SP execution, as the warn_list
       is cleared between substatements, and mysqltest gets confused
     */
-    uint tmp= min(total_warn_count, 65535);
+    uint tmp= MYSQL_MIN(total_warn_count, 65535);
     buff[0]= 254;
     int2store(buff+1, tmp);
     /*
diff -urN mysql-old/sql/rpl_record.cc mysql/sql/rpl_record.cc
--- mysql-old/sql/rpl_record.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/rpl_record.cc	2009-12-10 00:57:23.181925046 -0100
@@ -255,7 +255,7 @@
   /*
     throw away master's extra fields
   */
-  uint max_cols= min(tabledef->size(), cols->n_bits);
+  uint max_cols= MYSQL_MIN(tabledef->size(), cols->n_bits);
   for (; i < max_cols; i++)
   {
     if (bitmap_is_set(cols, i))
diff -urN mysql-old/sql/rpl_rli.cc mysql/sql/rpl_rli.cc
--- mysql-old/sql/rpl_rli.cc	2009-12-10 00:54:18.669801304 -0100
+++ mysql/sql/rpl_rli.cc	2009-12-10 00:57:23.182763515 -0100
@@ -662,7 +662,7 @@
   ulong log_name_extension;
   char log_name_tmp[FN_REFLEN]; //make a char[] from String
 
-  strmake(log_name_tmp, log_name->ptr(), min(log_name->length(), FN_REFLEN-1));
+  strmake(log_name_tmp, log_name->ptr(), MYSQL_MIN(log_name->length(), FN_REFLEN-1));
 
   char *p= fn_ext(log_name_tmp);
   char *p_end;
@@ -672,7 +672,7 @@
     goto err;
   }
   // Convert 0-3 to 4
-  log_pos= max(log_pos, BIN_LOG_HEADER_SIZE);
+  log_pos= MYSQL_MAX(log_pos, BIN_LOG_HEADER_SIZE);
   /* p points to '.' */
   log_name_extension= strtoul(++p, &p_end, 10);
   /*
diff -urN mysql-old/sql/rpl_utility.cc mysql/sql/rpl_utility.cc
--- mysql-old/sql/rpl_utility.cc	2009-12-10 00:54:18.669801304 -0100
+++ mysql/sql/rpl_utility.cc	2009-12-10 00:57:23.182763515 -0100
@@ -180,7 +180,7 @@
   /*
     We only check the initial columns for the tables.
   */
-  uint const cols_to_check= min(table->s->fields, size());
+  uint const cols_to_check= MYSQL_MIN(table->s->fields, size());
   int error= 0;
   Relay_log_info const *rli= const_cast<Relay_log_info*>(rli_arg);
 
diff -urN mysql-old/sql/rpl_utility.h mysql/sql/rpl_utility.h
--- mysql-old/sql/rpl_utility.h	2009-12-10 00:54:18.682800813 -0100
+++ mysql/sql/rpl_utility.h	2009-12-10 00:57:23.183698833 -0100
@@ -299,7 +299,7 @@
   do {                                             \
     char buf[256];                                 \
     uint i;                                        \
-    for (i = 0 ; i < min(sizeof(buf) - 1, (BS)->n_bits) ; i++) \
+    for (i = 0 ; i < MYSQL_MIN(sizeof(buf) - 1, (BS)->n_bits) ; i++) \
       buf[i] = bitmap_is_set((BS), i) ? '1' : '0'; \
     buf[i] = '\0';                                 \
     DBUG_PRINT((N), ((FRM), buf));                 \
diff -urN mysql-old/sql/set_var.cc mysql/sql/set_var.cc
--- mysql-old/sql/set_var.cc	2009-12-10 00:54:18.675801832 -0100
+++ mysql/sql/set_var.cc	2009-12-10 00:57:23.184598496 -0100
@@ -1850,7 +1850,7 @@
 					    &not_used));
     if (error_len)
     {
-      strmake(buff, error, min(sizeof(buff) - 1, error_len));
+      strmake(buff, error, MYSQL_MIN(sizeof(buff) - 1, error_len));
       goto err;
     }
   }
@@ -3994,7 +3994,7 @@
                                &error, &error_len, &not_used);
   if (error_len)
   {
-    strmake(buff, error, min(sizeof(buff) - 1, error_len));
+    strmake(buff, error, MYSQL_MIN(sizeof(buff) - 1, error_len));
     goto err;
   }
   return FALSE;
diff -urN mysql-old/sql/slave.cc mysql/sql/slave.cc
--- mysql-old/sql/slave.cc	2009-12-10 00:54:18.670801185 -0100
+++ mysql/sql/slave.cc	2009-12-10 00:57:23.187563669 -0100
@@ -1703,13 +1703,13 @@
         slave is 2. At SHOW SLAVE STATUS time, assume that the difference
         between timestamp of slave and rli->last_master_timestamp is 0
         (i.e. they are in the same second), then we get 0-(2-1)=-1 as a result.
-        This confuses users, so we don't go below 0: hence the max().
+        This confuses users, so we don't go below 0: hence the MYSQL_MAX().
 
         last_master_timestamp == 0 (an "impossible" timestamp 1970) is a
         special marker to say "consider we have caught up".
       */
       protocol->store((longlong)(mi->rli.last_master_timestamp ?
-                                 max(0, time_diff) : 0));
+                                 MYSQL_MAX(0, time_diff) : 0));
     }
     else
     {
@@ -2333,7 +2333,7 @@
             exec_res= 0;
             end_trans(thd, ROLLBACK);
             /* chance for concurrent connection to get more locks */
-            safe_sleep(thd, min(rli->trans_retries, MAX_SLAVE_RETRY_PAUSE),
+            safe_sleep(thd, MYSQL_MIN(rli->trans_retries, MAX_SLAVE_RETRY_PAUSE),
                        (CHECK_KILLED_FUNC)sql_slave_killed, (void*)rli);
             pthread_mutex_lock(&rli->data_lock); // because of SHOW STATUS
             rli->trans_retries++;
@@ -3984,7 +3984,7 @@
     relay_log_pos       Current log pos
     pending             Number of bytes already processed from the event
   */
-  rli->event_relay_log_pos= max(rli->event_relay_log_pos, BIN_LOG_HEADER_SIZE);
+  rli->event_relay_log_pos= MYSQL_MAX(rli->event_relay_log_pos, BIN_LOG_HEADER_SIZE);
   my_b_seek(cur_log,rli->event_relay_log_pos);
   DBUG_RETURN(cur_log);
 }
diff -urN mysql-old/sql/spatial.h mysql/sql/spatial.h
--- mysql-old/sql/spatial.h	2009-12-10 00:54:18.681800947 -0100
+++ mysql/sql/spatial.h	2009-12-10 00:57:23.189924896 -0100
@@ -180,8 +180,8 @@
     if (d != mbr->dimension() || d <= 0 || contains(mbr) || within(mbr))
       return 0;
 
-    MBR intersection(max(xmin, mbr->xmin), max(ymin, mbr->ymin),
-                     min(xmax, mbr->xmax), min(ymax, mbr->ymax));
+    MBR intersection(MYSQL_MAX(xmin, mbr->xmin), MYSQL_MAX(ymin, mbr->ymin),
+                     MYSQL_MIN(xmax, mbr->xmax), MYSQL_MIN(ymax, mbr->ymax));
 
     return (d == intersection.dimension());
   }
diff -urN mysql-old/sql/sp_head.cc mysql/sql/sp_head.cc
--- mysql-old/sql/sp_head.cc	2009-12-10 00:54:18.669801304 -0100
+++ mysql/sql/sp_head.cc	2009-12-10 00:57:23.190925470 -0100
@@ -2414,7 +2414,7 @@
 
     Item_empty_string *stmt_fld=
       new Item_empty_string(col3_caption,
-                            max(m_defstr.length, 1024));
+                            MYSQL_MAX(m_defstr.length, 1024));
 
     stmt_fld->maybe_null= TRUE;
 
@@ -2615,7 +2615,7 @@
   field_list.push_back(new Item_uint("Pos", 9));
   // 1024 is for not to confuse old clients
   field_list.push_back(new Item_empty_string("Instruction",
-					     max(buffer.length(), 1024)));
+					     MYSQL_MAX(buffer.length(), 1024)));
   if (protocol->send_fields(&field_list, Protocol::SEND_NUM_ROWS |
                                          Protocol::SEND_EOF))
     DBUG_RETURN(1);
diff -urN mysql-old/sql/sql_acl.cc mysql/sql/sql_acl.cc
--- mysql-old/sql/sql_acl.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/sql_acl.cc	2009-12-10 00:57:23.193600784 -0100
@@ -818,7 +818,7 @@
         chars= 128;                             // Marker that chars existed
       }
     }
-    sort= (sort << 8) + (wild_pos ? min(wild_pos, 127) : chars);
+    sort= (sort << 8) + (wild_pos ? MYSQL_MIN(wild_pos, 127) : chars);
   }
   va_end(args);
   return sort;
diff -urN mysql-old/sql/sql_analyse.cc mysql/sql/sql_analyse.cc
--- mysql-old/sql/sql_analyse.cc	2009-12-10 00:54:18.670801185 -0100
+++ mysql/sql/sql_analyse.cc	2009-12-10 00:57:23.196766218 -0100
@@ -280,16 +280,16 @@
   {
     if (((longlong) info->ullval) < 0)
       return 0; // Impossible to store as a negative number
-    ev_info->llval =  -(longlong) max((ulonglong) -ev_info->llval, 
+    ev_info->llval =  -(longlong) MYSQL_MAX((ulonglong) -ev_info->llval, 
 				      info->ullval);
-    ev_info->min_dval = (double) -max(-ev_info->min_dval, info->dval);
+    ev_info->min_dval = (double) -MYSQL_MAX(-ev_info->min_dval, info->dval);
   }
   else		// ulonglong is as big as bigint in MySQL
   {
     if ((check_ulonglong(num, info->integers) == DECIMAL_NUM))
       return 0;
-    ev_info->ullval = (ulonglong) max(ev_info->ullval, info->ullval);
-    ev_info->max_dval =  (double) max(ev_info->max_dval, info->dval);
+    ev_info->ullval = (ulonglong) MYSQL_MAX(ev_info->ullval, info->ullval);
+    ev_info->max_dval =  (double) MYSQL_MAX(ev_info->max_dval, info->dval);
   }
   return 1;
 } // get_ev_num_info
@@ -1043,7 +1043,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &avg_val, sum+cur_sum, &num, prec_increment);
   /* TODO remove this after decimal_div returns proper frac */
   my_decimal_round(E_DEC_FATAL_ERROR, &avg_val,
-                   min(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
+                   MYSQL_MIN(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
                    FALSE,&rounded_avg);
   my_decimal2string(E_DEC_FATAL_ERROR, &rounded_avg, 0, 0, '0', s);
   return s;
@@ -1068,7 +1068,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &tmp, &sum2, &num, prec_increment);
   my_decimal2double(E_DEC_FATAL_ERROR, &tmp, &std_sqr);
   s->set_real(((double) std_sqr <= 0.0 ? 0.0 : sqrt(std_sqr)),
-         min(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
+         MYSQL_MIN(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
 
   return s;
 }
@@ -1185,7 +1185,7 @@
   func_items[8] = new Item_proc_string("Std", 255);
   func_items[8]->maybe_null = 1;
   func_items[9] = new Item_proc_string("Optimal_fieldtype",
-				       max(64, output_str_length));
+				       MYSQL_MAX(64, output_str_length));
 
   for (uint i = 0; i < array_elements(func_items); i++)
     field_list.push_back(func_items[i]);
diff -urN mysql-old/sql/sql_cache.cc mysql/sql/sql_cache.cc
--- mysql-old/sql/sql_cache.cc	2009-12-10 00:54:18.670801185 -0100
+++ mysql/sql/sql_cache.cc	2009-12-10 00:57:23.198925221 -0100
@@ -981,7 +981,7 @@
     }
     last_result_block= header->result()->prev;
     allign_size= ALIGN_SIZE(last_result_block->used);
-    len= max(query_cache.min_allocation_unit, allign_size);
+    len= MYSQL_MAX(query_cache.min_allocation_unit, allign_size);
     if (last_result_block->length >= query_cache.min_allocation_unit + len)
       query_cache.split_block(last_result_block,len);
 
@@ -2341,7 +2341,7 @@
   DBUG_ENTER("Query_cache::write_block_data");
   DBUG_PRINT("qcache", ("data: %ld, header: %ld, all header: %ld",
 		      data_len, header_len, all_headers_len));
-  Query_cache_block *block= allocate_block(max(align_len,
+  Query_cache_block *block= allocate_block(MYSQL_MAX(align_len,
                                            min_allocation_unit),1, 0);
   if (block != 0)
   {
@@ -2396,7 +2396,7 @@
   ulong append_min = get_min_append_result_data_size();
   if (last_block_free_space < data_len &&
       append_next_free_block(last_block,
-			     max(tail, append_min)))
+			     MYSQL_MAX(tail, append_min)))
     last_block_free_space = last_block->length - last_block->used;
   // If no space in last block (even after join) allocate new block
   if (last_block_free_space < data_len)
@@ -2424,7 +2424,7 @@
   // Now finally write data to the last block
   if (success && last_block_free_space > 0)
   {
-    ulong to_copy = min(data_len,last_block_free_space);
+    ulong to_copy = MYSQL_MIN(data_len,last_block_free_space);
     DBUG_PRINT("qcache", ("use free space %lub at block 0x%lx to copy %lub",
 			last_block_free_space, (ulong)last_block, to_copy));
     memcpy((uchar*) last_block + last_block->used, data, to_copy);
@@ -2512,8 +2512,8 @@
   if (queries_in_cache < QUERY_CACHE_MIN_ESTIMATED_QUERIES_NUMBER)
     return min_result_data_size;
   ulong avg_result = (query_cache_size - free_memory) / queries_in_cache;
-  avg_result = min(avg_result, query_cache_limit);
-  return max(min_result_data_size, avg_result);
+  avg_result = MYSQL_MIN(avg_result, query_cache_limit);
+  return MYSQL_MAX(min_result_data_size, avg_result);
 }
 
 inline ulong Query_cache::get_min_append_result_data_size()
@@ -2545,7 +2545,7 @@
     ulong len= data_len + all_headers_len;
     ulong align_len= ALIGN_SIZE(len);
 
-    if (!(new_block= allocate_block(max(min_size, align_len),
+    if (!(new_block= allocate_block(MYSQL_MAX(min_size, align_len),
 				    min_result_data_size == 0,
 				    all_headers_len + min_result_data_size)))
     {
@@ -2554,7 +2554,7 @@
     }
 
     new_block->n_tables = 0;
-    new_block->used = min(len, new_block->length);
+    new_block->used = MYSQL_MIN(len, new_block->length);
     new_block->type = Query_cache_block::RES_INCOMPLETE;
     new_block->next = new_block->prev = new_block;
     Query_cache_result *header = new_block->result();
@@ -2977,7 +2977,7 @@
   DBUG_PRINT("qcache", ("len %lu, not less %d, min %lu",
              len, not_less,min));
 
-  if (len >= min(query_cache_size, query_cache_limit))
+  if (len >= MYSQL_MIN(query_cache_size, query_cache_limit))
   {
     DBUG_PRINT("qcache", ("Query cache hase only %lu memory and limit %lu",
 			query_cache_size, query_cache_limit));
diff -urN mysql-old/sql/sql_class.cc mysql/sql/sql_class.cc
--- mysql-old/sql/sql_class.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/sql_class.cc	2009-12-10 00:57:23.200925302 -0100
@@ -380,7 +380,7 @@
     if (max_query_len < 1)
       len= thd->query_length;
     else
-      len= min(thd->query_length, max_query_len);
+      len= MYSQL_MIN(thd->query_length, max_query_len);
     str.append('\n');
     str.append(thd->query, len);
   }
@@ -392,7 +392,7 @@
     was reallocated to a larger buffer to be able to fit.
   */
   DBUG_ASSERT(buffer != NULL);
-  length= min(str.length(), length-1);
+  length= MYSQL_MIN(str.length(), length-1);
   memcpy(buffer, str.c_ptr_quick(), length);
   /* Make sure that the new string is null terminated */
   buffer[length]= '\0';
@@ -1975,7 +1975,7 @@
     else
     {
       if (fixed_row_size)
-	used_length=min(res->length(),item->max_length);
+	used_length=MYSQL_MIN(res->length(),item->max_length);
       else
 	used_length=res->length();
       if ((result_type == STRING_RESULT || is_unsafe_field_sep) &&
diff -urN mysql-old/sql/sql_client.cc mysql/sql/sql_client.cc
--- mysql-old/sql/sql_client.cc	2009-12-10 00:54:18.669801304 -0100
+++ mysql/sql/sql_client.cc	2009-12-10 00:57:23.202924894 -0100
@@ -34,7 +34,7 @@
                            (uint)global_system_variables.net_write_timeout);
 
   net->retry_count=  (uint) global_system_variables.net_retry_count;
-  net->max_packet_size= max(global_system_variables.net_buffer_length,
+  net->max_packet_size= MYSQL_MAX(global_system_variables.net_buffer_length,
 			    global_system_variables.max_allowed_packet);
 #endif
 }
diff -urN mysql-old/sql/sql_connect.cc mysql/sql/sql_connect.cc
--- mysql-old/sql/sql_connect.cc	2009-12-10 00:54:18.675801832 -0100
+++ mysql/sql/sql_connect.cc	2009-12-10 00:57:23.203830981 -0100
@@ -670,7 +670,7 @@
       if (thd->main_security_ctx.host)
       {
         if (thd->main_security_ctx.host != my_localhost)
-          thd->main_security_ctx.host[min(strlen(thd->main_security_ctx.host),
+          thd->main_security_ctx.host[MYSQL_MIN(strlen(thd->main_security_ctx.host),
                                           HOSTNAME_LENGTH)]= 0;
         thd->main_security_ctx.host_or_ip= thd->main_security_ctx.host;
       }
diff -urN mysql-old/sql/sql_load.cc mysql/sql/sql_load.cc
--- mysql-old/sql/sql_load.cc	2009-12-10 00:54:18.670801185 -0100
+++ mysql/sql/sql_load.cc	2009-12-10 00:57:23.203830981 -0100
@@ -977,7 +977,7 @@
 
 
   /* Set of a stack for unget if long terminators */
-  uint length=max(field_term_length,line_term_length)+1;
+  uint length=MYSQL_MAX(field_term_length,line_term_length)+1;
   set_if_bigger(length,line_start.length());
   stack=stack_pos=(int*) sql_alloc(sizeof(int)*length);
 
diff -urN mysql-old/sql/sql_parse.cc mysql/sql/sql_parse.cc
--- mysql-old/sql/sql_parse.cc	2009-12-10 00:54:18.675801832 -0100
+++ mysql/sql/sql_parse.cc	2009-12-10 00:57:23.206924939 -0100
@@ -5563,7 +5563,7 @@
     return 1;
   }
 #ifndef DBUG_OFF
-  max_stack_used= max(max_stack_used, stack_used);
+  max_stack_used= MYSQL_MAX(max_stack_used, stack_used);
 #endif
   return 0;
 }
@@ -7054,7 +7054,7 @@
     char command[80];
     Lex_input_stream *lip= & thd->m_parser_state->m_lip;
     strmake(command, lip->yylval->symbol.str,
-	    min(lip->yylval->symbol.length, sizeof(command)-1));
+	    MYSQL_MIN(lip->yylval->symbol.length, sizeof(command)-1));
     my_error(ER_CANT_USE_OPTION_HERE, MYF(0), command);
     return 1;
   }
diff -urN mysql-old/sql/sql_partition.cc mysql/sql/sql_partition.cc
--- mysql-old/sql/sql_partition.cc	2009-12-10 00:54:18.678802160 -0100
+++ mysql/sql/sql_partition.cc	2009-12-10 00:57:23.210553448 -0100
@@ -4516,7 +4516,7 @@
             */
             start_part= 0;
             end_part= new_total_partitions - (upper_2n + 1);
-            end_part= max(lower_2n - 1, end_part);
+            end_part= MYSQL_MAX(lower_2n - 1, end_part);
           }
           else if (new_total_partitions <= upper_2n)
           {
diff -urN mysql-old/sql/sql_plugin.cc mysql/sql/sql_plugin.cc
--- mysql-old/sql/sql_plugin.cc	2009-12-10 00:54:18.668801053 -0100
+++ mysql/sql/sql_plugin.cc	2009-12-10 00:57:23.215549997 -0100
@@ -486,7 +486,7 @@
     for (i=0;
          (old=(struct st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;
          i++)
-      memcpy(cur+i, old, min(sizeof(cur[i]), sizeof_st_plugin));
+      memcpy(cur+i, old, MYSQL_MIN(sizeof(cur[i]), sizeof_st_plugin));
 
     sym= cur;
   }
@@ -2092,7 +2092,7 @@
                      &error, &error_len, &not_used);
     if (error_len)
     {
-      strmake(buff, error, min(sizeof(buff), error_len));
+      strmake(buff, error, MYSQL_MIN(sizeof(buff), error_len));
       strvalue= buff;
       goto err;
     }
diff -urN mysql-old/sql/sql_prepare.cc mysql/sql/sql_prepare.cc
--- mysql-old/sql/sql_prepare.cc	2009-12-10 00:54:18.673801019 -0100
+++ mysql/sql/sql_prepare.cc	2009-12-10 00:57:23.217549832 -0100
@@ -249,7 +249,7 @@
   int2store(buff+5, columns);
   int2store(buff+7, stmt->param_count);
   buff[9]= 0;                                   // Guard against a 4.1 client
-  tmp= min(stmt->thd->total_warn_count, 65535);
+  tmp= MYSQL_MIN(stmt->thd->total_warn_count, 65535);
   int2store(buff+10, tmp);
 
   /*
diff -urN mysql-old/sql/sql_profile.cc mysql/sql/sql_profile.cc
--- mysql-old/sql/sql_profile.cc	2009-12-10 00:54:18.673801019 -0100
+++ mysql/sql/sql_profile.cc	2009-12-10 00:57:23.218549839 -0100
@@ -252,7 +252,7 @@
                                      uint query_length_arg)
 {
   /* Truncate to avoid DoS attacks. */
-  uint length= min(MAX_QUERY_LENGTH, query_length_arg);
+  uint length= MYSQL_MIN(MAX_QUERY_LENGTH, query_length_arg);
 
   DBUG_ASSERT(query_source == NULL); /* we don't leak memory */
   if (query_source_arg != NULL)
diff -urN mysql-old/sql/sql_repl.cc mysql/sql/sql_repl.cc
--- mysql-old/sql/sql_repl.cc	2009-12-10 00:54:18.669801304 -0100
+++ mysql/sql/sql_repl.cc	2009-12-10 00:57:23.219827771 -0100
@@ -1256,12 +1256,12 @@
    {
      /*
        Sometimes mi->rli.master_log_pos == 0 (it happens when the SQL thread is
-       not initialized), so we use a max().
+       not initialized), so we use a MYSQL_MAX().
        What happens to mi->rli.master_log_pos during the initialization stages
        of replication is not 100% clear, so we guard against problems using
-       max().
+       MYSQL_MAX().
       */
-     mi->master_log_pos = max(BIN_LOG_HEADER_SIZE,
+     mi->master_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE,
 			      mi->rli.group_master_log_pos);
      strmake(mi->master_log_name, mi->rli.group_master_log_name,
              sizeof(mi->master_log_name)-1);
@@ -1423,7 +1423,7 @@
     LEX_MASTER_INFO *lex_mi= &thd->lex->mi;
     SELECT_LEX_UNIT *unit= &thd->lex->unit;
     ha_rows event_count, limit_start, limit_end;
-    my_off_t pos = max(BIN_LOG_HEADER_SIZE, lex_mi->pos); // user-friendly
+    my_off_t pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, lex_mi->pos); // user-friendly
     char search_file_name[FN_REFLEN], *name;
     const char *log_file_name = lex_mi->log_file_name;
     pthread_mutex_t *log_lock = mysql_bin_log.get_log_lock();
@@ -1692,14 +1692,14 @@
     DBUG_RETURN(0);
   
   for (block_len= (uint) (my_b_get_bytes_in_buffer(file)); block_len > 0;
-       buffer += min(block_len, max_event_size),
-       block_len -= min(block_len, max_event_size))
+       buffer += MYSQL_MIN(block_len, max_event_size),
+       block_len -= MYSQL_MIN(block_len, max_event_size))
   {
     lf_info->last_pos_in_file= my_b_get_pos_in_file(file);
     if (lf_info->wrote_create_file)
     {
       Append_block_log_event a(lf_info->thd, lf_info->thd->db, buffer,
-                               min(block_len, max_event_size),
+                               MYSQL_MIN(block_len, max_event_size),
                                lf_info->log_delayed);
       mysql_bin_log.write(&a);
     }
@@ -1707,7 +1707,7 @@
     {
       Begin_load_query_log_event b(lf_info->thd, lf_info->thd->db,
                                    buffer,
-                                   min(block_len, max_event_size),
+                                   MYSQL_MIN(block_len, max_event_size),
                                    lf_info->log_delayed);
       mysql_bin_log.write(&b);
       lf_info->wrote_create_file= 1;
diff -urN mysql-old/sql/sql_select.cc mysql/sql/sql_select.cc
--- mysql-old/sql/sql_select.cc	2009-12-10 00:54:18.674801821 -0100
+++ mysql/sql/sql_select.cc	2009-12-10 00:57:23.224925224 -0100
@@ -881,7 +881,7 @@
   }
 #endif
 
-  /* Optimize count(*), min() and max() */
+  /* Optimize count(*), MYSQL_MIN() and MYSQL_MAX() */
   if (tables_list && tmp_table_param.sum_func_count && ! group_list)
   {
     int res;
@@ -2829,7 +2829,7 @@
       This is can't be to high as otherwise we are likely to use
       table scan.
     */
-    s->worst_seeks= min((double) s->found_records / 10,
+    s->worst_seeks= MYSQL_MIN((double) s->found_records / 10,
 			(double) s->read_time*3);
     if (s->worst_seeks < 2.0)			// Fix for small tables
       s->worst_seeks=2.0;
@@ -3743,7 +3743,7 @@
   uint	and_level,i,found_eq_constant;
   KEY_FIELD *key_fields, *end, *field;
   uint sz;
-  uint m= max(select_lex->max_equal_elems,1);
+  uint m= MYSQL_MAX(select_lex->max_equal_elems,1);
   
   /* 
     We use the same piece of memory to store both  KEY_FIELD 
@@ -3766,7 +3766,7 @@
     can be not more than select_lex->max_equal_elems such 
     substitutions.
   */ 
-  sz= max(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
+  sz= MYSQL_MAX(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
       (((thd->lex->current_select->cond_count+1)*2 +
 	thd->lex->current_select->between_count)*m+1);
   if (!(key_fields=(KEY_FIELD*)	thd->alloc(sz)))
@@ -3925,7 +3925,7 @@
       if (map == 1)			// Only one table
       {
 	TABLE *tmp_table=join->all_tables[tablenr];
-	keyuse->ref_table_rows= max(tmp_table->file->stats.records, 100);
+	keyuse->ref_table_rows= MYSQL_MAX(tmp_table->file->stats.records, 100);
       }
     }
     /*
@@ -4245,7 +4245,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
         }
         else
@@ -4412,7 +4412,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
           else
             tmp= best_time;                    // Do nothing
@@ -5357,7 +5357,7 @@
   {
     uint blob_length=(uint) (join_tab->table->file->stats.mean_rec_length-
 			     (join_tab->table->s->reclength- rec_length));
-    rec_length+=(uint) max(4,blob_length);
+    rec_length+=(uint) MYSQL_MAX(4,blob_length);
   }
   join_tab->used_fields=fields;
   join_tab->used_fieldlength=rec_length;
@@ -6718,7 +6718,7 @@
     a correlated subquery itself, but has subqueries, we can free it
     fully and also free JOINs of all its subqueries. The exception
     is a subquery in SELECT list, e.g: @n
-    SELECT a, (select max(b) from t1) group by c @n
+    SELECT a, (select MYSQL_MAX(b) from t1) group by c @n
     This subquery will not be evaluated at first sweep and its value will
     not be inserted into the temporary table. Instead, it's evaluated
     when selecting from the temporary table. Therefore, it can't be freed
@@ -10162,7 +10162,7 @@
     share->max_rows= ~(ha_rows) 0;
   else
     share->max_rows= (ha_rows) (((share->db_type() == heap_hton) ?
-                                 min(thd->variables.tmp_table_size,
+                                 MYSQL_MIN(thd->variables.tmp_table_size,
                                      thd->variables.max_heap_table_size) :
                                  thd->variables.tmp_table_size) /
 			         share->reclength);
@@ -13217,7 +13217,7 @@
             index entry.
 	  */
           index_scan_time= select_limit/rec_per_key *
-	                   min(rec_per_key, table->file->scan_time());
+	                   MYSQL_MIN(rec_per_key, table->file->scan_time());
           if ((ref_key < 0 && is_covering) || 
               (ref_key < 0 && (group || table->force_index)) ||
               index_scan_time < read_time)
@@ -13229,7 +13229,7 @@
             if (table->quick_keys.is_set(nr))
               quick_records= table->quick_rows[nr];
             if (best_key < 0 ||
-                (select_limit <= min(quick_records,best_records) ?
+                (select_limit <= MYSQL_MIN(quick_records,best_records) ?
                  keyinfo->key_parts < best_key_parts :
                  quick_records < best_records))
             {
@@ -13868,7 +13868,7 @@
     count++;
   if (!sortorder)
     sortorder= (SORT_FIELD*) sql_alloc(sizeof(SORT_FIELD) *
-                                       (max(count, *length) + 1));
+                                       (MYSQL_MAX(count, *length) + 1));
   pos= sort= sortorder;
 
   if (!pos)
@@ -13990,7 +13990,7 @@
   cache->length=length+blobs*sizeof(char*);
   cache->blobs=blobs;
   *blob_ptr=0;					/* End sequentel */
-  size=max(thd->variables.join_buff_size, cache->length);
+  size=MYSQL_MAX(thd->variables.join_buff_size, cache->length);
   if (!(cache->buff=(uchar*) my_malloc(size,MYF(0))))
     DBUG_RETURN(1);				/* Don't use cache */ /* purecov: inspected */
   cache->end=cache->buff+size;
diff -urN mysql-old/sql/sql_show.cc mysql/sql/sql_show.cc
--- mysql-old/sql/sql_show.cc	2009-12-10 00:54:18.670801185 -0100
+++ mysql/sql/sql_show.cc	2009-12-10 00:57:23.305553824 -0100
@@ -640,7 +640,7 @@
   {
     field_list.push_back(new Item_empty_string("View",NAME_CHAR_LEN));
     field_list.push_back(new Item_empty_string("Create View",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
     field_list.push_back(new Item_empty_string("character_set_client",
                                                MY_CS_NAME_SIZE));
     field_list.push_back(new Item_empty_string("collation_connection",
@@ -651,7 +651,7 @@
     field_list.push_back(new Item_empty_string("Table",NAME_CHAR_LEN));
     // 1024 is for not to confuse old clients
     field_list.push_back(new Item_empty_string("Create Table",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
   }
 
   if (protocol->send_fields(&field_list,
@@ -1759,7 +1759,7 @@
         pthread_mutex_lock(&tmp->LOCK_thd_data);
         if (tmp->query)
         {
-          uint length= min(max_query_length, tmp->query_length);
+          uint length= MYSQL_MIN(max_query_length, tmp->query_length);
           thd_info->query=(char*) thd->strmake(tmp->query,length);
         }
         pthread_mutex_unlock(&tmp->LOCK_thd_data);
@@ -1888,7 +1888,7 @@
       if (tmp->query)
       {
         table->field[7]->store(tmp->query,
-                               min(PROCESS_LIST_INFO_WIDTH,
+                               MYSQL_MIN(PROCESS_LIST_INFO_WIDTH,
                                    tmp->query_length), cs);
         table->field[7]->set_notnull();
       }
@@ -3030,7 +3030,7 @@
     for (ptr=tables->table->field; (field= *ptr) ; ptr++)
     {
       star_table_open_method=
-        min(star_table_open_method,
+        MYSQL_MIN(star_table_open_method,
             schema_table->fields_info[field_indx].open_method);
       if (bitmap_is_set(tables->table->read_set, field->field_index))
       {
@@ -6869,7 +6869,7 @@
 
     Item_empty_string *stmt_fld=
       new Item_empty_string("SQL Original Statement",
-                            max(trg_sql_original_stmt.length, 1024));
+                            MYSQL_MAX(trg_sql_original_stmt.length, 1024));
 
     stmt_fld->maybe_null= TRUE;
 
diff -urN mysql-old/sql/sql_string.cc mysql/sql/sql_string.cc
--- mysql-old/sql/sql_string.cc	2009-12-10 00:54:18.676678556 -0100
+++ mysql/sql/sql_string.cc	2009-12-10 00:57:23.310733848 -0100
@@ -661,7 +661,7 @@
 {
   if (Alloced_length < str_length + space_needed)
   {
-    if (realloc(Alloced_length + max(space_needed, grow_by) - 1))
+    if (realloc(Alloced_length + MYSQL_MAX(space_needed, grow_by) - 1))
       return TRUE;
   }
   return FALSE;
@@ -747,7 +747,7 @@
 
 int stringcmp(const String *s,const String *t)
 {
-  uint32 s_len=s->length(),t_len=t->length(),len=min(s_len,t_len);
+  uint32 s_len=s->length(),t_len=t->length(),len=MYSQL_MIN(s_len,t_len);
   int cmp= memcmp(s->ptr(), t->ptr(), len);
   return (cmp) ? cmp : (int) (s_len - t_len);
 }
@@ -764,7 +764,7 @@
   }
   if (to->realloc(from_length))
     return from;				// Actually an error
-  if ((to->str_length=min(from->str_length,from_length)))
+  if ((to->str_length=MYSQL_MIN(from->str_length,from_length)))
     memcpy(to->Ptr,from->Ptr,to->str_length);
   to->str_charset=from->str_charset;
   return to;
@@ -965,7 +965,7 @@
 
     if (to_cs == &my_charset_bin)
     {
-      res= min(min(nchars, to_length), from_length);
+      res= MYSQL_MIN(MYSQL_MIN(nchars, to_length), from_length);
       memmove(to, from, res);
       *from_end_pos= from + res;
       *well_formed_error_pos= NULL;
@@ -1151,7 +1151,7 @@
   char *t= to;
   char *t_end= to + to_len - 1; // '- 1' is for the '\0' at the end
   const char *f= from;
-  const char *f_end= from + (nbytes ? min(from_len, nbytes) : from_len);
+  const char *f_end= from + (nbytes ? MYSQL_MIN(from_len, nbytes) : from_len);
   char *dots= to; // last safe place to append '...'
 
   if (!f || t == t_end)
diff -urN mysql-old/sql/sql_table.cc mysql/sql/sql_table.cc
--- mysql-old/sql/sql_table.cc	2009-12-10 00:54:18.671801382 -0100
+++ mysql/sql/sql_table.cc	2009-12-10 00:57:23.312925406 -0100
@@ -3213,7 +3213,7 @@
 	  if ((length=column->length) > max_key_length ||
 	      length > file->max_key_part_length())
 	  {
-	    length=min(max_key_length, file->max_key_part_length());
+	    length=MYSQL_MIN(max_key_length, file->max_key_part_length());
 	    if (key->type == Key::MULTIPLE)
 	    {
 	      /* not a critical problem */
diff -urN mysql-old/sql/sql_yacc.cc mysql/sql/sql_yacc.cc
--- mysql-old/sql/sql_yacc.cc	2009-12-10 00:54:18.680801992 -0100
+++ mysql/sql/sql_yacc.cc	2009-12-10 00:57:23.325926568 -0100
@@ -16004,7 +16004,7 @@
                from 0" (4 in fact), unspecified means "don't change the position
                (keep the preceding value)").
             */
-            Lex->mi.pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
+            Lex->mi.pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
           }
     break;
 
@@ -16024,7 +16024,7 @@
     {
             Lex->mi.relay_log_pos = (yyvsp[(3) - (3)].ulong_num);
             /* Adjust if < BIN_LOG_HEADER_SIZE (same comment as Lex->mi.pos) */
-            Lex->mi.relay_log_pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
+            Lex->mi.relay_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
           }
     break;
 
diff -urN mysql-old/sql/thr_malloc.cc mysql/sql/thr_malloc.cc
--- mysql-old/sql/thr_malloc.cc	2009-12-10 00:54:18.677801964 -0100
+++ mysql/sql/thr_malloc.cc	2009-12-10 00:57:23.407549717 -0100
@@ -126,7 +126,7 @@
   if ((from_cs == &my_charset_bin) || (to_cs == &my_charset_bin))
   {
     // Safety if to_cs->mbmaxlen > 0
-    new_length= min(arg_length, max_res_length);
+    new_length= MYSQL_MIN(arg_length, max_res_length);
     memcpy(pos, str, new_length);
   }
   else
diff -urN mysql-old/sql/tztime.cc mysql/sql/tztime.cc
--- mysql-old/sql/tztime.cc	2009-12-10 00:54:18.678802160 -0100
+++ mysql/sql/tztime.cc	2009-12-10 00:57:23.408549811 -0100
@@ -167,7 +167,7 @@
       uchar buf[sizeof(struct tzhead) + sizeof(my_time_t) * TZ_MAX_TIMES +
                 TZ_MAX_TIMES + sizeof(TRAN_TYPE_INFO) * TZ_MAX_TYPES +
 #ifdef ABBR_ARE_USED
-               max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
+               MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
 #endif
                sizeof(LS_INFO) * TZ_MAX_LEAPS];
     } u;
@@ -396,7 +396,7 @@
       Let us choose end_t as point before next time type change or leap
       second correction.
     */
-    end_t= min((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
+    end_t= MYSQL_MIN((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
                                                 MY_TIME_T_MAX,
                (next_leap_idx < sp->leapcnt) ?
                  sp->lsis[next_leap_idx].ls_trans - 1: MY_TIME_T_MAX);
@@ -1823,7 +1823,7 @@
   uchar types[TZ_MAX_TIMES];
   TRAN_TYPE_INFO ttis[TZ_MAX_TYPES];
 #ifdef ABBR_ARE_USED
-  char chars[max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
+  char chars[MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
 #endif
   /* 
     Used as a temporary tz_info until we decide that we actually want to
diff -urN mysql-old/sql/unireg.cc mysql/sql/unireg.cc
--- mysql-old/sql/unireg.cc	2009-12-10 00:54:18.672801332 -0100
+++ mysql/sql/unireg.cc	2009-12-10 00:57:23.410549895 -0100
@@ -490,7 +490,7 @@
     }
     cfield->row=(uint8) row;
     cfield->col=(uint8) (length+1);
-    cfield->sc_length=(uint8) min(cfield->length,cols-(length+2));
+    cfield->sc_length=(uint8) MYSQL_MIN(cfield->length,cols-(length+2));
   }
   length=(uint) (pos-start_screen);
   int2store(start_screen,length);
@@ -709,7 +709,7 @@
     DBUG_RETURN(1);
   }
   /* Hack to avoid bugs with small static rows in MySQL */
-  reclength=max(file->min_record_length(table_options),reclength);
+  reclength=MYSQL_MAX(file->min_record_length(table_options),reclength);
   if (info_length+(ulong) create_fields.elements*FCOMP+288+
       n_length+int_length+com_length > 65535L || int_count > 255)
   {
diff -urN mysql-old/sql-common/client.c mysql/sql-common/client.c
--- mysql-old/sql-common/client.c	2009-12-10 00:54:18.762801391 -0100
+++ mysql/sql-common/client.c	2009-12-10 00:57:23.411550572 -0100
@@ -728,7 +728,7 @@
       }
 
       (void) strmake(net->last_error,(char*) pos,
-		     min((uint) len,(uint) sizeof(net->last_error)-1));
+		     MYSQL_MIN((uint) len,(uint) sizeof(net->last_error)-1));
     }
     else
       set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
@@ -2102,7 +2102,7 @@
       {
         IF_DBUG(char ipaddr[18];)
         memcpy(&sock_addr.sin_addr, hp->h_addr_list[i],
-               min(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
+               MYSQL_MIN(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
         DBUG_PRINT("info",("Trying %s...",
                           (my_inet_ntoa(sock_addr.sin_addr, ipaddr), ipaddr)));
         status= my_connect(sock, (struct sockaddr *) &sock_addr,
diff -urN mysql-old/sql-common/my_time.c mysql/sql-common/my_time.c
--- mysql-old/sql-common/my_time.c	2009-12-10 00:54:18.762801391 -0100
+++ mysql/sql-common/my_time.c	2009-12-10 00:57:23.413549779 -0100
@@ -250,7 +250,7 @@
     2003-03-03 20:00:20 AM
     20:00:20.000000 AM 03-03-2000
   */
-  i= max((uint) format_position[0], (uint) format_position[1]);
+  i= MYSQL_MAX((uint) format_position[0], (uint) format_position[1]);
   set_if_bigger(i, (uint) format_position[2]);
   allow_space= ((1 << i) | (1 << format_position[6]));
   allow_space&= (1 | 2 | 4 | 8);
diff -urN mysql-old/storage/csv/ha_tina.cc mysql/storage/csv/ha_tina.cc
--- mysql-old/storage/csv/ha_tina.cc	2009-12-10 00:54:18.742800710 -0100
+++ mysql/storage/csv/ha_tina.cc	2009-12-10 00:57:23.414549859 -0100
@@ -1185,7 +1185,7 @@
   if (closest_hole == chain_ptr) /* no more chains */
     *end_pos= file_buff->end();
   else
-    *end_pos= min(file_buff->end(),
+    *end_pos= MYSQL_MIN(file_buff->end(),
                   closest_hole->begin);
   return (closest_hole != chain_ptr) && (*end_pos == closest_hole->begin);
 }
@@ -1421,7 +1421,7 @@
   /* write repaired file */
   while (1)
   {
-    write_end= min(file_buff->end(), current_position);
+    write_end= MYSQL_MIN(file_buff->end(), current_position);
     if ((write_end - write_begin) &&
         (my_write(repair_file, (uchar*)file_buff->ptr(),
                   (size_t) (write_end - write_begin), MYF_RW)))
diff -urN mysql-old/storage/example/ha_example.h mysql/storage/example/ha_example.h
--- mysql-old/storage/example/ha_example.h	2009-12-10 00:54:18.741801693 -0100
+++ mysql/storage/example/ha_example.h	2009-12-10 00:57:23.415549893 -0100
@@ -110,14 +110,14 @@
     max_supported_key_parts(), uint max_supported_key_length()
     to make sure that the storage engine can handle the data it is about to
     send. Return *real* limits of your storage engine here; MySQL will do
-    min(your_limits, MySQL_limits) automatically.
+    MYSQL_MIN(your_limits, MySQL_limits) automatically.
    */
   uint max_supported_record_length() const { return HA_MAX_REC_LENGTH; }
 
   /** @brief
     unireg.cc will call this to make sure that the storage engine can handle
     the data it is about to send. Return *real* limits of your storage engine
-    here; MySQL will do min(your_limits, MySQL_limits) automatically.
+    here; MySQL will do MYSQL_MIN(your_limits, MySQL_limits) automatically.
 
       @details
     There is no need to implement ..._key_... methods if your engine doesn't
@@ -128,7 +128,7 @@
   /** @brief
     unireg.cc will call this to make sure that the storage engine can handle
     the data it is about to send. Return *real* limits of your storage engine
-    here; MySQL will do min(your_limits, MySQL_limits) automatically.
+    here; MySQL will do MYSQL_MIN(your_limits, MySQL_limits) automatically.
 
       @details
     There is no need to implement ..._key_... methods if your engine doesn't
@@ -139,7 +139,7 @@
   /** @brief
     unireg.cc will call this to make sure that the storage engine can handle
     the data it is about to send. Return *real* limits of your storage engine
-    here; MySQL will do min(your_limits, MySQL_limits) automatically.
+    here; MySQL will do MYSQL_MIN(your_limits, MySQL_limits) automatically.
 
       @details
     There is no need to implement ..._key_... methods if your engine doesn't
diff -urN mysql-old/storage/federated/ha_federated.cc mysql/storage/federated/ha_federated.cc
--- mysql-old/storage/federated/ha_federated.cc	2009-12-10 00:54:18.741801693 -0100
+++ mysql/storage/federated/ha_federated.cc	2009-12-10 00:57:23.416697303 -0100
@@ -546,7 +546,7 @@
   size_t buf_len;
   DBUG_ENTER("ha_federated parse_url_error");
 
-  buf_len= min(table->s->connect_string.length,
+  buf_len= MYSQL_MIN(table->s->connect_string.length,
                FEDERATED_QUERY_BUFFER_SIZE-1);
   strmake(buf, table->s->connect_string.str, buf_len);
   my_error(error_num, MYF(0), buf);
@@ -1294,7 +1294,7 @@
     {
       Field *field= key_part->field;
       uint store_length= key_part->store_length;
-      uint part_length= min(store_length, length);
+      uint part_length= MYSQL_MIN(store_length, length);
       needs_quotes= field->str_needs_quotes();
       DBUG_DUMP("key, start of loop", ptr, length);
 
diff -urN mysql-old/storage/heap/hp_create.c mysql/storage/heap/hp_create.c
--- mysql-old/storage/heap/hp_create.c	2009-12-10 00:54:18.741801693 -0100
+++ mysql/storage/heap/hp_create.c	2009-12-10 00:57:23.417678529 -0100
@@ -229,7 +229,7 @@
 {
   uint i,recbuffer,records_in_block;
 
-  max_records= max(min_records,max_records);
+  max_records= MYSQL_MAX(min_records,max_records);
   if (!max_records)
     max_records= 1000;			/* As good as quess as anything */
   recbuffer= (uint) (reclength + sizeof(uchar**) - 1) & ~(sizeof(uchar**) - 1);
diff -urN mysql-old/storage/heap/hp_test2.c mysql/storage/heap/hp_test2.c
--- mysql-old/storage/heap/hp_test2.c	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/heap/hp_test2.c	2009-12-10 00:57:23.418705379 -0100
@@ -27,6 +27,7 @@
 
 #include "heapdef.h"		/* Because of hp_find_block */
 #include <signal.h>
+#include "my_global.h"
 
 #define MAX_RECORDS 100000
 #define MAX_KEYS 4
@@ -136,7 +137,7 @@
 
   for (i=0 ; i < recant ; i++)
   {
-    n1=rnd(1000); n2=rnd(100); n3=rnd(min(recant*5,MAX_RECORDS));
+    n1=rnd(1000); n2=rnd(100); n3=rnd(MYSQL_MIN(recant*5,MAX_RECORDS));
     make_record(record,n1,n2,n3,"Pos",write_count);
 
     if (heap_write(file,record))
@@ -217,7 +218,7 @@
   printf("- Update\n");
   for (i=0 ; i < write_count/10 ; i++)
   {
-    n1=rnd(1000); n2=rnd(100); n3=rnd(min(recant*2,MAX_RECORDS));
+    n1=rnd(1000); n2=rnd(100); n3=rnd(MYSQL_MIN(recant*2,MAX_RECORDS));
     make_record(record2, n1, n2, n3, "XXX", update);
     if (rnd(2) == 1)
     {
diff -urN mysql-old/storage/ibmdb2i/db2i_blobCollection.cc mysql/storage/ibmdb2i/db2i_blobCollection.cc
--- mysql-old/storage/ibmdb2i/db2i_blobCollection.cc	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/db2i_blobCollection.cc	2009-12-10 00:57:23.419619980 -0100
@@ -61,9 +61,9 @@
 
   uint curMaxSize = table->getBlobFieldActualSize(fieldIndex);
 
-  uint defaultAllocSize = min(defaultAllocation, fieldLength);
+  uint defaultAllocSize = MYSQL_MIN(defaultAllocation, fieldLength);
 
-  return max(defaultAllocSize, curMaxSize);
+  return MYSQL_MAX(defaultAllocSize, curMaxSize);
 
 }
       
diff -urN mysql-old/storage/ibmdb2i/db2i_conversion.cc mysql/storage/ibmdb2i/db2i_conversion.cc
--- mysql-old/storage/ibmdb2i/db2i_conversion.cc	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/db2i_conversion.cc	2009-12-10 00:57:23.419619980 -0100
@@ -528,13 +528,13 @@
           {
             if (field->type() == MYSQL_TYPE_STRING)
             {
-              sprintf(stringBuildBuffer, "BINARY(%d)", max(fieldLength, 1));
+              sprintf(stringBuildBuffer, "BINARY(%d)", MYSQL_MAX(fieldLength, 1));
             }
             else
             {
               if (fieldLength <= MAX_VARCHAR_LENGTH)
               {
-                sprintf(stringBuildBuffer, "VARBINARY(%d)", max(fieldLength, 1));
+                sprintf(stringBuildBuffer, "VARBINARY(%d)", MYSQL_MAX(fieldLength, 1));
               }
               else if (blobMapping == AS_VARCHAR &&
                        (field->flags & PART_KEY_FLAG))
@@ -543,8 +543,8 @@
               }
               else 
               {
-                fieldLength = min(MAX_BLOB_LENGTH, fieldLength);
-                sprintf(stringBuildBuffer, "BLOB(%d)", max(fieldLength, 1));
+                fieldLength = MYSQL_MIN(MAX_BLOB_LENGTH, fieldLength);
+                sprintf(stringBuildBuffer, "BLOB(%d)", MYSQL_MAX(fieldLength, 1));
               }
             }
             mapping.append(stringBuildBuffer);
@@ -559,24 +559,24 @@
               {
                 if (memcmp(fieldCharSet->name, "ucs2_", sizeof("ucs2_")-1) == 0 ) // UCS2
                 {
-                  sprintf(stringBuildBuffer, "GRAPHIC(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                  sprintf(stringBuildBuffer, "GRAPHIC(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                   db2Ccsid = 13488;
                 }
                 else if (memcmp(fieldCharSet->name, "utf8_", sizeof("utf8_")-1) == 0 &&
                          strcmp(fieldCharSet->name, "utf8_general_ci") != 0) 
                 {
-                  sprintf(stringBuildBuffer, "CHAR(%d)", max(fieldLength, 1)); // Number of bytes
+                  sprintf(stringBuildBuffer, "CHAR(%d)", MYSQL_MAX(fieldLength, 1)); // Number of bytes
                   db2Ccsid = 1208;
                 }
                 else
                 {
-                  sprintf(stringBuildBuffer, "GRAPHIC(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                  sprintf(stringBuildBuffer, "GRAPHIC(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                   db2Ccsid = 1200;
                 }
               }
               else
               {
-                sprintf(stringBuildBuffer, "CHAR(%d)", max(fieldLength, 1));
+                sprintf(stringBuildBuffer, "CHAR(%d)", MYSQL_MAX(fieldLength, 1));
               }
               mapping.append(stringBuildBuffer);
             }
@@ -588,24 +588,24 @@
                 {
                   if (memcmp(fieldCharSet->name, "ucs2_", sizeof("ucs2_")-1) == 0 ) // UCS2
                   {
-                    sprintf(stringBuildBuffer, "VARGRAPHIC(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                    sprintf(stringBuildBuffer, "VARGRAPHIC(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                     db2Ccsid = 13488;
                   }
                   else if (memcmp(fieldCharSet->name, "utf8_", sizeof("utf8_")-1) == 0 &&
                            strcmp(fieldCharSet->name, "utf8_general_ci") != 0) 
                   {
-                    sprintf(stringBuildBuffer, "VARCHAR(%d)", max(fieldLength, 1)); // Number of bytes
+                    sprintf(stringBuildBuffer, "VARCHAR(%d)", MYSQL_MAX(fieldLength, 1)); // Number of bytes
                     db2Ccsid = 1208;
                   }
                   else
                   {
-                    sprintf(stringBuildBuffer, "VARGRAPHIC(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                    sprintf(stringBuildBuffer, "VARGRAPHIC(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                     db2Ccsid = 1200;
                   }
                 }
                 else
                 {
-                  sprintf(stringBuildBuffer, "VARCHAR(%d)", max(fieldLength, 1));
+                  sprintf(stringBuildBuffer, "VARCHAR(%d)", MYSQL_MAX(fieldLength, 1));
                 }
               }
               else if (blobMapping == AS_VARCHAR &&
@@ -637,30 +637,30 @@
               }
               else
               {
-                fieldLength = min(MAX_BLOB_LENGTH, fieldLength);
+                fieldLength = MYSQL_MIN(MAX_BLOB_LENGTH, fieldLength);
 
                 if (fieldCharSet->mbmaxlen > 1)
                 {
                   if (memcmp(fieldCharSet->name, "ucs2_", sizeof("ucs2_")-1) == 0 ) // UCS2
                   {
-                    sprintf(stringBuildBuffer, "DBCLOB(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                    sprintf(stringBuildBuffer, "DBCLOB(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                     db2Ccsid = 13488;
                   }
                   else if (memcmp(fieldCharSet->name, "utf8_", sizeof("utf8_")-1) == 0 &&
                            strcmp(fieldCharSet->name, "utf8_general_ci") != 0) 
                   {
-                    sprintf(stringBuildBuffer, "CLOB(%d)", max(fieldLength, 1)); // Number of bytes
+                    sprintf(stringBuildBuffer, "CLOB(%d)", MYSQL_MAX(fieldLength, 1)); // Number of bytes
                     db2Ccsid = 1208;
                   }
                   else
                   {
-                    sprintf(stringBuildBuffer, "DBCLOB(%d)", max(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
+                    sprintf(stringBuildBuffer, "DBCLOB(%d)", MYSQL_MAX(fieldLength / fieldCharSet->mbmaxlen, 1)); // Number of characters
                     db2Ccsid = 1200;
                   }
                 }
                 else
                 {
-                  sprintf(stringBuildBuffer, "CLOB(%d)", max(fieldLength, 1)); // Number of characters
+                  sprintf(stringBuildBuffer, "CLOB(%d)", MYSQL_MAX(fieldLength, 1)); // Number of characters
                 }
               }
 
@@ -721,7 +721,7 @@
       {
         uint precision= ((Field_new_decimal*)field)->precision;
         uint scale= field->decimals();
-        uint db2Precision = min(precision, MAX_DEC_PRECISION);
+        uint db2Precision = MYSQL_MIN(precision, MAX_DEC_PRECISION);
         uint truncationAmount = precision - db2Precision;
         
         if (scale >= truncationAmount)
@@ -1101,7 +1101,7 @@
                   if (maxDisplayLength == 0 && db2FieldType == QMY_GRAPHIC)
                     maxDb2BytesToStore = 2;
                   else
-                    maxDb2BytesToStore = min(((bytesToStore * 2) / fieldCharSet->mbminlen),
+                    maxDb2BytesToStore = MYSQL_MIN(((bytesToStore * 2) / fieldCharSet->mbminlen),
                                              ((maxDisplayLength * 2) / fieldCharSet->mbmaxlen));
 
                   if (bytesToStore == 0)
@@ -1146,7 +1146,7 @@
                   else // Else Far East, special UTF8 or non-special UTF8/UCS2
                   {
                     size_t maxDb2BytesToStore;
-                    maxDb2BytesToStore = min(((bytesToStore * 2) / fieldCharSet->mbminlen),
+                    maxDb2BytesToStore = MYSQL_MIN(((bytesToStore * 2) / fieldCharSet->mbminlen),
                                              ((maxDisplayLength * 2) / fieldCharSet->mbmaxlen));
                     temp = getCharacterConversionBuffer(field->field_index, maxDb2BytesToStore);
                     rc = convertFieldChars(toDB2, field->field_index, (char*)dataToStore,temp,bytesToStore, maxDb2BytesToStore, &db2BytesToStore);
@@ -1199,7 +1199,7 @@
       {
         uint precision= ((Field_new_decimal*)field)->precision;
         uint scale= field->decimals();
-        uint db2Precision = min(precision, MAX_DEC_PRECISION);
+        uint db2Precision = MYSQL_MIN(precision, MAX_DEC_PRECISION);
         uint decimalPlace = precision-scale+1;
         char temp[80];
 
diff -urN mysql-old/storage/ibmdb2i/db2i_file.cc mysql/storage/ibmdb2i/db2i_file.cc
--- mysql-old/storage/ibmdb2i/db2i_file.cc	2009-12-10 00:54:18.739801321 -0100
+++ mysql/storage/ibmdb2i/db2i_file.cc	2009-12-10 00:57:23.420925523 -0100
@@ -335,14 +335,14 @@
     {
       strncpy(out, in, outlen);
       my_free(test, MYF(0));
-      return min(outlen, strlen(out));
+      return MYSQL_MIN(outlen, strlen(out));
     }
     ++cur;
   }
 
   strncpy(out, test, outlen);
   my_free(test, MYF(0));
-  return min(outlen, strlen(out));
+  return MYSQL_MIN(outlen, strlen(out));
 }
 
 void db2i_table::filenameToTablename(const char* in, char* out, size_t outlen)
@@ -366,8 +366,8 @@
       part4 = strend(in);
   }
   
-  memcpy(temp, part1, min(outlen, part2 - part1));
-  temp[min(outlen-1, part2-part1)] = 0;
+  memcpy(temp, part1, MYSQL_MIN(outlen, part2 - part1));
+  temp[MYSQL_MIN(outlen-1, part2-part1)] = 0;
     
   int32 accumLen = smartFilenameToTableName(temp, out, outlen);
   
@@ -376,9 +376,9 @@
     strcat(out, "#P#");
     accumLen += 4;
     
-    memset(temp, 0, min(outlen, part2-part1));
-    memcpy(temp, part3, min(outlen, part4-part3));
-    temp[min(outlen-1, part4-part3)] = 0;
+    memset(temp, 0, MYSQL_MIN(outlen, part2-part1));
+    memcpy(temp, part3, MYSQL_MIN(outlen, part4-part3));
+    temp[MYSQL_MIN(outlen-1, part4-part3)] = 0;
 
     accumLen += smartFilenameToTableName(temp, strend(out), outlen-accumLen);
     
@@ -484,7 +484,7 @@
   
   strncat(generatedName, 
           tableName+1,
-          min(strlen(tableName), (MAX_DB2_FILENAME_LENGTH-lenWithoutFile))-2 );
+          MYSQL_MIN(strlen(tableName), (MAX_DB2_FILENAME_LENGTH-lenWithoutFile))-2 );
 
   char finalName[MAX_DB2_FILENAME_LENGTH+1];
   convertMySQLNameToDB2Name(generatedName, finalName, sizeof(finalName), true, (format==ASCII_SQL));
diff -urN mysql-old/storage/ibmdb2i/db2i_ileBridge.cc mysql/storage/ibmdb2i/db2i_ileBridge.cc
--- mysql-old/storage/ibmdb2i/db2i_ileBridge.cc	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/db2i_ileBridge.cc	2009-12-10 00:57:23.421833794 -0100
@@ -594,7 +594,7 @@
   {
     Qmy_MSPO0100_output* output = (Qmy_MSPO0100_output*)parmBlock->outParms;
     *rfileHandle = output->ObjHnd;
-    *recLength = max(output->InNxtRowOff, output->OutNxtRowOff);    
+    *recLength = MYSQL_MAX(output->InNxtRowOff, output->OutNxtRowOff);    
   }
 
   
diff -urN mysql-old/storage/ibmdb2i/db2i_misc.h mysql/storage/ibmdb2i/db2i_misc.h
--- mysql-old/storage/ibmdb2i/db2i_misc.h	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/db2i_misc.h	2009-12-10 00:57:23.422555289 -0100
@@ -87,7 +87,7 @@
   
   if (delimit)
     output[o++] = '"';
-  output[min(o, outlen-1)] = 0; // This isn't the most user-friendly way to handle overflows,
+  output[MYSQL_MIN(o, outlen-1)] = 0; // This isn't the most user-friendly way to handle overflows,
                                   // but at least its safe.
   return (o <= outlen-1);
 }
diff -urN mysql-old/storage/ibmdb2i/db2i_safeString.h mysql/storage/ibmdb2i/db2i_safeString.h
--- mysql-old/storage/ibmdb2i/db2i_safeString.h	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/db2i_safeString.h	2009-12-10 00:57:23.422555289 -0100
@@ -79,7 +79,7 @@
   
   SafeString& strncat(const char* str, size_t len)
   {
-    uint64 amountToCopy = min((allocSize-1) - curPos, len);
+    uint64 amountToCopy = MYSQL_MIN((allocSize-1) - curPos, len);
     memcpy(buf + curPos, str, amountToCopy);
     curPos += amountToCopy;
     buf[curPos] = 0;
diff -urN mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc mysql/storage/ibmdb2i/ha_ibmdb2i.cc
--- mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/ha_ibmdb2i.cc	2009-12-10 00:57:23.423612063 -0100
@@ -2644,9 +2644,9 @@
     rowsToRead = 1;
   }
   
-  rowsToRead = min(stats.records+1,min(rowsToRead, DEFAULT_MAX_ROWS_TO_BUFFER));
+  rowsToRead = MYSQL_MIN(stats.records+1,MYSQL_MIN(rowsToRead, DEFAULT_MAX_ROWS_TO_BUFFER));
   
-  uint bufSize = min((format->readRowLen * rowsToRead), THDVAR(thd, max_read_buffer_size));
+  uint bufSize = MYSQL_MIN((format->readRowLen * rowsToRead), THDVAR(thd, max_read_buffer_size));
   multiRowReadBuf.allocBuf(format->readRowLen, format->readRowNullOffset, bufSize);
   activeReadBuf = &multiRowReadBuf;
     
@@ -2682,9 +2682,9 @@
 
   if (unlikely(rc)) DBUG_RETURN(rc);
   
-  rowsToWrite = min(rowsToWrite, DEFAULT_MAX_ROWS_TO_BUFFER);
+  rowsToWrite = MYSQL_MIN(rowsToWrite, DEFAULT_MAX_ROWS_TO_BUFFER);
   
-  uint bufSize = min((format->writeRowLen * rowsToWrite), THDVAR(ha_thd(), max_write_buffer_size));
+  uint bufSize = MYSQL_MIN((format->writeRowLen * rowsToWrite), THDVAR(ha_thd(), max_write_buffer_size));
   multiRowWriteBuf.allocBuf(format->writeRowLen, format->writeRowNullOffset, bufSize);
   activeWriteBuf = &multiRowWriteBuf;
 
@@ -2768,8 +2768,8 @@
       else
       {
         char unknownIndex[MAX_DB2_FILENAME_LENGTH+1];
-        convFromEbcdic(lastDupKeyNamePtr, unknownIndex, min(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH));
-        unknownIndex[min(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH)] = 0;        
+        convFromEbcdic(lastDupKeyNamePtr, unknownIndex, MYSQL_MIN(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH));
+        unknownIndex[MYSQL_MIN(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH)] = 0;        
         getErrTxt(DB2I_ERR_UNKNOWN_IDX, unknownIndex);
       }
     }
@@ -3141,7 +3141,7 @@
   if (forceSingleRowRead)
     rowsToBuffer = 1;
   else
-    rowsToBuffer = min(rowsToBuffer, activeReadBuf->getRowCapacity());
+    rowsToBuffer = MYSQL_MIN(rowsToBuffer, activeReadBuf->getRowCapacity());
         
   activeReadBuf->newReadRequest(activeHandle,
                                     orientation,
@@ -3279,7 +3279,7 @@
        double dataPageCount = stats.data_file_length/IO_SIZE;
                   
        cost = (rows * dataPageCount / totalRecords) + 
-               min(idxPageCnt, (log_2(idxPageCnt) * ranges + 
+               MYSQL_MIN(idxPageCnt, (log_2(idxPageCnt) * ranges + 
                                 rows * (log_2(idxPageCnt) + log_2(rows) - log_2(totalRecords))));
      } 
   }
diff -urN mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc.orig mysql/storage/ibmdb2i/ha_ibmdb2i.cc.orig
--- mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc.orig	1969-12-31 23:00:00.000000000 -0100
+++ mysql/storage/ibmdb2i/ha_ibmdb2i.cc.orig	2009-12-10 00:57:23.427924858 -0100
@@ -0,0 +1,3359 @@
+/*
+Licensed Materials - Property of IBM
+DB2 Storage Engine Enablement
+Copyright IBM Corporation 2007,2008
+All rights reserved
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met: 
+ (a) Redistributions of source code must retain this list of conditions, the
+     copyright notice in section {d} below, and the disclaimer following this
+     list of conditions. 
+ (b) Redistributions in binary form must reproduce this list of conditions, the
+     copyright notice in section (d) below, and the disclaimer following this
+     list of conditions, in the documentation and/or other materials provided
+     with the distribution. 
+ (c) The name of IBM may not be used to endorse or promote products derived from
+     this software without specific prior written permission. 
+ (d) The text of the required copyright notice is: 
+       Licensed Materials - Property of IBM
+       DB2 Storage Engine Enablement 
+       Copyright IBM Corporation 2007,2008 
+       All rights reserved
+
+THIS SOFTWARE IS PROVIDED BY IBM CORPORATION "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+SHALL IBM CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+OF SUCH DAMAGE.
+*/
+
+
+/**
+  @file ha_ibmdb2i.cc
+
+  @brief
+  The ha_ibmdb2i storage engine provides an interface from MySQL to IBM DB2 for i.
+
+*/
+
+#ifdef USE_PRAGMA_IMPLEMENTATION
+#pragma implementation        // gcc: Class implementation
+#endif
+
+#include "ha_ibmdb2i.h"
+#include "mysql_priv.h"
+#include <mysql/plugin.h>
+#include "db2i_ileBridge.h"
+#include "db2i_charsetSupport.h"
+#include <sys/utsname.h>
+#include "db2i_safeString.h"
+
+static const char __NOT_NULL_VALUE_EBCDIC = 0xF0; // '0'
+static const char __NULL_VALUE_EBCDIC = 0xF1; // '1'
+static const char __DEFAULT_VALUE_EBCDIC = 0xC4; // 'D'
+static const char BlankASPName[19] = "                  ";
+static const int DEFAULT_MAX_ROWS_TO_BUFFER = 4096;
+
+static const char SAVEPOINT_PREFIX[] = {0xD4, 0xE8, 0xE2, 0xD7}; // MYSP (in EBCDIC)
+
+OSVersion osVersion;
+
+
+// ================================================================
+// ================================================================
+// System variables
+static char* ibmdb2i_rdb_name;
+static MYSQL_SYSVAR_STR(rdb_name, ibmdb2i_rdb_name,
+  PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY,
+  "The name of the RDB to use",
+  NULL, 
+  NULL,
+  BlankASPName);
+
+static MYSQL_THDVAR_BOOL(transaction_unsafe,
+  0,
+  "Disable support for commitment control",
+  NULL, 
+  NULL, 
+  FALSE);
+
+static MYSQL_THDVAR_UINT(lob_alloc_size,
+  0,
+  "Baseline allocation for lob read buffer",
+  NULL, 
+  NULL, 
+  2*1024*1024,
+  64*1024,
+  128*1024*1024,
+  1);
+
+static MYSQL_THDVAR_UINT(max_read_buffer_size,
+  0,
+  "Maximum size of buffers used for read-ahead.",
+  NULL,
+  NULL,
+  1*1024*1024,
+  32*1024,
+  16*1024*1024,
+  1);
+  
+static MYSQL_THDVAR_UINT(max_write_buffer_size,
+  0,
+  "Maximum size of buffers used for bulk writes.",
+  NULL,
+  NULL,
+  8*1024*1024,
+  32*1024,
+  64*1024*1024,
+  1);
+
+static MYSQL_THDVAR_BOOL(compat_opt_time_as_duration,
+  0,
+  "Control how new TIME columns should be defined in DB2. 0=time-of-day (default), 1=duration.",
+  NULL, 
+  NULL, 
+  FALSE);
+
+static MYSQL_THDVAR_UINT(compat_opt_year_as_int,
+  0,
+  "Control how new YEAR columns should be defined in DB2. 0=CHAR(4) (default), 1=SMALLINT.",
+  NULL, 
+  NULL, 
+  0,
+  0,
+  1,
+  1);
+
+static MYSQL_THDVAR_UINT(compat_opt_blob_cols,
+  0,
+  "Control how new TEXT and BLOB columns should be defined in DB2. 0=CLOB/BLOB (default), 1=VARCHAR/VARBINARY",
+  NULL, 
+  NULL, 
+  0,
+  0,
+  1,
+  1);
+
+static MYSQL_THDVAR_UINT(compat_opt_allow_zero_date_vals,
+  0,
+  "Allow substitute values to be used when storing a column with a 0000-00-00 date component. 0=No substitution (default), 1=Substitute '0001-01-01'",
+  NULL, 
+  NULL, 
+  0,
+  0,
+  1,
+  1);
+
+static MYSQL_THDVAR_BOOL(propagate_default_col_vals,
+  0,
+  "Should DEFAULT column values be propagated to the DB2 table definition.",
+  NULL, 
+  NULL, 
+  TRUE);
+
+static my_bool ibmdb2i_assume_exclusive_use;
+static MYSQL_SYSVAR_BOOL(assume_exclusive_use, ibmdb2i_assume_exclusive_use,
+  0,
+  "Can MySQL assume that this process is the only one modifying the DB2 tables. ",
+  NULL, 
+  NULL, 
+  FALSE);
+
+static MYSQL_THDVAR_BOOL(async_enabled,
+  0,
+  "Should reads be done asynchronously when possible",
+  NULL, 
+  NULL, 
+  TRUE);
+
+static MYSQL_THDVAR_UINT(create_index_option,
+  0,
+  "Control whether additional indexes are created. 0=No (default), 1=Create additional *HEX-based index",
+  NULL,
+  NULL,
+  0,
+  0,
+  1,
+  1);
+
+/* static MYSQL_THDVAR_UINT(discovery_mode,
+  0,
+  "Unsupported",
+  NULL,
+  NULL,
+  0,
+  0,
+  1,
+  1); */
+
+static uint32 ibmdb2i_system_trace;
+static MYSQL_SYSVAR_UINT(system_trace_level, ibmdb2i_system_trace,
+  0,
+  "Set system tracing level",
+  NULL, 
+  NULL, 
+  0,
+  0,
+  63,
+  1);
+
+
+inline uint8 ha_ibmdb2i::getCommitLevel(THD* thd)
+{
+  if (!THDVAR(thd, transaction_unsafe))
+  {    
+    switch (thd_tx_isolation(thd))
+    {
+      case ISO_READ_UNCOMMITTED: 
+        return (accessIntent == QMY_READ_ONLY ? QMY_READ_UNCOMMITTED : QMY_REPEATABLE_READ);
+      case ISO_READ_COMMITTED: 
+        return (accessIntent == QMY_READ_ONLY ? QMY_READ_COMMITTED : QMY_REPEATABLE_READ);
+      case ISO_REPEATABLE_READ: 
+        return QMY_REPEATABLE_READ;
+      case ISO_SERIALIZABLE: 
+        return QMY_SERIALIZABLE;
+    }
+  }
+
+  return QMY_NONE;
+}
+
+inline uint8 ha_ibmdb2i::getCommitLevel()
+{
+  return getCommitLevel(ha_thd());
+}
+
+//=====================================================================
+
+static handler *ibmdb2i_create_handler(handlerton *hton,
+                                       TABLE_SHARE *table, 
+                                       MEM_ROOT *mem_root);
+static void ibmdb2i_drop_database(handlerton *hton, char* path);
+static int ibmdb2i_savepoint_set(handlerton *hton, THD* thd, void *sv);
+static int ibmdb2i_savepoint_rollback(handlerton *hton, THD* thd, void *sv);
+static int ibmdb2i_savepoint_release(handlerton *hton, THD* thd, void *sv);
+static uint ibmdb2i_alter_table_flags(uint flags);
+
+handlerton *ibmdb2i_hton;
+static bool was_ILE_inited;
+
+/* Tracks the number of open tables */
+static HASH ibmdb2i_open_tables;
+
+/* Mutex used to synchronize initialization of the hash */
+static pthread_mutex_t ibmdb2i_mutex;
+
+
+/**
+  Create hash key for tracking open tables.
+*/
+
+static uchar* ibmdb2i_get_key(IBMDB2I_SHARE *share,size_t *length,
+                             bool not_used __attribute__((unused)))
+{
+  *length=share->table_name_length;
+  return (uchar*) share->table_name;
+}
+
+
+int ibmdb2i_close_connection(handlerton* hton, THD *thd)
+{
+  DBUG_PRINT("ha_ibmdb2i::close_connection", ("Closing %d", thd->thread_id));
+  db2i_ileBridge::getBridgeForThread(thd)->closeConnection(thd->thread_id);
+  db2i_ileBridge::destroyBridgeForThread(thd);
+  
+  return 0;  
+}
+
+
+static int ibmdb2i_init_func(void *p)
+{
+  DBUG_ENTER("ibmdb2i_init_func");
+  
+  utsname tempName;
+  uname(&tempName);
+  osVersion.v = atoi(tempName.version);
+  osVersion.r = atoi(tempName.release);
+  
+  was_ILE_inited = false;
+  ibmdb2i_hton= (handlerton *)p;
+  VOID(pthread_mutex_init(&ibmdb2i_mutex,MY_MUTEX_INIT_FAST));
+  (void) hash_init(&ibmdb2i_open_tables,system_charset_info,32,0,0,
+                   (hash_get_key) ibmdb2i_get_key,0,0);
+
+  ibmdb2i_hton->state=   SHOW_OPTION_YES;
+  ibmdb2i_hton->create=  ibmdb2i_create_handler;
+  ibmdb2i_hton->drop_database= ibmdb2i_drop_database;
+  ibmdb2i_hton->commit=  ha_ibmdb2i::doCommit;
+  ibmdb2i_hton->rollback= ha_ibmdb2i::doRollback;
+  ibmdb2i_hton->savepoint_offset= 0;
+  ibmdb2i_hton->savepoint_set= ibmdb2i_savepoint_set;
+  ibmdb2i_hton->savepoint_rollback= ibmdb2i_savepoint_rollback;
+  ibmdb2i_hton->savepoint_release= ibmdb2i_savepoint_release;
+  ibmdb2i_hton->alter_table_flags=ibmdb2i_alter_table_flags;
+  ibmdb2i_hton->close_connection=ibmdb2i_close_connection;
+
+  int rc;
+  
+  rc = initCharsetSupport();
+    
+  if (!rc)
+    rc = db2i_ileBridge::setup();
+  
+  if (!rc)
+  {
+    int nameLen = strlen(ibmdb2i_rdb_name);
+    for (int i = 0; i < nameLen; ++i)
+    {
+      ibmdb2i_rdb_name[i] = my_toupper(system_charset_info, (uchar)ibmdb2i_rdb_name[i]);
+    }    
+    
+    rc = db2i_ileBridge::initILE(ibmdb2i_rdb_name, (uint16*)(((char*)&ibmdb2i_system_trace)+2));
+    if (rc == 0)
+    {
+      was_ILE_inited = true;
+    }
+  }
+  
+  DBUG_RETURN(rc);
+}
+
+
+static int ibmdb2i_done_func(void *p)
+{
+  int error= 0;
+  DBUG_ENTER("ibmdb2i_done_func");
+
+  if (ibmdb2i_open_tables.records)
+    error= 1;  
+  
+  if (was_ILE_inited)
+    db2i_ileBridge::exitILE();
+
+  db2i_ileBridge::takedown();
+  
+  doneCharsetSupport();
+
+  hash_free(&ibmdb2i_open_tables);
+  pthread_mutex_destroy(&ibmdb2i_mutex);
+  
+  DBUG_RETURN(0);
+}
+
+
+IBMDB2I_SHARE *ha_ibmdb2i::get_share(const char *table_name, TABLE *table)
+{
+  IBMDB2I_SHARE *share;
+  uint length;
+  char *tmp_name;
+  
+  pthread_mutex_lock(&ibmdb2i_mutex);
+  length=(uint) strlen(table_name);
+
+  if (!(share=(IBMDB2I_SHARE*) hash_search(&ibmdb2i_open_tables,
+                                           (uchar*)table_name,
+                                           length)))
+  {
+    if (!(share=(IBMDB2I_SHARE *)
+          my_multi_malloc(MYF(MY_WME | MY_ZEROFILL),
+                          &share, sizeof(*share),
+                          &tmp_name, length+1,
+                          NullS)))
+    {
+      pthread_mutex_unlock(&ibmdb2i_mutex);
+      return NULL;
+    }
+
+    share->use_count=0;
+    share->table_name_length=length;
+    share->table_name=tmp_name;
+    strmov(share->table_name,table_name);
+    if (my_hash_insert(&ibmdb2i_open_tables, (uchar*) share))
+      goto error;
+    thr_lock_init(&share->lock);
+    pthread_mutexattr_t mutexattr = MY_MUTEX_INIT_FAST;
+    pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);
+    pthread_mutex_init(&share->mutex, &mutexattr);
+    
+    share->db2Table = new db2i_table(table->s, table_name);
+    int32 rc = share->db2Table->initDB2Objects(table_name);
+    
+    if (rc)
+    {
+      delete share->db2Table;
+      hash_delete(&ibmdb2i_open_tables, (uchar*) share);
+      thr_lock_delete(&share->lock);
+      my_errno = rc;
+      goto error;
+    }
+    
+    memset(&share->cachedStats, 0, sizeof(share->cachedStats));
+  }
+  share->use_count++;
+  pthread_mutex_unlock(&ibmdb2i_mutex);
+
+  db2Table = share->db2Table;
+  
+  return share;
+
+error:
+  pthread_mutex_destroy(&share->mutex);
+  my_free((uchar*) share, MYF(0));
+  pthread_mutex_unlock(&ibmdb2i_mutex);
+
+  return NULL;
+}
+
+
+
+int ha_ibmdb2i::free_share(IBMDB2I_SHARE *share)
+{
+  pthread_mutex_lock(&ibmdb2i_mutex);
+  if (!--share->use_count)
+  {
+    delete share->db2Table;
+    db2Table = NULL;
+
+    hash_delete(&ibmdb2i_open_tables, (uchar*) share);
+    thr_lock_delete(&share->lock);
+    pthread_mutex_destroy(&share->mutex);
+    my_free(share, MYF(0));
+    pthread_mutex_unlock(&ibmdb2i_mutex);
+    return 1;
+  }
+  pthread_mutex_unlock(&ibmdb2i_mutex);
+
+  return 0;
+}
+
+static handler* ibmdb2i_create_handler(handlerton *hton,
+                                       TABLE_SHARE *table, 
+                                       MEM_ROOT *mem_root)
+{
+  return new (mem_root) ha_ibmdb2i(hton, table);
+}
+
+static void ibmdb2i_drop_database(handlerton *hton, char* path)
+{
+  DBUG_ENTER("ha_ibmdb2i::ibmdb2i_drop_database");
+  int rc = 0;
+  char queryBuffer[200];
+  String query(queryBuffer, sizeof(queryBuffer), system_charset_info);
+  query.length(0);
+  query.append(STRING_WITH_LEN(" DROP SCHEMA \""));
+  query.append(path+2, strchr(path+2, '/')-(path+2));
+  query.append('"');
+  
+  SqlStatementStream sqlStream(query);
+  
+  rc = db2i_ileBridge::getBridgeForThread()->execSQL(sqlStream.getPtrToData(),
+                                              sqlStream.getStatementCount(),
+                                              QMY_NONE,
+                                              FALSE,
+                                              TRUE);
+  DBUG_VOID_RETURN;
+}
+
+inline static void genSavepointName(const void* sv, char* out)
+{
+  *(uint32*)out = *(uint32*)SAVEPOINT_PREFIX;
+  DBUG_ASSERT(sizeof(SAVEPOINT_PREFIX) == 4);
+  out += sizeof(SAVEPOINT_PREFIX);
+  
+  longlong2str((longlong)sv, out, 10);
+  while (*out)
+  {
+    out += 0xF0;
+    ++out;
+  }
+}
+
+
+/*********************************************************************
+Sets a transaction savepoint. */
+static int ibmdb2i_savepoint_set(handlerton* hton, THD* thd, void* sv) 
+{
+  DBUG_ENTER("ibmdb2i_savepoint_set");
+  int rc = 0;
+  if (!THDVAR(thd ,transaction_unsafe))
+  {
+    char name[64];
+    genSavepointName(sv, name);
+    DBUG_PRINT("ibmdb2i_savepoint_set",("Setting %s", name));
+    rc = ha_ibmdb2i::doSavepointSet(thd, name);
+  } 
+  DBUG_RETURN(rc);
+}
+
+
+/*********************************************************************
+Rollback a savepoint. */
+static int ibmdb2i_savepoint_rollback(handlerton* hton, THD* thd, void* sv) 
+{
+  DBUG_ENTER("ibmdb2i_savepoint_rollback");
+  int rc = 0;
+  if (!THDVAR(thd,transaction_unsafe))
+  {
+    char name[64];
+    genSavepointName(sv, name);
+    DBUG_PRINT("ibmdb2i_savepoint_rollback",("Rolling back %s", name));
+    rc = ha_ibmdb2i::doSavepointRollback(thd, name);
+  } 
+  DBUG_RETURN(rc);  
+}
+
+
+/*********************************************************************
+Release a savepoint. */
+static int ibmdb2i_savepoint_release(handlerton* hton, THD* thd, void* sv) 
+{
+  DBUG_ENTER("ibmdb2i_savepoint_release");
+  int rc = 0;
+  if (!THDVAR(thd,transaction_unsafe))
+  {
+    char name[64];
+    genSavepointName(sv, name);
+    DBUG_PRINT("ibmdb2i_savepoint_release",("Releasing %s", name));
+    rc = ha_ibmdb2i::doSavepointRelease(thd, name);
+  } 
+  DBUG_RETURN(rc);
+}
+
+/* Thse flags allow for the online add and drop of an index via the CREATE INDEX,
+   DROP INDEX, and ALTER TABLE statements. These flags indicate that MySQL is not
+   required to lock the table before calling the storage engine to add or drop the
+   index(s).  */                    
+static uint ibmdb2i_alter_table_flags(uint flags)
+{
+  return (HA_ONLINE_ADD_INDEX | HA_ONLINE_DROP_INDEX |
+          HA_ONLINE_ADD_UNIQUE_INDEX | HA_ONLINE_DROP_UNIQUE_INDEX |
+          HA_ONLINE_ADD_PK_INDEX | HA_ONLINE_DROP_PK_INDEX); 
+}
+
+ha_ibmdb2i::ha_ibmdb2i(handlerton *hton, TABLE_SHARE *table_arg)
+  :share(NULL), handler(hton, table_arg),
+   activeHandle(0), dataHandle(0),
+    activeReadBuf(NULL), activeWriteBuf(NULL),
+    blobReadBuffers(NULL), accessIntent(QMY_UPDATABLE), currentRRN(0),
+    releaseRowNeeded(FALSE),
+    indexReadSizeEstimates(NULL),
+    outstanding_start_bulk_insert(false),
+    last_rnd_init_rc(0),
+    last_index_init_rc(0),
+    last_start_bulk_insert_rc(0),
+    autoIncLockAcquired(false),
+    got_auto_inc_values(false),
+    next_identity_value(0),
+    indexHandles(0),
+    returnDupKeysImmediately(false),
+    onDupUpdate(false), 
+    blobWriteBuffers(NULL),
+    forceSingleRowRead(false)
+ {
+   activeReferences = 0;
+   ref_length = sizeof(currentRRN);
+   if (table_share && table_share->keys > 0)
+   {
+     indexHandles = (FILE_HANDLE*)my_malloc(table_share->keys * sizeof(FILE_HANDLE), MYF(MY_WME | MY_ZEROFILL));
+   }
+   clear_alloc_root(&conversionBufferMemroot);
+ }
+
+
+ha_ibmdb2i::~ha_ibmdb2i()
+{
+  DBUG_ASSERT(activeReferences == 0 || outstanding_start_bulk_insert);
+    
+  if (indexHandles)
+    my_free(indexHandles, MYF(0));
+  if (indexReadSizeEstimates)
+    my_free(indexReadSizeEstimates, MYF(0));
+  
+  cleanupBuffers();
+}
+ 
+ 
+static const char *ha_ibmdb2i_exts[] = {
+  FID_EXT,
+  NullS
+};
+
+const char **ha_ibmdb2i::bas_ext() const
+{
+  return ha_ibmdb2i_exts;
+}
+
+
+int ha_ibmdb2i::open(const char *name, int mode, uint test_if_locked)
+{
+  DBUG_ENTER("ha_ibmdb2i::open");
+
+  initBridge();
+  
+  dataHandle = bridge()->findAndRemovePreservedHandle(name, &share);
+  
+  if (share)
+    db2Table = share->db2Table;
+  
+  if (!share && (!(share = get_share(name, table))))
+    DBUG_RETURN(my_errno);
+  thr_lock_data_init(&share->lock,&lock,NULL);
+
+  info(HA_STATUS_NO_LOCK | HA_STATUS_CONST | HA_STATUS_VARIABLE);
+
+    
+  DBUG_RETURN(0);
+}
+
+
+
+
+int ha_ibmdb2i::close(void)
+{
+  DBUG_ENTER("ha_ibmdb2i::close");
+  int32 rc = 0;
+  bool preserveShare = false;
+  
+  db2i_ileBridge* bridge = db2i_ileBridge::getBridgeForThread();
+  
+  if (dataHandle)
+  {
+    if (bridge->expectErrors(QMY_ERR_PEND_LOCKS)->deallocateFile(dataHandle, FALSE) == QMY_ERR_PEND_LOCKS)
+    {
+      bridge->preserveHandle(share->table_name, dataHandle, share);
+      preserveShare = true;
+    }
+    dataHandle = 0;
+  }
+
+  for (int idx = 0; idx < table_share->keys; ++idx)
+  {
+    if (indexHandles[idx] != 0)
+    {
+      bridge->deallocateFile(indexHandles[idx], FALSE);
+    }
+  }
+  
+  cleanupBuffers();
+    
+  if (!preserveShare)
+  {
+    if (free_share(share))
+      share = NULL;
+  }
+  
+  DBUG_RETURN(rc);
+}
+
+
+
+int ha_ibmdb2i::write_row(uchar * buf)
+{  
+
+  DBUG_ENTER("ha_ibmdb2i::write_row");
+  
+  if (last_start_bulk_insert_rc)
+    DBUG_RETURN( last_start_bulk_insert_rc );
+  
+  ha_statistic_increment(&SSV::ha_write_count);
+  int rc = 0;
+
+  bool fileHandleNeedsRelease = false;
+  
+  if (!activeHandle)
+  {
+    rc = useDataFile();
+    if (rc) DBUG_RETURN(rc);
+    fileHandleNeedsRelease = true;
+  }
+      
+  if (!outstanding_start_bulk_insert)
+    rc = prepWriteBuffer(1, getFileForActiveHandle());
+  
+  if (!rc)
+  {
+    if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_INSERT)
+      table->timestamp_field->set_time();
+
+    char* writeBuffer = activeWriteBuf->addRow();
+    rc = prepareRowForWrite(writeBuffer, 
+                            writeBuffer+activeWriteBuf->getRowNullOffset(),
+                            true);
+    if (rc == 0)
+    {
+      // If we are doing block inserts, if the MI is supposed to generate an auto_increment
+      // (i.e. identity column) value for this record, and if this is not the first record in
+      // the block, then store the value (that the MI will generate for the identity column)
+      // into the MySQL write buffer. We can predetermine the value because the file is locked.    
+
+      if ((autoIncLockAcquired) && (default_identity_value) && (got_auto_inc_values))
+      { 
+        if (unlikely((next_identity_value - 1) == 
+                      maxValueForField(table->next_number_field)))
+        {
+          rc = QMY_ERR_MAXVALUE;
+        }
+        else
+        {
+          rc = table->next_number_field->store((longlong) next_identity_value, TRUE);
+          next_identity_value = next_identity_value + incrementByValue;
+        }
+      }
+      // If the buffer is full, or if we locked the file and this is the first or last row
+      // of a blocked insert, then flush the buffer.    
+      if (!rc && (activeWriteBuf->endOfBuffer()) ||
+          ((autoIncLockAcquired) &&
+           ((!got_auto_inc_values))) ||
+          (returnDupKeysImmediately))
+        rc = flushWrite(activeHandle, buf);
+    }
+    else
+      activeWriteBuf->deleteRow();
+  }
+      
+  if (fileHandleNeedsRelease)
+    releaseActiveHandle();
+  
+  DBUG_RETURN(rc);
+}
+
+/**
+  @brief 
+  Helper function used by write_row and update_row to prepare the MySQL
+  row for insertion into DB2.
+*/
+int ha_ibmdb2i::prepareRowForWrite(char* data, char* nulls, bool honorIdentCols)
+{
+  int rc = 0;
+  
+  // set null map all to non nulls
+  memset(nulls,__NOT_NULL_VALUE_EBCDIC, table->s->fields);
+  default_identity_value = FALSE;  
+    
+  ulong sql_mode = ha_thd()->variables.sql_mode;
+  
+  my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->read_set);
+  for (Field **field = table->field; *field && !rc; ++field)
+  {  
+    int fieldIndex = (*field)->field_index;
+    if ((*field)->Field::is_null())                        
+    {                                                  
+      nulls[fieldIndex] = __NULL_VALUE_EBCDIC;         
+    }                                                 
+    if (honorIdentCols && ((*field)->flags & AUTO_INCREMENT_FLAG) &&
+        *field == table->next_number_field) 
+//     && ((!autoIncLockAcquired) || (!got_auto_inc_values)))
+    {
+      if (sql_mode & MODE_NO_AUTO_VALUE_ON_ZERO)
+      {
+        if (!table->auto_increment_field_not_null)
+        {
+          nulls[fieldIndex] = __DEFAULT_VALUE_EBCDIC;
+          default_identity_value = TRUE; 
+        }
+      }
+      else if ((*field)->val_int() == 0)
+      {
+        nulls[fieldIndex] = __DEFAULT_VALUE_EBCDIC;
+        default_identity_value = TRUE; 
+      }
+    }   
+    
+    DB2Field& db2Field = db2Table->db2Field(fieldIndex);
+    if (nulls[fieldIndex] == __NOT_NULL_VALUE_EBCDIC ||
+        db2Field.isBlob())
+    {
+      rc = convertMySQLtoDB2(*field, db2Field, data + db2Field.getBufferOffset());
+    }
+  }  
+  
+  if (!rc && db2Table->hasBlobs())
+    rc = db2i_ileBridge::getBridgeForThread()->objectOverride(activeHandle,
+                                                            activeWriteBuf->ptr());  
+
+  dbug_tmp_restore_column_map(table->read_set, old_map);
+
+  return rc; 
+}
+
+
+
+int ha_ibmdb2i::update_row(const uchar * old_data, uchar * new_data)
+{
+  DBUG_ENTER("ha_ibmdb2i::update_row");
+  ha_statistic_increment(&SSV::ha_update_count);
+  int rc;
+  
+  bool fileHandleNeedsRelease = false;
+  
+  if (!activeHandle)
+  {
+    rc = useFileByHandle(QMY_UPDATABLE, rrnAssocHandle);
+    if (rc) DBUG_RETURN(rc);
+    fileHandleNeedsRelease = true;
+  }
+    
+  if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_UPDATE)
+    table->timestamp_field->set_time();
+  
+  char* writeBuf = activeWriteBuf->addRow();
+  rc = prepareRowForWrite(writeBuf, 
+                          writeBuf+activeWriteBuf->getRowNullOffset(),
+                          onDupUpdate);
+
+  char* lastDupKeyNamePtr = NULL;
+  uint32 lastDupKeyNameLen = 0;
+  
+  if (!rc)
+  {
+    rc = db2i_ileBridge::getBridgeForThread()->updateRow(activeHandle,
+                                                       currentRRN,
+                                                       activeWriteBuf->ptr(),
+                                                       &lastDupKeyRRN,
+                                                       &lastDupKeyNamePtr,
+                                                       &lastDupKeyNameLen);
+  }
+  
+  if (lastDupKeyNameLen)
+  {
+    lastDupKeyID = getKeyFromName(lastDupKeyNamePtr, lastDupKeyNameLen);
+    rrnAssocHandle = activeHandle;
+  }
+
+  if (fileHandleNeedsRelease)
+    releaseActiveHandle();
+  
+  activeWriteBuf->resetAfterWrite();
+    
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::delete_row(const uchar * buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::delete_row");
+  ha_statistic_increment(&SSV::ha_delete_count);
+  
+  bool needReleaseFile = false;
+  int rc = 0;
+  
+  if (!activeHandle) // In some circumstances, MySQL comes here after
+  {                  // closing the active handle. We need to re-open.
+    rc = useFileByHandle(QMY_UPDATABLE, rrnAssocHandle);    
+    needReleaseFile = true;
+  }
+      
+  if (likely(!rc))
+  {
+    rc = db2i_ileBridge::getBridgeForThread()->deleteRow(activeHandle,
+                                                       currentRRN);  
+    invalidateCachedStats();
+    if (needReleaseFile)
+      releaseActiveHandle();
+  }
+ 
+  DBUG_RETURN(rc);
+}
+
+
+
+int ha_ibmdb2i::index_init(uint idx, bool sorted)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_init");
+  
+  int& rc = last_index_init_rc;
+  rc = 0;
+  
+  invalidDataFound=false;
+  tweakReadSet();
+    
+  active_index=idx;
+
+  rc = useIndexFile(idx);
+  
+  if (!rc)
+  {
+//     THD* thd = ha_thd();
+//     if (accessIntent == QMY_UPDATABLE &&
+//         thd_tx_isolation(thd) == ISO_REPEATABLE_READ &&
+//         !THDVAR(thd, transaction_unsafe))
+//     {
+//       readAccessIntent = QMY_READ_ONLY;
+//     }
+//     else
+//     {
+      readAccessIntent = accessIntent;
+//     }
+    
+    if (!rc && accessIntent != QMY_READ_ONLY)
+      rc = prepWriteBuffer(1, db2Table->indexFile(idx));
+    
+    if (rc)
+      releaseIndexFile(idx);
+  }
+  
+  rrnAssocHandle= 0;
+
+  DBUG_RETURN(rc); 
+}
+
+
+
+int ha_ibmdb2i::index_read(uchar * buf, const uchar * key,
+                           uint key_len,
+                           enum ha_rkey_function find_flag)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_read");
+
+  if (unlikely(last_index_init_rc)) DBUG_RETURN(last_index_init_rc);
+
+  int rc;
+  
+  ha_rows estimatedRows = getIndexReadEstimate(active_index);
+  rc = prepReadBuffer(estimatedRows, db2Table->indexFile(active_index), readAccessIntent);  
+  if (unlikely(rc)) DBUG_RETURN(rc);
+  
+  DBUG_ASSERT(activeReadBuf);
+  
+  keyBuf.allocBuf(activeReadBuf->getRowLength(), 
+                  activeReadBuf->getRowNullOffset(), 
+                  activeReadBuf->getRowLength());
+  keyBuf.zeroBuf();
+  
+  char* db2KeyBufPtr = keyBuf.ptr();
+  char* nullKeyMap = db2KeyBufPtr + activeReadBuf->getRowNullOffset();
+  
+  const uchar* keyBegin = key;
+  int partsInUse;
+  
+  KEY& curKey = table->key_info[active_index];
+  
+  for (partsInUse = 0; partsInUse < curKey.key_parts, key - keyBegin < key_len; ++partsInUse)
+  {
+    Field* field = curKey.key_part[partsInUse].field;     
+    if ((curKey.key_part[partsInUse].null_bit) &&
+        (char*)key[0])
+    {
+      if (field->flags & AUTO_INCREMENT_FLAG)
+      {
+        table->status = STATUS_NOT_FOUND; 
+        DBUG_RETURN(HA_ERR_END_OF_FILE);
+      }
+      else
+      {
+        nullKeyMap[partsInUse] = __NULL_VALUE_EBCDIC;
+      }
+    }
+    else
+    {
+      nullKeyMap[partsInUse] = __NOT_NULL_VALUE_EBCDIC;
+      convertMySQLtoDB2(field, 
+                        db2Table->db2Field(field->field_index),
+                        db2KeyBufPtr, 
+                        (uchar*)key+((curKey.key_part[partsInUse].null_bit)? 1 : 0) ); // + (curKey.key_parts+7) / 8);
+    }
+   
+    db2KeyBufPtr += db2Table->db2Field(field->field_index).getByteLengthInRecord();
+    key += curKey.key_part[partsInUse].store_length;
+  }
+  
+  keyLen = db2KeyBufPtr - (char*)keyBuf.ptr();
+  
+  DBUG_PRINT("ha_ibmdb2i::index_read", ("find_flag: %d", find_flag));
+
+  char readDirection = QMY_NEXT;
+    
+  switch (find_flag)
+  {
+    case HA_READ_AFTER_KEY:
+      doInitialRead(QMY_AFTER_EQUAL, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      break;
+    case HA_READ_BEFORE_KEY:
+      doInitialRead(QMY_BEFORE_EQUAL, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      break;
+    case HA_READ_KEY_OR_NEXT:
+      doInitialRead(QMY_AFTER_OR_EQUAL, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      break;
+    case HA_READ_KEY_OR_PREV:
+      DBUG_ASSERT(0); // This function is unused      
+      doInitialRead(QMY_BEFORE_OR_EQUAL, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      break;
+    case HA_READ_PREFIX_LAST_OR_PREV:
+      doInitialRead(QMY_LAST_PREVIOUS, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      readDirection = QMY_PREVIOUS;
+      break; 
+    case HA_READ_PREFIX_LAST:
+      doInitialRead(QMY_PREFIX_LAST, estimatedRows,
+                    keyBuf.ptr(), keyLen, partsInUse);
+      readDirection = QMY_PREVIOUS;
+      break; 
+    case HA_READ_KEY_EXACT:
+      doInitialRead(QMY_EQUAL, estimatedRows, keyBuf.ptr(), keyLen, partsInUse);
+      break;
+    default: 
+        DBUG_ASSERT(0);
+        return HA_ERR_GENERIC;
+      break;
+  }
+  
+  ha_statistic_increment(&SSV::ha_read_key_count);
+  rc = readFromBuffer(buf, readDirection);
+  
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::index_next(uchar * buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_next");
+  ha_statistic_increment(&SSV::ha_read_next_count);
+  
+  int rc = readFromBuffer(buf, QMY_NEXT);
+  
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::index_next_same(uchar *buf, const uchar *key, uint keylen)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_next_same");
+  ha_statistic_increment(&SSV::ha_read_next_count);
+  
+  int rc = readFromBuffer(buf, QMY_NEXT_EQUAL);
+  
+  if (rc == HA_ERR_KEY_NOT_FOUND)
+  {
+    rc = HA_ERR_END_OF_FILE;
+  }
+
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+int ha_ibmdb2i::index_read_last(uchar * buf, const uchar * key, uint key_len)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_read_last");
+  DBUG_RETURN(index_read(buf, key, key_len, HA_READ_PREFIX_LAST));  
+}
+
+
+
+int ha_ibmdb2i::index_prev(uchar * buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_prev");
+  ha_statistic_increment(&SSV::ha_read_prev_count);
+  
+  int rc = readFromBuffer(buf, QMY_PREVIOUS);
+
+  table->status= (rc ? STATUS_NOT_FOUND: 0);  
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::index_first(uchar * buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_first");
+
+  if (unlikely(last_index_init_rc)) DBUG_RETURN(last_index_init_rc);
+    
+  int rc = prepReadBuffer(DEFAULT_MAX_ROWS_TO_BUFFER, 
+                          db2Table->indexFile(active_index), 
+                          readAccessIntent);
+  
+  if (rc == 0)
+  {
+    doInitialRead(QMY_FIRST, DEFAULT_MAX_ROWS_TO_BUFFER);
+    ha_statistic_increment(&SSV::ha_read_first_count);
+    rc = readFromBuffer(buf, QMY_NEXT);
+  }
+  
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::index_last(uchar * buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::index_last");
+  
+  if (unlikely(last_index_init_rc)) DBUG_RETURN(last_index_init_rc);
+  
+  int rc = prepReadBuffer(DEFAULT_MAX_ROWS_TO_BUFFER, 
+                          db2Table->indexFile(active_index), 
+                          readAccessIntent);
+  
+  if (rc == 0)
+  {
+    doInitialRead(QMY_LAST, DEFAULT_MAX_ROWS_TO_BUFFER);
+    ha_statistic_increment(&SSV::ha_read_last_count);
+    rc = readFromBuffer(buf, QMY_PREVIOUS);
+  }
+  
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::rnd_init(bool scan)
+{
+  DBUG_ENTER("ha_ibmdb2i::rnd_init");
+
+  int& rc = last_rnd_init_rc;
+  rc = 0;
+      
+  tweakReadSet();
+  invalidDataFound=false;
+  
+  uint32 rowsToBlockOnRead;
+
+  if (!scan)
+  { 
+    rowsToBlockOnRead = 1;
+  }
+  else
+  {
+    rowsToBlockOnRead = DEFAULT_MAX_ROWS_TO_BUFFER;
+  }
+  
+  rc = useDataFile(); 
+  
+  if (!rc)
+  {
+//     THD* thd = ha_thd();
+//     if (accessIntent == QMY_UPDATABLE &&
+//         thd_tx_isolation(thd) == ISO_REPEATABLE_READ &&
+//         !THDVAR(thd, transaction_unsafe))
+//     {
+//       readAccessIntent = QMY_READ_ONLY;
+//     }
+//     else
+//     {
+      readAccessIntent = accessIntent;
+//     }
+
+    rc = prepReadBuffer(rowsToBlockOnRead, db2Table->dataFile(), readAccessIntent);
+
+    if (!rc && accessIntent != QMY_READ_ONLY)
+      rc = prepWriteBuffer(1, db2Table->dataFile());
+
+    if (!rc && scan)
+      doInitialRead(QMY_FIRST, rowsToBlockOnRead);
+    
+    if (rc)
+      releaseDataFile();
+  }
+  
+  rrnAssocHandle= 0;
+
+  DBUG_RETURN(0); // MySQL sometimes does not check the return code, causing 
+                  // an assert in ha_rnd_end later on if we return a non-zero
+                  // value here. 
+}
+
+int ha_ibmdb2i::rnd_end()
+{
+  DBUG_ENTER("ha_ibmdb2i::rnd_end");
+  
+  warnIfInvalidData();
+  if (likely(activeReadBuf))
+    activeReadBuf->endRead();
+  if (last_rnd_init_rc == 0)
+    releaseActiveHandle();
+  last_rnd_init_rc = 0;
+  DBUG_RETURN(0);
+}
+
+
+int32 ha_ibmdb2i::mungeDB2row(uchar* record, const char* dataPtr, const char* nullMapPtr, bool skipLOBs)
+{
+  DBUG_ASSERT(dataPtr);
+  
+  my_bitmap_map *old_write_map= dbug_tmp_use_all_columns(table, table->write_set);
+  my_bitmap_map *old_read_map;
+  
+  if (unlikely(readAllColumns))
+    old_read_map = tmp_use_all_columns(table, table->read_set);
+
+  resetCharacterConversionBuffers();
+  
+  my_ptrdiff_t old_ptr= (my_ptrdiff_t) (record - table->record[0]); 
+  int fieldIndex = 0;
+  for (Field **field = table->field; *field; ++field, ++fieldIndex)
+  {  
+    if (unlikely(old_ptr))   
+      (*field)->move_field_offset(old_ptr);
+    if (nullMapPtr[fieldIndex] == __NULL_VALUE_EBCDIC ||
+        (!bitmap_is_set(table->read_set, fieldIndex)) ||
+        (skipLOBs && db2Table->db2Field(fieldIndex).isBlob()))
+    {
+      (*field)->set_null();
+    }
+    else
+    {
+      (*field)->set_notnull();
+      convertDB2toMySQL(db2Table->db2Field(fieldIndex), *field, dataPtr);
+    }
+    if (unlikely(old_ptr))
+      (*field)->move_field_offset(-old_ptr);
+    
+  }
+    
+  if (unlikely(readAllColumns))
+    tmp_restore_column_map(table->read_set, old_read_map);
+  dbug_tmp_restore_column_map(table->write_set, old_write_map);
+  
+  return 0;
+}
+
+
+int ha_ibmdb2i::rnd_next(uchar *buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::rnd_next");
+
+  if (unlikely(last_rnd_init_rc)) DBUG_RETURN(last_rnd_init_rc);
+  ha_statistic_increment(&SSV::ha_read_rnd_next_count);
+  
+  int rc;      
+  
+  rc = readFromBuffer(buf, QMY_NEXT);
+    
+  table->status= (rc ? STATUS_NOT_FOUND: 0);
+  DBUG_RETURN(rc);
+}
+
+
+void ha_ibmdb2i::position(const uchar *record)
+{
+  DBUG_ENTER("ha_ibmdb2i::position");
+  my_store_ptr(ref, ref_length, currentRRN);
+  DBUG_VOID_RETURN;
+}
+
+
+int ha_ibmdb2i::rnd_pos(uchar * buf, uchar *pos)
+{
+  DBUG_ENTER("ha_ibmdb2i::rnd_pos");
+  if (unlikely(last_rnd_init_rc)) DBUG_RETURN( last_rnd_init_rc);
+  ha_statistic_increment(&SSV::ha_read_rnd_count);
+
+  currentRRN = my_get_ptr(pos, ref_length);
+
+  tweakReadSet();  
+  
+  int rc = 0;
+
+  if (rrnAssocHandle &&
+      (activeHandle != rrnAssocHandle))
+  {
+    if (activeHandle) releaseActiveHandle();
+    rc = useFileByHandle(QMY_UPDATABLE, rrnAssocHandle);    
+  }
+  
+  if (likely(rc == 0))
+  {
+    rc = prepReadBuffer(1, getFileForActiveHandle(), accessIntent);
+
+    if (likely(rc == 0) && accessIntent == QMY_UPDATABLE)
+      rc = prepWriteBuffer(1, getFileForActiveHandle());
+
+    if (likely(rc == 0))
+    {
+      rc = db2i_ileBridge::getBridgeForThread()->readByRRN(activeHandle, 
+                                                         activeReadBuf->ptr(),
+                                                         currentRRN,
+                                                         accessIntent,
+                                                         getCommitLevel());
+
+      if (likely(rc == 0))
+      {
+        rrnAssocHandle = activeHandle;
+        const char* readBuf = activeReadBuf->getRowN(0);
+        rc = mungeDB2row(buf, readBuf, readBuf + activeReadBuf->getRowNullOffset(), false);
+        releaseRowNeeded = TRUE;
+      }
+    }    
+  }
+  
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::info(uint flag)
+{
+  DBUG_ENTER("ha_ibmdb2i::info");
+
+  uint16 infoRequested = 0;
+  ValidatedPointer<char> rowKeySpcPtr;  // Space pointer passed to DB2
+  uint32 rowKeySpcLen;                  // Length of space passed to DB2
+  THD* thd = ha_thd();
+  int command = thd_sql_command(thd);
+  
+  if (flag & HA_STATUS_AUTO)
+    stats.auto_increment_value = (ulonglong) 0;
+
+  if (flag & HA_STATUS_ERRKEY)
+  {
+    errkey = lastDupKeyID;
+    my_store_ptr(dup_ref, ref_length, lastDupKeyRRN);
+  }
+  
+  if (flag & HA_STATUS_TIME)
+  {
+    if ((flag & HA_STATUS_NO_LOCK) && 
+        ibmdb2i_assume_exclusive_use &&
+        share &&
+        (share->cachedStats.isInited(lastModTime)))
+      stats.update_time = share->cachedStats.getUpdateTime();
+    else
+      infoRequested |= lastModTime;
+  }
+  
+  if (flag & HA_STATUS_CONST)
+  {
+    stats.block_size=4096;
+    infoRequested |= createTime;
+    
+    if (table->s->keys)
+    {
+      infoRequested |= rowsPerKey;
+      rowKeySpcLen = (table->s->keys) * MAX_DB2_KEY_PARTS * sizeof(uint64);
+      rowKeySpcPtr.alloc(rowKeySpcLen);
+      memset(rowKeySpcPtr, 0, rowKeySpcLen);               // Clear the allocated space
+    }
+  }
+  
+  if (flag & HA_STATUS_VARIABLE)
+  {
+    if ((flag & HA_STATUS_NO_LOCK) &&
+        (command != SQLCOM_SHOW_TABLE_STATUS) &&
+        ibmdb2i_assume_exclusive_use &&
+        share &&
+        (share->cachedStats.isInited(rowCount | deletedRowCount | meanRowLen | ioCount)) &&
+        (share->cachedStats.getRowCount() >= 2))
+    {
+      stats.records = share->cachedStats.getRowCount();
+      stats.deleted = share->cachedStats.getDelRowCount();
+      stats.mean_rec_length = share->cachedStats.getMeanLength();
+      stats.data_file_length = share->cachedStats.getAugmentedDataLength();
+    }
+    else
+    {
+      infoRequested |= rowCount | deletedRowCount | meanRowLen;            
+      if (command == SQLCOM_SHOW_TABLE_STATUS)
+        infoRequested |= objLength;
+      else
+        infoRequested |= ioCount;
+    }
+  }
+
+  int rc = 0;
+          
+  if (infoRequested)
+  {
+    DBUG_PRINT("ha_ibmdb2i::info",("Retrieving fresh stats %d", flag));
+
+    initBridge(thd);
+    rc = bridge()->retrieveTableInfo((dataHandle  ? dataHandle : db2Table->dataFile()->getMasterDefnHandle()),
+                                     infoRequested,
+                                     stats,
+                                     rowKeySpcPtr);
+    
+    if (!rc)
+    {
+      if ((flag & HA_STATUS_VARIABLE) &&
+          (command != SQLCOM_SHOW_TABLE_STATUS))
+        stats.data_file_length = stats.data_file_length * IO_SIZE;
+
+      if ((ibmdb2i_assume_exclusive_use) &&
+          (share) && 
+          (command != SQLCOM_SHOW_TABLE_STATUS))
+      {
+        if (flag & HA_STATUS_VARIABLE) 
+        {
+          share->cachedStats.cacheRowCount(stats.records);
+          share->cachedStats.cacheDelRowCount(stats.deleted);
+          share->cachedStats.cacheMeanLength(stats.mean_rec_length);
+          share->cachedStats.cacheAugmentedDataLength(stats.data_file_length);
+        }
+
+        if (flag & HA_STATUS_TIME)
+        {
+          share->cachedStats.cacheUpdateTime(stats.update_time);
+        }
+      }
+
+      if (flag & HA_STATUS_CONST)
+      {
+        ulong i;                 // Loop counter for indexes
+        ulong j;                 // Loop counter for key parts
+        RowKey* rowKeyPtr;       // Pointer to 'number of unique rows' array for this index
+
+        rowKeyPtr = (RowKey_t*)(void*)rowKeySpcPtr;    // Address first array of DB2 row counts
+        for (i = 0; i < table->s->keys; i++)           // Do for each index, including primary
+        {
+          for (j = 0; j < table->key_info[i].key_parts; j++)   
+          {
+            table->key_info[i].rec_per_key[j]= rowKeyPtr->RowKeyArray[j];
+          }
+          rowKeyPtr = rowKeyPtr + 1;                   // Address next array of DB2 row counts 
+        }
+      }
+    }
+    else if (rc == HA_ERR_LOCK_WAIT_TIMEOUT && share)
+    {
+      // If we couldn't retrieve the info because the object was locked,
+      // we'll do our best by returning the most recently cached data.
+      if ((infoRequested & rowCount) &&
+          share->cachedStats.isInited(rowCount))
+        stats.records = share->cachedStats.getRowCount();
+      if ((infoRequested & deletedRowCount) &&
+          share->cachedStats.isInited(deletedRowCount))
+        stats.deleted = share->cachedStats.getDelRowCount();
+      if ((infoRequested & meanRowLen) &&
+          share->cachedStats.isInited(meanRowLen))
+        stats.mean_rec_length = share->cachedStats.getMeanLength();
+      if ((infoRequested & lastModTime) &&
+          share->cachedStats.isInited(lastModTime))
+        stats.update_time = share->cachedStats.getUpdateTime();
+      
+      rc = 0;
+    }
+  }
+
+  DBUG_RETURN(rc);
+}
+
+
+ha_rows ha_ibmdb2i::records()
+{
+  DBUG_ENTER("ha_ibmdb2i::records");
+  int rc;
+  rc = bridge()->retrieveTableInfo((dataHandle ? dataHandle : db2Table->dataFile()->getMasterDefnHandle()),
+                                                             rowCount,
+                                                             stats);
+
+  if (unlikely(rc))
+  {
+    if (rc == HA_ERR_LOCK_WAIT_TIMEOUT && 
+        share && 
+        (share->cachedStats.isInited(rowCount)))
+      DBUG_RETURN(share->cachedStats.getRowCount());
+    else
+      DBUG_RETURN(HA_POS_ERROR);
+  }
+  else if (share)
+  {
+    share->cachedStats.cacheRowCount(stats.records);
+  }
+
+ DBUG_RETURN(stats.records); 
+}
+
+
+int ha_ibmdb2i::extra(enum ha_extra_function operation)
+{
+  DBUG_ENTER("ha_ibmdb2i::extra");
+  
+  switch(operation)
+  {
+    // Can these first five flags be replaced by attending to HA_EXTRA_WRITE_CACHE?
+    case HA_EXTRA_NO_IGNORE_DUP_KEY: 
+    case HA_EXTRA_WRITE_CANNOT_REPLACE: 
+      {                                                
+        returnDupKeysImmediately = false;
+        onDupUpdate = false;                         
+      }                                              
+      break;
+    case HA_EXTRA_INSERT_WITH_UPDATE:                
+      {                                              
+        returnDupKeysImmediately = true;             
+        onDupUpdate = true;                          
+      }                                               
+      break;                            
+    case HA_EXTRA_IGNORE_DUP_KEY:  
+    case HA_EXTRA_WRITE_CAN_REPLACE: 
+      returnDupKeysImmediately = true;
+      break;
+    case HA_EXTRA_FLUSH_CACHE:
+      if (outstanding_start_bulk_insert)
+        finishBulkInsert();
+      break;
+  }
+
+  
+  DBUG_RETURN(0);
+}
+
+/** 
+  @brief  
+  The DB2 storage engine will ignore a MySQL generated value and will generate 
+  a new value in SLIC. We arbitrarily set first_value to 1, and set the
+  interval to infinity for better performance on multi-row inserts.
+*/
+void ha_ibmdb2i::get_auto_increment(ulonglong offset, ulonglong increment,
+                                  ulonglong nb_desired_values,
+                                  ulonglong *first_value,
+                                  ulonglong *nb_reserved_values)
+{
+  DBUG_ENTER("ha_ibmdb2i::get_auto_increment");
+  *first_value= 1;
+  *nb_reserved_values= ULONGLONG_MAX;
+} 
+
+
+
+void ha_ibmdb2i::update_create_info(HA_CREATE_INFO *create_info)
+{
+  DBUG_ENTER("ha_ibmdb2i::update_create_info");
+
+  if ((!(create_info->used_fields & HA_CREATE_USED_AUTO)) &&
+      (table->found_next_number_field != NULL))
+  {
+    initBridge();
+    
+    create_info->auto_increment_value= 1; 
+
+    ha_rows rowCount = records();
+    
+    if (rowCount == 0)
+    { 
+      create_info->auto_increment_value = db2Table->getStartId();
+      DBUG_VOID_RETURN;
+    }
+    else if (rowCount == HA_POS_ERROR)
+    { 
+      DBUG_VOID_RETURN;
+    }
+
+    getNextIdVal(&create_info->auto_increment_value); 
+  }
+  DBUG_VOID_RETURN;
+}
+
+
+int ha_ibmdb2i::getNextIdVal(ulonglong *value)
+{
+  DBUG_ENTER("ha_ibmdb2i::getNextIdVal");
+  
+  char queryBuffer[MAX_DB2_COLNAME_LENGTH + MAX_DB2_QUALIFIEDNAME_LENGTH + 64];
+  strcpy(queryBuffer, " SELECT CAST(MAX( ");
+  convertMySQLNameToDB2Name(table->found_next_number_field->field_name, 
+                            strend(queryBuffer), 
+                            MAX_DB2_COLNAME_LENGTH+1);
+  strcat(queryBuffer, ") AS BIGINT) FROM ");    
+  db2Table->getDB2QualifiedName(strend(queryBuffer));
+  DBUG_ASSERT(strlen(queryBuffer) < sizeof(queryBuffer));
+  
+  SqlStatementStream sqlStream(queryBuffer);
+  DBUG_PRINT("ha_ibmdb2i::getNextIdVal", ("Sent to DB2: %s",queryBuffer));
+
+  int rc = 0;
+  FILE_HANDLE fileHandle2;
+  uint32 db2RowDataLen2;
+  rc = bridge()->prepOpen(sqlStream.getPtrToData(),
+                          &fileHandle2,
+                          &db2RowDataLen2);
+  if (likely(rc == 0))
+  {
+    IOReadBuffer rowBuffer(1, db2RowDataLen2);
+    rc = bridge()->read(fileHandle2, 
+                        rowBuffer.ptr(),
+                        QMY_READ_ONLY,
+                        QMY_NONE,
+                        QMY_FIRST);
+    
+    if (likely(rc == 0))
+    {
+      /* This check is here for the case where the table is not empty,
+         but the auto_increment starting value has been changed since     
+         the last record was written.                                */
+
+      longlong maxIdVal = *(longlong*)(rowBuffer.getRowN(0));
+      if ((maxIdVal + 1) > db2Table->getStartId())
+        *value = maxIdVal + 1; 
+      else
+        *value = db2Table->getStartId();
+    }
+    
+    bridge()->deallocateFile(fileHandle2);
+  }
+  DBUG_RETURN(rc);
+}
+
+
+/*
+  Updates index cardinalities.                                             
+*/
+int ha_ibmdb2i::analyze(THD* thd, HA_CHECK_OPT *check_opt)
+{
+  DBUG_ENTER("ha_ibmdb2i::analyze");
+  info(HA_STATUS_TIME | HA_STATUS_CONST | HA_STATUS_VARIABLE);
+  DBUG_RETURN(0);
+}
+
+int ha_ibmdb2i::optimize(THD* thd, HA_CHECK_OPT *check_opt)
+{
+  DBUG_ENTER("ha_ibmdb2i::optimize");
+
+  initBridge(thd);
+  
+  if (unlikely(records() == 0))
+    DBUG_RETURN(0); // DB2 doesn't like to reorganize a table with no data.
+  
+  quiesceAllFileHandles();
+  
+  int32 rc = bridge()->optimizeTable(db2Table->dataFile()->getMasterDefnHandle());
+  info(HA_STATUS_TIME | HA_STATUS_CONST | HA_STATUS_VARIABLE);
+  
+  DBUG_RETURN(rc);
+}
+
+
+/**
+  @brief
+  Determines if an ALTER TABLE is allowed to switch the storage engine
+  for this table. If the table has a foreign key or is referenced by a
+  foreign key, then it cannot be switched. 
+*/
+bool ha_ibmdb2i::can_switch_engines(void)
+/*=================================*/
+{
+  DBUG_ENTER("ha_ibmdb2i::can_switch_engines");
+
+  int rc = 0;
+  FILE_HANDLE queryFile = 0;
+  uint32 resultRowLen;  
+  uint count = 0; 
+  bool can_switch = FALSE;   // 1 if changing storage engine is allowed
+  
+  const char* libName = db2Table->getDB2LibName(db2i_table::ASCII_SQL);
+  const char* fileName = db2Table->getDB2TableName(db2i_table::ASCII_SQL);
+  
+  String query(256);
+  query.append(STRING_WITH_LEN(" SELECT COUNT(*) FROM SYSIBM.SQLFOREIGNKEYS WHERE ((PKTABLE_SCHEM = '"));
+  query.append(libName+1, strlen(libName)-2);            // Remove quotes from parent schema name
+  query.append(STRING_WITH_LEN("' AND PKTABLE_NAME = '"));                   
+  query.append(fileName+1,strlen(fileName)-2);           // Remove quotes from file name
+  query.append(STRING_WITH_LEN("') OR (FKTABLE_SCHEM = '"));                                              
+  query.append(libName+1,strlen(libName)-2);             // Remove quotes from child schema
+  query.append(STRING_WITH_LEN("' AND FKTABLE_NAME = '"));          
+  query.append(fileName+1,strlen(fileName)-2);           // Remove quotes from child name 
+  query.append(STRING_WITH_LEN("'))"));
+                                               
+  SqlStatementStream sqlStream(query);
+  
+  rc = bridge()->prepOpen(sqlStream.getPtrToData(),
+                        &queryFile,
+                        &resultRowLen);
+  if (rc == 0)
+  {
+    IOReadBuffer rowBuffer(1, resultRowLen);
+
+    rc =   bridge()->read(queryFile, 
+                        rowBuffer.ptr(),
+                        QMY_READ_ONLY, 
+                        QMY_NONE,
+                        QMY_FIRST);
+    if (!rc)
+    {
+       count = *(uint*)(rowBuffer.getRowN(0));
+       if (count == 0)
+         can_switch = TRUE;
+    }
+
+    bridge()->deallocateFile(queryFile);
+  }
+  DBUG_RETURN(can_switch);
+}
+
+
+
+bool ha_ibmdb2i::check_if_incompatible_data(HA_CREATE_INFO *info,
+                                         uint table_changes)
+{
+  DBUG_ENTER("ha_ibmdb2i::check_if_incompatible_data");
+  uint i;
+  /* Check that auto_increment value and field definitions were
+     not changed. */
+  if ((info->used_fields & HA_CREATE_USED_AUTO &&
+       info->auto_increment_value != 0) ||
+       table_changes != IS_EQUAL_YES)
+    DBUG_RETURN(COMPATIBLE_DATA_NO);
+  /* Check if any fields were renamed. */
+  for (i= 0; i < table->s->fields; i++)
+  {
+   Field *field= table->field[i];
+   if (field->flags & FIELD_IS_RENAMED)
+    {
+      DBUG_PRINT("info", ("Field has been renamed, copy table"));
+      DBUG_RETURN(COMPATIBLE_DATA_NO);
+    }
+  }
+  DBUG_RETURN(COMPATIBLE_DATA_YES);
+}
+
+int ha_ibmdb2i::reset_auto_increment(ulonglong value)
+ {
+  DBUG_ENTER("ha_ibmdb2i::reset_auto_increment");
+  
+  int rc = 0;
+
+  quiesceAllFileHandles();
+
+  const char* libName = db2Table->getDB2LibName(db2i_table::ASCII_SQL);
+  const char* fileName = db2Table->getDB2TableName(db2i_table::ASCII_SQL);
+
+  String query(512);
+  query.append(STRING_WITH_LEN(" ALTER TABLE "));
+  query.append(libName);
+  query.append('.');
+  query.append(fileName);
+  query.append(STRING_WITH_LEN(" ALTER COLUMN "));
+  char colName[MAX_DB2_COLNAME_LENGTH+1];
+  convertMySQLNameToDB2Name(table->found_next_number_field->field_name, 
+                            colName, 
+                            sizeof(colName));
+  query.append(colName);
+  
+  char restart_value[22];  
+  CHARSET_INFO *cs= &my_charset_bin;
+  uint len = (uint)(cs->cset->longlong10_to_str)(cs,restart_value,sizeof(restart_value), 10, value);  
+  restart_value[len] = 0;
+  
+  query.append(STRING_WITH_LEN(" RESTART WITH "));
+  query.append(restart_value);
+  
+  SqlStatementStream sqlStream(query);
+  DBUG_PRINT("ha_ibmdb2i::reset_auto_increment", ("Sent to DB2: %s",query.c_ptr()));
+
+  rc = db2i_ileBridge::getBridgeForThread()->execSQL(sqlStream.getPtrToData(),
+                                                     sqlStream.getStatementCount(),
+                                                     QMY_NONE, //getCommitLevel(),
+                                                     FALSE,
+                                                     FALSE,
+                                                     TRUE, //FALSE,
+                                                     dataHandle);
+  if (rc == 0)
+    db2Table->updateStartId(value); 
+
+  DBUG_RETURN(rc);
+}
+
+
+/**
+  @brief
+  This function receives an error code that was previously set by the handler.
+  It returns to MySQL the error string associated with that error.   
+*/
+bool ha_ibmdb2i::get_error_message(int error, String *buf)
+{
+  DBUG_ENTER("ha_ibmdb2i::get_error_message");
+  if ((error >= DB2I_FIRST_ERR && error <= DB2I_LAST_ERR) ||
+      (error >= QMY_ERR_MIN && error <= QMY_ERR_MAX))
+  {
+    db2i_ileBridge* bridge = db2i_ileBridge::getBridgeForThread(ha_thd());
+    char* errMsg = bridge->getErrorStorage();
+    buf->copy(errMsg, strlen(errMsg),system_charset_info);
+    bridge->freeErrorStorage();
+  }
+  DBUG_RETURN(FALSE);                          
+}
+
+
+int ha_ibmdb2i::delete_all_rows()
+{
+  DBUG_ENTER("ha_ibmdb2i::delete_all_rows");
+  int rc = 0;
+  char queryBuffer[MAX_DB2_QUALIFIEDNAME_LENGTH + 64];
+  strcpy(queryBuffer, " DELETE FROM ");
+  db2Table->getDB2QualifiedName(strend(queryBuffer));
+  DBUG_ASSERT(strlen(queryBuffer) < sizeof(queryBuffer));
+  
+  SqlStatementStream sqlStream(queryBuffer);
+  DBUG_PRINT("ha_ibmdb2i::delete_all_rows", ("Sent to DB2: %s",queryBuffer));
+  rc = bridge()->execSQL(sqlStream.getPtrToData(),
+                         sqlStream.getStatementCount(),
+                         getCommitLevel(),
+                         false,
+                         false,
+                         true,
+                         dataHandle);
+  
+ /* If this method was called on behalf of a TRUNCATE TABLE statement, and if */
+ /* the table has an auto_increment field, then reset the starting value for  */
+ /* the auto_increment field to 1.
+                                            */
+  if (rc == 0 && thd_sql_command(ha_thd()) == SQLCOM_TRUNCATE &&
+      table->found_next_number_field )
+    rc = reset_auto_increment(1);
+
+  invalidateCachedStats();
+  
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::external_lock(THD *thd, int lock_type)
+{
+  int rc = 0;
+
+  DBUG_ENTER("ha_ibmdb2i::external_lock");
+  DBUG_PRINT("ha_ibmdb2i::external_lock",("Lock type: %d", lock_type));
+  
+  if (lock_type == F_RDLCK)
+    accessIntent = QMY_READ_ONLY;
+  else if (lock_type == F_WRLCK)
+    accessIntent = QMY_UPDATABLE;
+  
+  initBridge(thd);
+  int command = thd_sql_command(thd);
+  
+  if (!THDVAR(thd,transaction_unsafe))
+  {
+    if (lock_type != F_UNLCK)
+    {
+      if (autoCommitIsOn(thd) == QMY_YES)
+      {
+        trans_register_ha(thd, FALSE, ibmdb2i_hton);
+      }
+      else 
+      { 
+        trans_register_ha(thd, TRUE, ibmdb2i_hton);
+        if (likely(command != SQLCOM_CREATE_TABLE))
+        {
+          trans_register_ha(thd, FALSE, ibmdb2i_hton);
+          bridge()->beginStmtTx();
+        }
+      }
+    }    
+  }
+
+  if (command == SQLCOM_LOCK_TABLES ||
+      command == SQLCOM_ALTER_TABLE ||
+      command == SQLCOM_UNLOCK_TABLES ||
+      (accessIntent == QMY_UPDATABLE &&
+       (command == SQLCOM_UPDATE ||
+        command == SQLCOM_UPDATE_MULTI ||
+        command == SQLCOM_DELETE ||
+        command == SQLCOM_DELETE_MULTI ||
+        command == SQLCOM_REPLACE ||
+        command == SQLCOM_REPLACE_SELECT) &&
+       getCommitLevel(thd) == QMY_NONE))
+  {
+    char action;
+    char type;
+    if (lock_type == F_UNLCK)
+    { 
+      action = QMY_UNLOCK;
+      type = accessIntent == QMY_READ_ONLY ? QMY_LSRD : QMY_LENR;
+    }
+    else
+    {
+      action = QMY_LOCK;
+      type = lock_type == F_RDLCK ? QMY_LSRD : QMY_LENR;
+    }
+
+    DBUG_PRINT("ha_ibmdb2i::external_lock",("%socking table", action==QMY_LOCK ? "L" : "Unl"));
+
+    if (!dataHandle)
+      rc = db2Table->dataFile()->allocateNewInstance(&dataHandle, curConnection);  
+
+    rc = bridge()->lockObj(dataHandle, 
+                           0,
+                           action,               
+                           type,
+                           (command == SQLCOM_LOCK_TABLES ? QMY_NO : QMY_YES)); 
+    
+  } 
+  
+  // Cache this away so we don't have to access it on each row operation
+  cachedZeroDateOption = (enum_ZeroDate)THDVAR(thd, compat_opt_allow_zero_date_vals);
+  
+  DBUG_RETURN(rc);
+}
+
+
+THR_LOCK_DATA **ha_ibmdb2i::store_lock(THD *thd,
+                                       THR_LOCK_DATA **to,
+                                       enum thr_lock_type lock_type)
+{
+  if (lock_type != TL_IGNORE && lock.type == TL_UNLOCK)
+  {
+    if ((lock_type >= TL_WRITE_CONCURRENT_INSERT &&
+         lock_type <= TL_WRITE) && !(thd->in_lock_tables && thd_sql_command(thd) == SQLCOM_LOCK_TABLES))
+      lock_type= TL_WRITE_ALLOW_WRITE;
+    lock.type=lock_type;
+  }
+  *to++= &lock;
+  return to;
+}
+
+
+int ha_ibmdb2i::delete_table(const char *name)
+{
+  DBUG_ENTER("ha_ibmdb2i::delete_table");
+  THD* thd = ha_thd();
+  db2i_ileBridge* bridge = db2i_ileBridge::getBridgeForThread(thd);  
+  
+  char db2Name[MAX_DB2_QUALIFIEDNAME_LENGTH];
+  db2i_table::getDB2QualifiedNameFromPath(name, db2Name);
+
+  String query(128);
+  query.append(STRING_WITH_LEN(" DROP TABLE "));
+  query.append(db2Name);
+
+  if (thd_sql_command(thd) == SQLCOM_DROP_TABLE &&
+      thd->lex->drop_mode == DROP_RESTRICT)
+    query.append(STRING_WITH_LEN(" RESTRICT "));  
+  DBUG_PRINT("ha_ibmdb2i::delete_table", ("Sent to DB2: %s",query.c_ptr()));
+
+  SqlStatementStream sqlStream(query);
+
+  db2i_table::getDB2LibNameFromPath(name, db2Name);  
+  bool isTemporary = (strcmp(db2Name, DB2I_TEMP_TABLE_SCHEMA) == 0 ? TRUE : FALSE);
+
+  int rc = bridge->execSQL(sqlStream.getPtrToData(),
+                       sqlStream.getStatementCount(),
+                       (isTemporary ? QMY_NONE : getCommitLevel(thd)),
+                       FALSE,
+                       FALSE,
+                       isTemporary);
+
+  if (rc == HA_ERR_NO_SUCH_TABLE)
+  {
+     warning(thd, DB2I_ERR_TABLE_NOT_FOUND, name);
+     rc = 0;
+  }
+  
+  if (rc == 0)
+  {
+    db2i_table::deleteAssocFiles(name);
+  }
+  
+  FILE_HANDLE savedHandle = bridge->findAndRemovePreservedHandle(name, &share);
+  while (savedHandle)
+  {
+    bridge->deallocateFile(savedHandle, TRUE);
+    DBUG_ASSERT(share);
+    if (free_share(share))
+      share = NULL;   
+    savedHandle = bridge->findAndRemovePreservedHandle(name, &share);
+  }
+    
+  my_errno = rc;
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::rename_table(const char * from, const char * to)
+{
+  DBUG_ENTER("ha_ibmdb2i::rename_table ");
+    
+  char db2FromFileName[MAX_DB2_FILENAME_LENGTH + 1];
+  char db2ToFileName[MAX_DB2_FILENAME_LENGTH+1];
+  char db2FromLibName[MAX_DB2_SCHEMANAME_LENGTH+1];
+  char db2ToLibName[MAX_DB2_SCHEMANAME_LENGTH+1];
+
+  db2i_table::getDB2LibNameFromPath(from, db2FromLibName);
+  db2i_table::getDB2LibNameFromPath(to, db2ToLibName);
+
+  if (strcmp(db2FromLibName, db2ToLibName) != 0 )
+  {
+    getErrTxt(DB2I_ERR_RENAME_MOVE,from,to);
+    DBUG_RETURN(DB2I_ERR_RENAME_MOVE);
+  }
+ 
+  db2i_table::getDB2FileNameFromPath(from, db2FromFileName, db2i_table::ASCII_NATIVE);
+  db2i_table::getDB2FileNameFromPath(to, db2ToFileName);
+
+  char escapedFromFileName[2 * MAX_DB2_FILENAME_LENGTH + 1];
+    
+  uint o = 0;
+  uint i = 1;
+  do
+  {
+    escapedFromFileName[o++] = db2FromFileName[i];
+    if (db2FromFileName[i] == '+')
+      escapedFromFileName[o++] = '+';
+  } while (db2FromFileName[++i]);
+  escapedFromFileName[o-1] = 0;
+
+  
+  int rc = 0;
+  
+  char queryBuffer[sizeof(db2FromLibName) + 2 * sizeof(db2FromFileName) + 256];
+  SafeString selectQuery(queryBuffer, sizeof(queryBuffer));
+  selectQuery.strncat(STRING_WITH_LEN("SELECT CAST(INDEX_NAME AS VARCHAR(128) CCSID 1208) FROM QSYS2.SYSINDEXES WHERE INDEX_NAME LIKE '%+_+_+_%"));
+  selectQuery.strcat(escapedFromFileName);
+  selectQuery.strncat(STRING_WITH_LEN("' ESCAPE '+' AND TABLE_NAME='"));
+  selectQuery.strncat(db2FromFileName+1, strlen(db2FromFileName)-2);
+  selectQuery.strncat(STRING_WITH_LEN("' AND TABLE_SCHEMA='"));
+  selectQuery.strncat(db2FromLibName+1, strlen(db2FromLibName)-2);
+  selectQuery.strcat('\'');
+  DBUG_ASSERT(!selectQuery.overflowed());
+  
+  SqlStatementStream indexQuery(selectQuery.ptr());
+
+  FILE_HANDLE queryFile = 0;
+  uint32 resultRowLen;
+    
+  initBridge();
+  rc = bridge()->prepOpen(indexQuery.getPtrToData(),
+                        &queryFile,
+                        &resultRowLen);
+
+  if (unlikely(rc))
+    DBUG_RETURN(rc);
+    
+  IOReadBuffer rowBuffer(1, resultRowLen);  
+     
+  int tableNameLen = strlen(db2FromFileName) - 2;
+  
+  SqlStatementStream renameQuery(64);
+  String query;
+  while (rc == 0)
+  {
+    query.length(0);
+
+    rc = bridge()->read(queryFile,
+                      rowBuffer.ptr(),
+                      QMY_READ_ONLY,
+                      QMY_NONE,
+                      QMY_NEXT);
+
+    if (!rc)
+    {
+      const char* rowData = rowBuffer.getRowN(0);
+      char indexFileName[MAX_DB2_FILENAME_LENGTH];
+      memset(indexFileName, 0, sizeof(indexFileName));
+      
+      uint16 fileNameLen = *(uint16*)(rowData);
+      strncpy(indexFileName, rowData + sizeof(uint16), fileNameLen);
+            
+      int bytesToRetain = fileNameLen - tableNameLen;
+      if (bytesToRetain <= 0)
+      /* We can't handle index names in which the MySQL index name and
+         the table name together are longer than the max index name.      */
+      {
+        getErrTxt(DB2I_ERR_INVALID_NAME,"index","*generated*");
+        DBUG_RETURN(DB2I_ERR_INVALID_NAME);     
+      }
+      char indexName[MAX_DB2_FILENAME_LENGTH];
+      memset(indexName, 0, sizeof(indexName));
+
+      strncpy(indexName, 
+              indexFileName, 
+              bytesToRetain);
+      
+      char db2IndexName[MAX_DB2_FILENAME_LENGTH+1];
+      
+      convertMySQLNameToDB2Name(indexFileName, db2IndexName, sizeof(db2IndexName));
+
+      query.append(STRING_WITH_LEN("RENAME INDEX "));
+      query.append(db2FromLibName);
+      query.append('.');
+      query.append(db2IndexName);
+      query.append(STRING_WITH_LEN(" TO "));
+      if (db2i_table::appendQualifiedIndexFileName(indexName, db2ToFileName, query, db2i_table::ASCII_SQL, typeNone) == -1)
+      {
+        getErrTxt(DB2I_ERR_INVALID_NAME,"index","*generated*");
+        DBUG_RETURN(DB2I_ERR_INVALID_NAME );
+      }
+      renameQuery.addStatement(query);      
+      DBUG_PRINT("ha_ibmdb2i::rename_table", ("Sent to DB2: %s",query.c_ptr_safe()));
+    }    
+  }
+
+    
+  if (queryFile)
+    bridge()->deallocateFile(queryFile);
+  
+  if (rc != HA_ERR_END_OF_FILE)
+    DBUG_RETURN(rc);
+  
+  char db2Name[MAX_DB2_QUALIFIEDNAME_LENGTH];
+          
+  /* Rename the table */
+  query.length(0);
+  query.append(STRING_WITH_LEN(" RENAME TABLE "));
+  db2i_table::getDB2QualifiedNameFromPath(from, db2Name);
+  query.append(db2Name);  
+  query.append(STRING_WITH_LEN(" TO "));
+  query.append(db2ToFileName);
+  DBUG_PRINT("ha_ibmdb2i::rename_table", ("Sent to DB2: %s",query.c_ptr_safe()));
+  renameQuery.addStatement(query);
+  rc = bridge()->execSQL(renameQuery.getPtrToData(),
+                       renameQuery.getStatementCount(),
+                       getCommitLevel());
+  
+  if (!rc)
+    db2i_table::renameAssocFiles(from, to);
+  
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::create(const char *name, TABLE *table_arg,
+                       HA_CREATE_INFO *create_info)
+{
+  DBUG_ENTER("ha_ibmdb2i::create");
+
+  int rc;
+  char fileSortSequence[11] = "*HEX";
+  char fileSortSequenceLibrary[11] = "";
+  char fileSortSequenceType = ' ';
+  char libName[MAX_DB2_SCHEMANAME_LENGTH+1];
+  char fileName[MAX_DB2_FILENAME_LENGTH+1];
+  char colName[MAX_DB2_COLNAME_LENGTH+1];
+  bool isTemporary;
+  ulong auto_inc_value;
+
+  db2i_table::getDB2LibNameFromPath(name, libName);
+  db2i_table::getDB2FileNameFromPath(name, fileName);
+
+  if (osVersion.v < 6)
+  {
+    if (strlen(libName) > 
+         MAX_DB2_V5R4_LIBNAME_LENGTH + (isOrdinaryIdentifier(libName) ? 2 : 0))
+    {
+      getErrTxt(DB2I_ERR_TOO_LONG_SCHEMA,libName, MAX_DB2_V5R4_LIBNAME_LENGTH);
+      DBUG_RETURN(DB2I_ERR_TOO_LONG_SCHEMA);
+    }
+  }
+  else if (strlen(libName) > MAX_DB2_V6R1_LIBNAME_LENGTH)
+  {
+    getErrTxt(DB2I_ERR_TOO_LONG_SCHEMA,libName, MAX_DB2_V6R1_LIBNAME_LENGTH);
+    DBUG_RETURN(DB2I_ERR_TOO_LONG_SCHEMA);
+  }
+  
+  String query(256);
+  
+  if (strcmp(libName, DB2I_TEMP_TABLE_SCHEMA))
+  {
+    query.append(STRING_WITH_LEN("CREATE TABLE "));
+    query.append(libName);
+    query.append('.');
+    query.append(fileName);
+    isTemporary = FALSE;
+  }
+  else
+  {
+    query.append(STRING_WITH_LEN("DECLARE GLOBAL TEMPORARY TABLE "));
+    query.append(fileName);
+    isTemporary = TRUE;
+  }
+  query.append(STRING_WITH_LEN(" ("));
+  
+  THD* thd = ha_thd();
+  enum_TimeFormat timeFormat = (enum_TimeFormat)(THDVAR(thd, compat_opt_time_as_duration));
+  enum_YearFormat yearFormat = (enum_YearFormat)(THDVAR(thd, compat_opt_year_as_int));
+  enum_BlobMapping blobMapping = (enum_BlobMapping)(THDVAR(thd, compat_opt_blob_cols));
+  enum_ZeroDate zeroDate = (enum_ZeroDate)(THDVAR(thd, compat_opt_allow_zero_date_vals));
+  bool propagateDefaults = THDVAR(thd, propagate_default_col_vals);
+  
+  Field **field;
+  for (field= table_arg->field; *field; field++)
+  {  
+    if ( field != table_arg->field ) // Not the first one
+      query.append(STRING_WITH_LEN(" , "));
+
+    if (!convertMySQLNameToDB2Name((*field)->field_name, colName, sizeof(colName)))
+    {
+      getErrTxt(DB2I_ERR_INVALID_NAME,"field",(*field)->field_name);
+      DBUG_RETURN(DB2I_ERR_INVALID_NAME );
+    }
+
+    query.append(colName);    
+    query.append(' ');
+
+    if (rc = getFieldTypeMapping(*field, 
+                                 query, 
+                                 timeFormat, 
+                                 blobMapping,
+                                 zeroDate,
+                                 propagateDefaults,
+                                 yearFormat))
+      DBUG_RETURN(rc);
+
+    if ( (*field)->flags & NOT_NULL_FLAG )
+    {
+      query.append(STRING_WITH_LEN(" NOT NULL "));
+    }
+    if ( (*field)->flags & AUTO_INCREMENT_FLAG )     
+    {
+#ifdef WITH_PARTITION_STORAGE_ENGINE      
+      if (table_arg->part_info)
+      {
+        getErrTxt(DB2I_ERR_PART_AUTOINC);
+        DBUG_RETURN(DB2I_ERR_PART_AUTOINC);
+      }
+#endif
+      query.append(STRING_WITH_LEN(" GENERATED BY DEFAULT AS IDENTITY ") );
+      if (create_info->auto_increment_value != 0) 
+      {
+        /* Query was ALTER TABLE...AUTO_INCREMENT = x; or
+        CREATE TABLE ...AUTO_INCREMENT = x;  Set the starting
+                    value for the auto_increment column.  */          
+        char stringValue[22];  
+        CHARSET_INFO *cs= &my_charset_bin;
+        uint len = (uint)(cs->cset->longlong10_to_str)(cs,stringValue,sizeof(stringValue), 10, create_info->auto_increment_value);  
+        stringValue[len] = 0;
+        query.append(STRING_WITH_LEN(" (START WITH "));
+        query.append(stringValue);
+
+        uint64 maxValue=maxValueForField(*field);
+        
+        if (maxValue)
+        {
+          len = (uint)(cs->cset->longlong10_to_str)(cs,stringValue,sizeof(stringValue), 10, maxValue);  
+          stringValue[len] = 0;
+          query.append(STRING_WITH_LEN(" MAXVALUE "));
+          query.append(stringValue);
+        }
+        
+        query.append(STRING_WITH_LEN(") "));
+      }
+
+    } 
+  }
+  
+  String fieldDefinition(128);
+  
+  if (table_arg->s->primary_key != MAX_KEY && !isTemporary)
+  {
+    query.append(STRING_WITH_LEN(", PRIMARY KEY "));
+    rc = buildIndexFieldList(fieldDefinition, 
+                             table_arg->key_info[table_arg->s->primary_key],
+                             true,
+                             &fileSortSequenceType,
+                             fileSortSequence,
+                             fileSortSequenceLibrary);
+    if (rc) DBUG_RETURN(rc);
+    query.append(fieldDefinition);
+  }
+
+  rc = buildDB2ConstraintString(thd->lex, 
+                                query, 
+                                name,
+                                table_arg->field,
+                                &fileSortSequenceType,
+                                fileSortSequence,
+                                fileSortSequenceLibrary);  
+  if (rc) DBUG_RETURN (rc);
+  
+  query.append(STRING_WITH_LEN(" ) "));
+  
+  if (isTemporary)
+    query.append(STRING_WITH_LEN(" ON COMMIT PRESERVE ROWS "));
+  
+  if (create_info->alias)
+    generateAndAppendRCDFMT(create_info->alias, query);
+  else if (((TABLE_LIST*)(thd->lex->select_lex.table_list.first))->table_name)  
+    generateAndAppendRCDFMT((char*)((TABLE_LIST*)(thd->lex->select_lex.table_list.first))->table_name, query);
+        
+  DBUG_PRINT("ha_ibmdb2i::create", ("Sent to DB2: %s",query.c_ptr()));
+  SqlStatementStream sqlStream(query.length());
+  sqlStream.addStatement(query,fileSortSequence,fileSortSequenceLibrary);
+  
+  if (table_arg->s->primary_key != MAX_KEY && 
+      !isTemporary &&
+      (THDVAR(thd, create_index_option)==1) &&
+      (fileSortSequenceType != 'B') &&
+      (fileSortSequenceType != ' '))
+  {
+    rc = generateShadowIndex(sqlStream, 
+                             table_arg->key_info[table_arg->s->primary_key], 
+                             libName, 
+                             fileName, 
+                             fieldDefinition);
+    if (rc) DBUG_RETURN(rc);
+  }
+  for (uint i = 0; i < table_arg->s->keys; ++i)
+  {
+    if (i != table_arg->s->primary_key || isTemporary)
+    {
+      rc = buildCreateIndexStatement(sqlStream, 
+                                table_arg->key_info[i], 
+                                false,
+                                libName,
+                                fileName);
+      if (rc) DBUG_RETURN (rc);
+    }
+  }
+  
+  bool noCommit = isTemporary || ((!autoCommitIsOn(thd)) && (thd_sql_command(thd) == SQLCOM_ALTER_TABLE));
+  
+  initBridge();
+  
+//   if (THDVAR(thd, discovery_mode) == 1)
+//     bridge()->expectErrors(QMY_ERR_TABLE_EXISTS);
+  
+  rc = bridge()->execSQL(sqlStream.getPtrToData(),
+                         sqlStream.getStatementCount(),
+                         (isTemporary ? QMY_NONE : getCommitLevel(thd)),
+                         TRUE,
+                         FALSE,
+                         noCommit );
+  
+  if (unlikely(rc == QMY_ERR_MSGID) &&
+      memcmp(bridge()->getErrorMsgID(), DB2I_SQL0350, 7) == 0)
+  {
+    my_error(ER_BLOB_USED_AS_KEY, MYF(0), "*unknown*");
+    rc = ER_BLOB_USED_AS_KEY;
+  }
+/*   else if (unlikely(rc == QMY_ERR_TABLE_EXISTS) &&
+            THDVAR(thd, discovery_mode) == 1)
+  {
+    db2i_table* temp = new db2i_table(table_arg->s, name);
+    int32 rc = temp->fastInitForCreate(name);
+    delete temp;
+    
+    if (!rc)
+      warning(thd, DB2I_ERR_WARN_CREATE_DISCOVER);
+    
+    DBUG_RETURN(rc);
+  }   
+*/
+  
+  if (!rc && !isTemporary)
+  {
+    db2i_table* temp = new db2i_table(table_arg->s, name);
+    rc = temp->fastInitForCreate(name);
+    delete temp;
+    if (rc) 
+      delete_table(name);
+  }
+  
+  DBUG_RETURN(rc);
+}
+
+
+/**
+  @brief
+  Add an index on-line to a table. This method is called on behalf of
+  a CREATE INDEX or ALTER TABLE statement. 
+  It is implemented via a composed DDL statement passed to DB2.
+*/
+int ha_ibmdb2i::add_index(TABLE *table_arg, 
+                          KEY *key_info,
+                          uint num_of_keys)
+{
+  DBUG_ENTER("ha_ibmdb2i::add_index");
+
+  int rc;
+  SqlStatementStream sqlStream(256);
+  const char* libName = db2Table->getDB2LibName(db2i_table::ASCII_SQL);
+  const char* fileName = db2Table->getDB2TableName(db2i_table::ASCII_SQL);
+  
+  quiesceAllFileHandles();
+  
+  uint primaryKey = MAX_KEY;
+  if (table_arg->s->primary_key >= MAX_KEY && !db2Table->isTemporary())
+  {  
+    for (int i = 0; i < num_of_keys; ++i)
+    {
+      if (strcmp(key_info[i].name, "PRIMARY") == 0)
+      {
+        primaryKey = i;
+        break;
+      }
+      else if (primaryKey == MAX_KEY &&
+               key_info[i].flags & HA_NOSAME)
+      {
+        primaryKey = i;
+        for (int j=0 ; j < key_info[i].key_parts ;j++)
+        {
+          uint fieldnr= key_info[i].key_part[j].fieldnr;
+          if (table_arg->s->field[fieldnr]->null_ptr ||
+              table_arg->s->field[fieldnr]->key_length() !=
+              key_info[i].key_part[j].length)
+          {
+            primaryKey = MAX_KEY;
+            break;
+          }
+        }
+      }
+    }
+  }
+        
+        
+  for (int i = 0; i < num_of_keys; ++i)
+  {
+    KEY& curKey= key_info[i];
+    rc = buildCreateIndexStatement(sqlStream, 
+                              curKey, 
+                              (i == primaryKey),
+                              libName,
+                              fileName);
+    if (rc) DBUG_RETURN (rc);
+  }
+  
+  rc = bridge()->execSQL(sqlStream.getPtrToData(),
+                         sqlStream.getStatementCount(),
+                         getCommitLevel(),
+                         FALSE,
+                         FALSE,
+                         FALSE,
+                         dataHandle);
+
+  /* Handle the case where a unique index is being created but an error occurs
+     because the file contains duplicate key values.                           */ 
+  if (rc == ER_DUP_ENTRY)
+    print_keydup_error(MAX_KEY,ER(ER_DUP_ENTRY_WITH_KEY_NAME));
+
+  DBUG_RETURN(rc);
+}
+
+/**
+  @brief
+  Drop an index on-line from a table. This method is called on behalf of
+  a DROP INDEX or ALTER TABLE statement. 
+  It is implemented via a composed DDL statement passed to DB2.
+*/
+int ha_ibmdb2i::prepare_drop_index(TABLE *table_arg, 
+                                   uint *key_num, uint num_of_keys)
+{
+  DBUG_ENTER("ha_ibmdb2i::prepare_drop_index");
+  int rc;
+  int i = 0;
+  String query(64);
+  SqlStatementStream sqlStream(64 * num_of_keys);
+  SqlStatementStream shadowStream(64 * num_of_keys);
+
+  quiesceAllFileHandles();
+  
+  const char* libName = db2Table->getDB2LibName(db2i_table::ASCII_SQL);
+  const char* fileName = db2Table->getDB2TableName(db2i_table::ASCII_SQL);
+
+  while (i < num_of_keys)
+  {
+    query.length(0);
+    DBUG_PRINT("info", ("ha_ibmdb2i::prepare_drop_index %u", key_num[i]));
+    KEY& curKey= table_arg->key_info[key_num[i]];
+    if (key_num[i] == table->s->primary_key && !db2Table->isTemporary())
+    {
+      query.append(STRING_WITH_LEN("ALTER TABLE "));
+      query.append(libName);
+      query.append(STRING_WITH_LEN("."));
+      query.append(fileName);
+      query.append(STRING_WITH_LEN(" DROP PRIMARY KEY"));
+    }
+    else
+    {
+      query.append(STRING_WITH_LEN("DROP INDEX "));
+      query.append(libName);
+      query.append(STRING_WITH_LEN("."));
+      db2i_table::appendQualifiedIndexFileName(curKey.name, fileName, query);
+    }
+    DBUG_PRINT("ha_ibmdb2i::prepare_drop_index", ("Sent to DB2: %s",query.c_ptr_safe()));
+    sqlStream.addStatement(query);
+    
+    query.length(0);
+    query.append(STRING_WITH_LEN("DROP INDEX "));
+    query.append(libName);
+    query.append(STRING_WITH_LEN("."));
+    db2i_table::appendQualifiedIndexFileName(curKey.name, fileName, query, db2i_table::ASCII_SQL, typeHex);
+    
+    DBUG_PRINT("ha_ibmdb2i::prepare_drop_index", ("Sent to DB2: %s",query.c_ptr_safe()));
+    shadowStream.addStatement(query);
+    
+    ++i;
+   }
+  
+  rc = bridge()->execSQL(sqlStream.getPtrToData(),
+                         sqlStream.getStatementCount(),
+                         getCommitLevel(),
+                         FALSE,
+                         FALSE,
+                         FALSE,
+                         dataHandle);
+  
+  if (rc == 0)
+    bridge()->execSQL(shadowStream.getPtrToData(),
+                         shadowStream.getStatementCount(),
+                         getCommitLevel());
+  
+  DBUG_RETURN(rc);
+}
+
+
+void
+ha_ibmdb2i::unlock_row()
+{
+  DBUG_ENTER("ha_ibmdb2i::unlock_row");
+  DBUG_VOID_RETURN;
+}    
+
+int
+ha_ibmdb2i::index_end()
+{
+  DBUG_ENTER("ha_ibmdb2i::index_end");
+  warnIfInvalidData();
+  last_index_init_rc = 0;
+  if (likely(activeReadBuf))
+    activeReadBuf->endRead();
+  if (likely(!last_index_init_rc))
+    releaseIndexFile(active_index);
+  active_index= MAX_KEY;
+  DBUG_RETURN (0);
+}
+
+int ha_ibmdb2i::doCommit(handlerton *hton, THD *thd, bool all)
+{
+  if (!THDVAR(thd, transaction_unsafe))
+  {
+    if (all || autoCommitIsOn(thd))
+    {
+      DBUG_PRINT("ha_ibmdb2i::doCommit",("Committing all"));
+      return (db2i_ileBridge::getBridgeForThread(thd)->commitmentControl(QMY_COMMIT));
+    }
+    else
+    {
+      DBUG_PRINT("ha_ibmdb2i::doCommit",("Committing stmt"));
+      return (db2i_ileBridge::getBridgeForThread(thd)->commitStmtTx());
+    }
+  }
+  
+  return (0);
+} 
+
+
+int ha_ibmdb2i::doRollback(handlerton *hton, THD *thd, bool all)
+{
+  if (!THDVAR(thd,transaction_unsafe))
+  {
+    if (all || autoCommitIsOn(thd))
+    {
+      DBUG_PRINT("ha_ibmdb2i::doRollback",("Rolling back all"));
+      return ( db2i_ileBridge::getBridgeForThread(thd)->commitmentControl(QMY_ROLLBACK));
+    }
+    else
+    {
+      DBUG_PRINT("ha_ibmdb2i::doRollback",("Rolling back stmt"));
+      return (db2i_ileBridge::getBridgeForThread(thd)->rollbackStmtTx());
+    }
+  }
+  return (0);
+}
+
+
+void ha_ibmdb2i::start_bulk_insert(ha_rows rows)
+{
+  DBUG_ENTER("ha_ibmdb2i::start_bulk_insert");
+  DBUG_PRINT("ha_ibmdb2i::start_bulk_insert",("Rows hinted %d", rows));
+  int rc;
+  THD* thd = ha_thd();
+  int command = thd_sql_command(thd);
+  
+  if (db2Table->hasBlobs() || 
+      (command == SQLCOM_REPLACE || command == SQLCOM_REPLACE_SELECT))
+    rows = 1;
+  else if (rows == 0)
+    rows = DEFAULT_MAX_ROWS_TO_BUFFER; // Shoot the moon
+  
+ // If we're doing a multi-row insert, binlogging is active, and the table has an
+ // auto_increment column, then we'll attempt to lock the file while we perform a 'fast path' blocked
+ // insert.  If we can't get the lock, then we'll do a row-by-row 'slow path' insert instead.  The reason is
+ // because the MI generates the auto_increment (identity value), and if we can't lock the file,
+ // then we can't predetermine what that value will be for insertion into the MySQL write buffer.
+
+  if ((rows > 1) &&                               // Multi-row insert
+      (thd->options & OPTION_BIN_LOG) &&          // Binlogging is on
+      (table->found_next_number_field))           // Table has an auto_increment column
+  {
+    if (!dataHandle)
+      rc = db2Table->dataFile()->allocateNewInstance(&dataHandle, curConnection);  
+
+    rc = bridge()->lockObj(dataHandle, 1, QMY_LOCK, QMY_LEAR, QMY_YES);
+    if (rc==0)                                     // Got the lock
+    {
+      autoIncLockAcquired = TRUE;               
+      got_auto_inc_values = FALSE;                    
+    }
+    else                                          // Didn't get the lock
+      rows = 1;                                   // No problem, but don't block inserts
+  }
+  
+  if (activeHandle == 0)
+  {
+    last_start_bulk_insert_rc = useDataFile();
+    if (last_start_bulk_insert_rc == 0)
+      last_start_bulk_insert_rc = prepWriteBuffer(rows, db2Table->dataFile());
+  }
+
+  if (last_start_bulk_insert_rc == 0)
+    outstanding_start_bulk_insert = true;
+  else
+  {
+    if (autoIncLockAcquired == TRUE)
+    {
+      bridge()->lockObj(dataHandle,  0, QMY_UNLOCK, QMY_LEAR, QMY_YES);
+      autoIncLockAcquired = FALSE;
+    }
+  }
+
+  DBUG_VOID_RETURN;
+}
+
+
+int ha_ibmdb2i::end_bulk_insert()
+{
+  DBUG_ENTER("ha_ibmdb2i::end_bulk_insert");
+  int rc = 0;
+  
+  if (outstanding_start_bulk_insert)
+  {
+    rc = finishBulkInsert();
+  }
+
+  my_errno = rc;
+    
+  DBUG_RETURN(rc);
+}
+
+  
+int ha_ibmdb2i::prepReadBuffer(ha_rows rowsToRead, const db2i_file* file, char intent)    
+{
+  DBUG_ENTER("ha_ibmdb2i::prepReadBuffer");
+  DBUG_ASSERT(rowsToRead > 0);
+
+  THD* thd = ha_thd();
+  char cmtLvl = getCommitLevel(thd);
+  
+  const db2i_file::RowFormat* format;
+  int rc = file->obtainRowFormat(activeHandle, intent, cmtLvl, &format);
+  
+  if (unlikely(rc)) DBUG_RETURN(rc);
+  
+  if (lobFieldsRequested())
+  {
+    forceSingleRowRead = true;
+    rowsToRead = 1;
+  }
+  
+  rowsToRead = min(stats.records+1,MYSQL_MIN(rowsToRead, DEFAULT_MAX_ROWS_TO_BUFFER));
+  
+  uint bufSize = min((format->readRowLen * rowsToRead), THDVAR(thd, max_read_buffer_size));
+  multiRowReadBuf.allocBuf(format->readRowLen, format->readRowNullOffset, bufSize);
+  activeReadBuf = &multiRowReadBuf;
+    
+  if (db2Table->hasBlobs())
+  {
+    if (!blobReadBuffers)
+      blobReadBuffers = new BlobCollection(db2Table, THDVAR(thd, lob_alloc_size));  
+    rc = prepareReadBufferForLobs();
+    if (rc) DBUG_RETURN(rc);
+  }
+  
+//   if (accessIntent == QMY_UPDATABLE &&
+//       thd_tx_isolation(thd) == ISO_REPEATABLE_READ &&
+//       !THDVAR(thd, transaction_unsafe))
+//     activeReadBuf->update(QMY_READ_ONLY, &releaseRowNeeded, QMY_REPEATABLE_READ);
+//   else
+    activeReadBuf->update(intent, &releaseRowNeeded, cmtLvl);
+
+  DBUG_RETURN(rc);
+}
+
+ 
+int ha_ibmdb2i::prepWriteBuffer(ha_rows rowsToWrite, const db2i_file* file)
+{
+  DBUG_ENTER("ha_ibmdb2i::prepWriteBuffer");
+  DBUG_ASSERT(accessIntent == QMY_UPDATABLE && rowsToWrite > 0);
+  
+  const db2i_file::RowFormat* format;
+  int rc = file->obtainRowFormat(activeHandle,
+                                 QMY_UPDATABLE,
+                                 getCommitLevel(ha_thd()),
+                                 &format);
+
+  if (unlikely(rc)) DBUG_RETURN(rc);
+  
+  rowsToWrite = min(rowsToWrite, DEFAULT_MAX_ROWS_TO_BUFFER);
+  
+  uint bufSize = min((format->writeRowLen * rowsToWrite), THDVAR(ha_thd(), max_write_buffer_size));
+  multiRowWriteBuf.allocBuf(format->writeRowLen, format->writeRowNullOffset, bufSize);
+  activeWriteBuf = &multiRowWriteBuf;
+
+  if (!blobWriteBuffers && db2Table->hasBlobs())
+  {
+    blobWriteBuffers = new ValidatedPointer<char>[db2Table->getBlobCount()];
+  }    
+  DBUG_RETURN(rc);
+}
+
+
+int ha_ibmdb2i::flushWrite(FILE_HANDLE fileHandle, uchar* buf )
+{
+  DBUG_ENTER("ha_ibmdb2i::flushWrite");
+  int rc;
+  int64 generatedIdValue = 0;
+  bool IdValueWasGenerated = FALSE;
+  char* lastDupKeyNamePtr = NULL;
+  uint32 lastDupKeyNameLen = 0;
+  int loopCnt = 0; 
+  bool retry_dup = FALSE; 
+
+ while (loopCnt == 0 || retry_dup == TRUE) 
+ {
+  rc = bridge()->writeRows(fileHandle,
+                           activeWriteBuf->ptr(),
+                           getCommitLevel(),  
+                           &generatedIdValue,
+                           &IdValueWasGenerated,
+                           &lastDupKeyRRN,
+                           &lastDupKeyNamePtr,
+                           &lastDupKeyNameLen,
+                           &incrementByValue);
+  loopCnt++;  
+  retry_dup = FALSE;
+  invalidateCachedStats();
+  if (lastDupKeyNameLen)
+  {
+    rrnAssocHandle = fileHandle;
+    
+    int command = thd_sql_command(ha_thd());
+
+    if (command == SQLCOM_REPLACE ||
+        command == SQLCOM_REPLACE_SELECT)
+      lastDupKeyID = 0;
+    else
+    {
+      lastDupKeyID = getKeyFromName(lastDupKeyNamePtr, lastDupKeyNameLen);
+      
+      if (likely(lastDupKeyID != MAX_KEY))
+      {
+        uint16 failedRow = activeWriteBuf->rowsWritten()+1; 
+
+        if (buf && (failedRow != activeWriteBuf->rowCount()))
+        {
+          const char* badRow = activeWriteBuf->getRowN(failedRow-1);
+          bool savedReadAllColumns = readAllColumns;
+          readAllColumns = true;
+          mungeDB2row(buf, 
+                      badRow, 
+                      badRow + activeWriteBuf->getRowNullOffset(),
+                      true);
+          readAllColumns = savedReadAllColumns;
+
+          if (table->found_next_number_field)
+          {
+            table->next_number_field->store(next_identity_value - (incrementByValue * (activeWriteBuf->rowCount() - (failedRow - 1))));
+          }
+        }
+
+        if (default_identity_value &&                 // Table has ID colm and generating a value
+           (!autoIncLockAcquired || !got_auto_inc_values) &&
+                                                      // Writing first or only row in block
+            loopCnt == 1 &&                           // Didn't already retry
+            lastDupKeyID == table->s->next_number_index) // Autoinc column is in failed index
+ 	{  
+          if (alterStartWith() == 0)                  // Reset next Identity value to max+1
+            retry_dup = TRUE;                         // Rtry the write operation
+	} 
+      }
+      else
+      {
+        char unknownIndex[MAX_DB2_FILENAME_LENGTH+1];
+        convFromEbcdic(lastDupKeyNamePtr, unknownIndex, min(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH));
+        unknownIndex[min(lastDupKeyNameLen, MAX_DB2_FILENAME_LENGTH)] = 0;        
+        getErrTxt(DB2I_ERR_UNKNOWN_IDX, unknownIndex);
+      }
+    }
+  }
+ } 
+
+  if ((rc == 0 || rc == HA_ERR_FOUND_DUPP_KEY)
+         && default_identity_value && IdValueWasGenerated &&
+     (!autoIncLockAcquired || !got_auto_inc_values))
+  {
+    /* Save the generated identity value for the MySQL last_insert_id() function. */
+    insert_id_for_cur_row = generatedIdValue;
+ 
+    /* Store the value into MySQL's buf for row-based replication
+       or for an 'on duplicate key update' clause.                      */
+    table->next_number_field->store((longlong) generatedIdValue, TRUE);
+    if (autoIncLockAcquired)
+    {
+      got_auto_inc_values = TRUE;
+      next_identity_value = generatedIdValue + incrementByValue;
+    }
+  } 
+  else
+  {
+    if (!autoIncLockAcquired)      // Don't overlay value for first row of a block  
+      insert_id_for_cur_row = 0;                                        
+  }
+  
+
+  activeWriteBuf->resetAfterWrite();
+  DBUG_RETURN(rc);
+}
+
+int ha_ibmdb2i::alterStartWith() 
+{ 
+  DBUG_ENTER("ha_ibmdb2i::alterStartWith");  
+  int rc = 0; 
+  ulonglong nextIdVal; 
+  if (!dataHandle) 
+     rc = db2Table->dataFile()->allocateNewInstance(&dataHandle, curConnection);
+  if (!rc) {rc = bridge()->lockObj(dataHandle, 1, QMY_LOCK, QMY_LENR, QMY_YES);}
+  if (!rc) 
+  {  
+    rc = getNextIdVal(&nextIdVal); 
+    if (!rc) {rc = reset_auto_increment(nextIdVal);} 
+    bridge()->lockObj(dataHandle,  0, QMY_UNLOCK, QMY_LENR, QMY_YES); 
+  } 
+  DBUG_RETURN(rc); 
+}
+
+bool ha_ibmdb2i::lobFieldsRequested()
+{
+  if (!db2Table->hasBlobs())
+  {
+    DBUG_PRINT("ha_ibmdb2i::lobFieldsRequested",("No LOBs"));
+    return (false);
+  }
+
+  if (readAllColumns)
+  {
+    DBUG_PRINT("ha_ibmdb2i::lobFieldsRequested",("All cols requested"));
+    return (true);
+  }
+    
+  for (int i = 0; i < db2Table->getBlobCount(); ++i)
+  {
+    if (bitmap_is_set(table->read_set, db2Table->blobFields[i]))
+    {
+      DBUG_PRINT("ha_ibmdb2i::lobFieldsRequested",("LOB requested"));
+      return (true);
+    }
+  }
+  
+  DBUG_PRINT("ha_ibmdb2i::lobFieldsRequested",("No LOBs requested"));
+  return (false);
+}
+
+
+int ha_ibmdb2i::prepareReadBufferForLobs()
+{
+  DBUG_ENTER("ha_ibmdb2i::prepareReadBufferForLobs");
+  DBUG_ASSERT(db2Table->hasBlobs());
+  
+  uint32 activeLobFields = 0;
+  DB2LobField* lobField;
+  uint16 blobCount = db2Table->getBlobCount();
+    
+  char* readBuf = activeReadBuf->getRowN(0);
+  
+  for (int i = 0; i < blobCount; ++i)
+  {
+    int fieldID = db2Table->blobFields[i];
+    DB2Field& db2Field = db2Table->db2Field(fieldID);
+    lobField = db2Field.asBlobField(readBuf);
+    if (readAllColumns ||
+        bitmap_is_set(table->read_set, fieldID))
+    {
+      lobField->dataHandle = (ILEMemHandle)blobReadBuffers->getBufferPtr(fieldID);
+      activeLobFields++;
+    }
+    else
+    {
+      lobField->dataHandle = NULL;
+    }
+  }
+  
+  if (activeLobFields == 0)
+  {
+    for (int i = 0; i < blobCount; ++i)
+    {
+      DB2Field& db2Field = db2Table->db2Field(db2Table->blobFields[i]);
+      uint16 offset = db2Field.getBufferOffset() + db2Field.calcBlobPad();
+
+      for (int r = 1; r < activeReadBuf->getRowCapacity(); ++r)
+      { 
+        lobField = (DB2LobField*)(activeReadBuf->getRowN(r) + offset);
+        lobField->dataHandle = NULL;
+      }      
+    }
+  }
+
+  activeReadBuf->setRowsToProcess((activeLobFields ? 1 : activeReadBuf->getRowCapacity()));
+  int rc = bridge()->objectOverride(activeHandle,
+                                    activeReadBuf->ptr(),
+                                    activeReadBuf->getRowLength());
+  DBUG_RETURN(rc);
+}
+
+
+uint32 ha_ibmdb2i::adjustLobBuffersForRead()
+{
+  DBUG_ENTER("ha_ibmdb2i::adjustLobBuffersForRead");
+
+  char* readBuf = activeReadBuf->getRowN(0);
+   
+  for (int i = 0; i < db2Table->getBlobCount(); ++i)
+  {
+    DB2Field& db2Field = db2Table->db2Field(db2Table->blobFields[i]);
+    DB2LobField* lobField = db2Field.asBlobField(readBuf);
+    if (readAllColumns || 
+        bitmap_is_set(table->read_set, db2Table->blobFields[i]))
+    {
+      lobField->dataHandle = (ILEMemHandle)blobReadBuffers->reallocBuffer(db2Table->blobFields[i], lobField->length);
+
+      if (lobField->dataHandle == NULL)
+        DBUG_RETURN(HA_ERR_OUT_OF_MEM);
+    }      
+    else
+    {
+      lobField->dataHandle = 0;
+    }
+  }
+  
+  int32 rc = bridge()->objectOverride(activeHandle,
+                                      activeReadBuf->ptr());
+  DBUG_RETURN(rc);
+}
+
+
+
+int ha_ibmdb2i::reset()
+{
+  DBUG_ENTER("ha_ibmdb2i::reset");
+
+  if (outstanding_start_bulk_insert)
+  {
+    finishBulkInsert();
+  }  
+  
+  if (activeHandle != 0)
+  {
+    releaseActiveHandle();
+  }
+  
+  cleanupBuffers();
+  
+  db2i_ileBridge::getBridgeForThread(ha_thd())->freeErrorStorage();
+    
+  last_rnd_init_rc = last_index_init_rc = last_start_bulk_insert_rc = 0;
+
+  returnDupKeysImmediately = false;
+  onDupUpdate = false;
+  forceSingleRowRead = false; 
+
+#ifndef DBUG_OFF
+  cachedBridge=NULL;
+#endif      
+      
+  DBUG_RETURN(0);
+}
+
+
+int32 ha_ibmdb2i::buildCreateIndexStatement(SqlStatementStream& sqlStream, 
+                                           KEY& key,
+                                           bool isPrimary,
+                                           const char* db2LibName,    
+                                           const char* db2FileName)
+{
+  DBUG_ENTER("ha_ibmdb2i::buildCreateIndexStatement");
+
+  char fileSortSequence[11] = "*HEX";
+  char fileSortSequenceLibrary[11] = "";
+  char fileSortSequenceType = ' ';
+  String query(256);
+  query.length(0);
+  int rc = 0;
+  
+  if (isPrimary)
+  {
+    query.append(STRING_WITH_LEN("ALTER TABLE "));
+    query.append(db2LibName);
+    query.append('.');
+    query.append(db2FileName);
+    query.append(STRING_WITH_LEN(" ADD PRIMARY KEY "));    
+  }
+  else
+  {
+    query.append(STRING_WITH_LEN("CREATE"));
+
+    if (key.flags & HA_NOSAME)
+      query.append(STRING_WITH_LEN(" UNIQUE WHERE NOT NULL"));
+
+    query.append(STRING_WITH_LEN(" INDEX "));
+
+    query.append(db2LibName);
+    query.append('.');
+    if (db2i_table::appendQualifiedIndexFileName(key.name, db2FileName, query))
+    {
+      getErrTxt(DB2I_ERR_INVALID_NAME,"index","*generated*");
+      DBUG_RETURN(DB2I_ERR_INVALID_NAME );
+    }
+
+    query.append(STRING_WITH_LEN(" ON "));
+
+    query.append(db2LibName);
+    query.append('.');
+    query.append(db2FileName);
+  }
+  
+  String fieldDefinition(128);
+  rc = buildIndexFieldList(fieldDefinition,
+                           key,
+                           isPrimary,
+                           &fileSortSequenceType, 
+                           fileSortSequence,
+                           fileSortSequenceLibrary);
+  
+  if (rc) DBUG_RETURN(rc);
+   
+  query.append(fieldDefinition);
+  
+  if ((THDVAR(ha_thd(), create_index_option)==1) &&
+      (fileSortSequenceType != 'B') &&
+      (fileSortSequenceType != ' '))
+  {
+    rc = generateShadowIndex(sqlStream, 
+                             key, 
+                             db2LibName, 
+                             db2FileName, 
+                             fieldDefinition);
+    if (rc) DBUG_RETURN(rc);
+  }
+    
+  DBUG_PRINT("ha_ibmdb2i::buildCreateIndexStatement", ("Sent to DB2: %s",query.c_ptr_safe()));
+  sqlStream.addStatement(query,fileSortSequence,fileSortSequenceLibrary);
+
+  DBUG_RETURN(0);
+}
+
+/**
+  Generate the SQL syntax for the list of fields to be assigned to the 
+  specified key. The corresponding sort sequence is also calculated.
+      
+  @param[out] appendHere  The string to receive the generated SQL
+  @param key  The key to evaluate
+  @param isPrimary  True if this is being generated on behalf of the primary key
+  @param[out] fileSortSequenceType  The type of the associated sort sequence
+  @param[out] fileSortSequence  The name of the associated sort sequence
+  @param[out] fileSortSequenceLibrary  The library of the associated sort sequence
+  
+  @return  0 if successful; error value otherwise
+*/
+int32 ha_ibmdb2i::buildIndexFieldList(String& appendHere,
+                                      const KEY& key,
+                                      bool isPrimary,
+                                      char* fileSortSequenceType, 
+                                      char* fileSortSequence, 
+                                      char* fileSortSequenceLibrary)
+{
+  DBUG_ENTER("ha_ibmdb2i::buildIndexFieldList");
+  appendHere.append(STRING_WITH_LEN(" ( "));
+  for (int j = 0; j < key.key_parts; ++j)
+  {
+    char colName[MAX_DB2_COLNAME_LENGTH+1];
+    if (j != 0)
+    {
+      appendHere.append(STRING_WITH_LEN(" , "));
+    }
+    
+    KEY_PART_INFO& kpi = key.key_part[j];
+    Field* field = kpi.field;
+    
+    convertMySQLNameToDB2Name(field->field_name, 
+                              colName, 
+                              sizeof(colName));
+    appendHere.append(colName);
+    
+    int32 rc;
+    rc = updateAssociatedSortSequence(field->charset(),
+                                      fileSortSequenceType,
+                                      fileSortSequence,
+                                      fileSortSequenceLibrary);
+    if (rc) DBUG_RETURN (rc);
+  }
+    
+  appendHere.append(STRING_WITH_LEN(" ) "));
+  
+  DBUG_RETURN(0);
+}
+
+
+/**
+  Generate an SQL statement that defines a *HEX sorted index to implement 
+  the ibmdb2i_create_index.
+      
+  @param[out] stream  The stream to append the generated statement to
+  @param key  The key to evaluate
+  @param[out] libName  The library containg the table
+  @param[out] fileName  The DB2-compatible name of the table 
+  @param[out] fieldDefinition  The list of the fields in the index, in SQL syntax
+  
+  @return  0 if successful; error value otherwise
+*/
+int32 ha_ibmdb2i::generateShadowIndex(SqlStatementStream& stream, 
+                                      const KEY& key,
+                                      const char* libName,
+                                      const char* fileName,
+                                      const String& fieldDefinition)
+{
+  String shadowQuery(256);
+  shadowQuery.length(0);
+  shadowQuery.append(STRING_WITH_LEN("CREATE INDEX "));
+  shadowQuery.append(libName);
+  shadowQuery.append('.');
+  if (db2i_table::appendQualifiedIndexFileName(key.name, fileName, shadowQuery, db2i_table::ASCII_SQL, typeHex))
+  {
+    getErrTxt(DB2I_ERR_INVALID_NAME,"index","*generated*");
+    return DB2I_ERR_INVALID_NAME;
+  }
+  shadowQuery.append(STRING_WITH_LEN(" ON "));
+  shadowQuery.append(libName);
+  shadowQuery.append('.');
+  shadowQuery.append(fileName);
+  shadowQuery.append(fieldDefinition);
+  DBUG_PRINT("ha_ibmdb2i::generateShadowIndex", ("Sent to DB2: %s",shadowQuery.c_ptr_safe()));
+  stream.addStatement(shadowQuery,"*HEX","QSYS");
+  return 0;
+}
+  
+  
+void ha_ibmdb2i::doInitialRead(char orientation,
+                                uint32 rowsToBuffer,
+                                ILEMemHandle key,
+                                int keyLength,
+                                int keyParts)
+{
+  DBUG_ENTER("ha_ibmdb2i::doInitialRead");
+  
+  if (forceSingleRowRead)
+    rowsToBuffer = 1;
+  else
+    rowsToBuffer = min(rowsToBuffer, activeReadBuf->getRowCapacity());
+        
+  activeReadBuf->newReadRequest(activeHandle,
+                                    orientation,
+                                    rowsToBuffer,
+                                    THDVAR(ha_thd(), async_enabled),
+                                    key, 
+                                    keyLength,
+                                    keyParts);
+  DBUG_VOID_RETURN;
+}
+
+
+int ha_ibmdb2i::start_stmt(THD *thd, thr_lock_type lock_type)
+{
+  DBUG_ENTER("ha_ibmdb2i::start_stmt");
+  initBridge(thd);
+  if (!THDVAR(thd, transaction_unsafe))
+  {
+    trans_register_ha(thd, FALSE, ibmdb2i_hton);
+    
+    if (!autoCommitIsOn(thd))
+    {
+      bridge()->beginStmtTx();
+    }
+  }
+
+  DBUG_RETURN(0);
+}
+
+int32 ha_ibmdb2i::handleLOBReadOverflow()
+{
+  DBUG_ENTER("ha_ibmdb2i::handleLOBReadOverflow");
+  DBUG_ASSERT(db2Table->hasBlobs() && (activeReadBuf->getRowCapacity() == 1));
+
+  int32 rc = adjustLobBuffersForRead();
+
+  if (!rc)
+  {
+    activeReadBuf->rewind();
+    rc = bridge()->expectErrors(QMY_ERR_END_OF_BLOCK)
+                 ->read(activeHandle, 
+                        activeReadBuf->ptr(),
+                        accessIntent,
+                        getCommitLevel(),
+                        QMY_SAME);
+    releaseRowNeeded = TRUE;
+
+  }
+  DBUG_RETURN(rc);
+}
+
+
+int32 ha_ibmdb2i::finishBulkInsert()
+{
+  int32 rc = 0;
+
+  if (activeWriteBuf->rowCount() && activeHandle)
+    rc = flushWrite(activeHandle, table->record[0]);
+
+  if (activeHandle)
+    releaseActiveHandle();
+
+  if (autoIncLockAcquired == TRUE)
+  {
+   // We could check the return code on the unlock, but beware not
+   // to overlay the return code from the flushwrite or we will mask
+   // duplicate key errors..
+    bridge()->lockObj(dataHandle, 0, QMY_UNLOCK, QMY_LEAR, QMY_YES);
+    autoIncLockAcquired = FALSE;
+  } 
+  outstanding_start_bulk_insert = false;
+  multiRowWriteBuf.freeBuf();    
+  last_start_bulk_insert_rc = 0;
+
+  resetCharacterConversionBuffers();
+
+  return rc;
+}
+
+int ha_ibmdb2i::getKeyFromName(const char* name, size_t len)  
+{
+  for (int i = 0; i < table_share->keys; ++i)
+  {
+    const char* indexName = db2Table->indexFile(i)->getDB2FileName();
+    if ((strncmp(name, indexName, len) == 0) &&
+        (strlen(indexName) == len))
+    {
+      return i;        
+    }
+  }
+  return MAX_KEY;
+}
+
+/*                                                                       
+Determine the number of I/O's it takes to read through the table.        
+                                                                      */
+double ha_ibmdb2i::scan_time()
+  {
+    DBUG_ENTER("ha_ibmdb2i::scan_time");
+    DBUG_RETURN(ulonglong2double((stats.data_file_length)/IO_SIZE));
+  }
+
+
+/**
+  Estimate the number of I/O's it takes to read a set of ranges through
+  an index.                                                            
+  
+  @param index  
+  @param ranges  
+  @param rows  
+  
+  @return The estimate number of I/Os
+*/
+
+double ha_ibmdb2i::read_time(uint index, uint ranges, ha_rows rows)
+{
+  DBUG_ENTER("ha_ibmdb2i::read_time");
+  int rc;
+  uint64 idxPageCnt = 0;
+  double cost;
+  
+  if (unlikely(rows == HA_POS_ERROR))
+    DBUG_RETURN(double(rows) + ranges);
+
+  rc = bridge()->retrieveIndexInfo(db2Table->indexFile(index)->getMasterDefnHandle(),
+                                                        &idxPageCnt);                     
+  if (!rc)
+  {
+     if ((idxPageCnt == 1) ||            // Retrieving rows in requested order or
+         (ranges == rows))               // 'Sweep' full records retrieval           
+       cost = idxPageCnt/4;
+     else
+     {  
+       uint64 totalRecords = stats.records + 1;
+       double dataPageCount = stats.data_file_length/IO_SIZE;
+                  
+       cost = (rows * dataPageCount / totalRecords) + 
+               min(idxPageCnt, (log_2(idxPageCnt) * ranges + 
+                                rows * (log_2(idxPageCnt) + log_2(rows) - log_2(totalRecords))));
+     } 
+  }
+  else
+  {
+     cost = rows2double(ranges+rows);    // Use default costing
+  }
+  DBUG_RETURN(cost);
+}
+
+int ha_ibmdb2i::useIndexFile(int idx)
+{
+  DBUG_ENTER("ha_ibmdb2i::useIndexFile");
+
+  if (activeHandle)
+    releaseActiveHandle();
+
+  int rc = 0;
+
+  if (!indexHandles[idx])
+    rc = db2Table->indexFile(idx)->allocateNewInstance(&indexHandles[idx], curConnection);
+
+  if (rc == 0)
+  {
+      activeHandle = indexHandles[idx];
+      bumpInUseCounter(1);
+  }
+
+   DBUG_RETURN(rc);
+}
+
+
+ulong ha_ibmdb2i::index_flags(uint inx, uint part, bool all_parts) const
+{
+  return  HA_READ_NEXT | HA_READ_PREV | HA_KEYREAD_ONLY | HA_READ_ORDER | HA_READ_RANGE;
+}
+
+
+static struct st_mysql_sys_var* ibmdb2i_system_variables[] = {
+  MYSQL_SYSVAR(rdb_name),
+  MYSQL_SYSVAR(transaction_unsafe),
+  MYSQL_SYSVAR(lob_alloc_size),
+  MYSQL_SYSVAR(max_read_buffer_size),
+  MYSQL_SYSVAR(max_write_buffer_size),
+  MYSQL_SYSVAR(async_enabled),
+  MYSQL_SYSVAR(assume_exclusive_use),
+  MYSQL_SYSVAR(compat_opt_blob_cols),
+  MYSQL_SYSVAR(compat_opt_time_as_duration),
+  MYSQL_SYSVAR(compat_opt_allow_zero_date_vals),
+  MYSQL_SYSVAR(compat_opt_year_as_int),
+  MYSQL_SYSVAR(propagate_default_col_vals),
+  MYSQL_SYSVAR(create_index_option),
+//   MYSQL_SYSVAR(discovery_mode),
+  MYSQL_SYSVAR(system_trace_level),
+  NULL
+};
+
+
+struct st_mysql_storage_engine ibmdb2i_storage_engine=
+{ MYSQL_HANDLERTON_INTERFACE_VERSION };
+
+mysql_declare_plugin(ibmdb2i)
+{
+  MYSQL_STORAGE_ENGINE_PLUGIN,
+  &ibmdb2i_storage_engine,
+  "IBMDB2I",
+  "The IBM development team in Rochester, Minnesota",
+  "IBM DB2 for i Storage Engine",
+  PLUGIN_LICENSE_GPL,
+  ibmdb2i_init_func,                            /* Plugin Init */
+  ibmdb2i_done_func,                            /* Plugin Deinit */
+  0x0100 /* 1.0 */,
+  NULL,                                         /* status variables */
+  ibmdb2i_system_variables,                       /* system variables */
+  NULL                                          /* config options */
+}
+mysql_declare_plugin_end;
diff -urN mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc.rej mysql/storage/ibmdb2i/ha_ibmdb2i.cc.rej
--- mysql-old/storage/ibmdb2i/ha_ibmdb2i.cc.rej	1969-12-31 23:00:00.000000000 -0100
+++ mysql/storage/ibmdb2i/ha_ibmdb2i.cc.rej	2009-12-10 00:57:23.429840544 -0100
@@ -0,0 +1,21 @@
+***************
+*** 2644,2652 ****
+      rowsToRead = 1;
+    }
+    
+-   rowsToRead = min(stats.records+1,min(rowsToRead, DEFAULT_MAX_ROWS_TO_BUFFER));
+    
+-   uint bufSize = min((format->readRowLen * rowsToRead), THDVAR(thd, max_read_buffer_size));
+    multiRowReadBuf.allocBuf(format->readRowLen, format->readRowNullOffset, bufSize);
+    activeReadBuf = &multiRowReadBuf;
+      
+--- 2644,2652 ----
+      rowsToRead = 1;
+    }
+    
++   rowsToRead = MYSQL_MIN(stats.records+1,min(rowsToRead, DEFAULT_MAX_ROWS_TO_BUFFER));
+    
++   uint bufSize = MYSQL_MIN((format->readRowLen * rowsToRead), THDVAR(thd, max_read_buffer_size));
+    multiRowReadBuf.allocBuf(format->readRowLen, format->readRowNullOffset, bufSize);
+    activeReadBuf = &multiRowReadBuf;
+      
diff -urN mysql-old/storage/ibmdb2i/ha_ibmdb2i.h mysql/storage/ibmdb2i/ha_ibmdb2i.h
--- mysql-old/storage/ibmdb2i/ha_ibmdb2i.h	2009-12-10 00:54:18.740801668 -0100
+++ mysql/storage/ibmdb2i/ha_ibmdb2i.h	2009-12-10 00:57:23.429840544 -0100
@@ -502,7 +502,7 @@
   ha_rows getIndexReadEstimate(uint index)
   {
     if (indexReadSizeEstimates)
-      return max(indexReadSizeEstimates[index], 1);
+      return MYSQL_MAX(indexReadSizeEstimates[index], 1);
     
     return 10000; // Assume index scan if no estimate exists.
   }
diff -urN mysql-old/storage/innobase/include/ut0byte.h mysql/storage/innobase/include/ut0byte.h
--- mysql-old/storage/innobase/include/ut0byte.h	2009-12-10 00:54:18.733801273 -0100
+++ mysql/storage/innobase/include/ut0byte.h	2009-12-10 00:57:23.430599449 -0100
@@ -87,7 +87,7 @@
 dulint
 ut_dulint_get_max(
 /*==============*/
-			/* out: max(a, b) */
+			/* out: MYSQL_MAX(a, b) */
 	dulint	a,	/* in: dulint */
 	dulint	b);	/* in: dulint */
 /***********************************************************
@@ -96,7 +96,7 @@
 dulint
 ut_dulint_get_min(
 /*==============*/
-			/* out: min(a, b) */
+			/* out: MYSQL_MIN(a, b) */
 	dulint	a,	/* in: dulint */
 	dulint	b);	/* in: dulint */
 /***********************************************************
diff -urN mysql-old/storage/innodb_plugin/dict/dict0dict.c mysql/storage/innodb_plugin/dict/dict0dict.c
--- mysql-old/storage/innodb_plugin/dict/dict0dict.c	2009-12-10 00:54:18.728801665 -0100
+++ mysql/storage/innodb_plugin/dict/dict0dict.c	2009-12-10 00:57:23.431800036 -0100
@@ -4699,7 +4699,7 @@
 
 /**********************************************************************//**
 In case there is more than one index with the same name return the index
-with the min(id).
+with the MYSQL_MIN(id).
 @return	index, NULL if does not exist */
 UNIV_INTERN
 dict_index_t*
@@ -4709,7 +4709,7 @@
 	const char*	name)	/*!< in: name of the index to find */
 {
 	dict_index_t*	index;
-	dict_index_t*	min_index; /* Index with matching name and min(id) */
+	dict_index_t*	min_index; /* Index with matching name and MYSQL_MIN(id) */
 
 	min_index = NULL;
 	index = dict_table_get_first_index(table);
diff -urN mysql-old/storage/innodb_plugin/include/dict0dict.h mysql/storage/innodb_plugin/include/dict0dict.h
--- mysql-old/storage/innodb_plugin/include/dict0dict.h	2009-12-10 00:54:18.726799841 -0100
+++ mysql/storage/innodb_plugin/include/dict0dict.h	2009-12-10 00:57:23.433924906 -0100
@@ -1090,7 +1090,7 @@
 	const char*	name);	/*!< in: name of the index to find */
 /**********************************************************************//**
 In case there is more than one index with the same name return the index
-with the min(id).
+with the MYSQL_MIN(id).
 @return	index, NULL if does not exist */
 UNIV_INTERN
 dict_index_t*
diff -urN mysql-old/storage/innodb_plugin/include/ut0byte.h mysql/storage/innodb_plugin/include/ut0byte.h
--- mysql-old/storage/innodb_plugin/include/ut0byte.h	2009-12-10 00:54:18.723801555 -0100
+++ mysql/storage/innodb_plugin/include/ut0byte.h	2009-12-10 00:57:23.434904923 -0100
@@ -99,7 +99,7 @@
 	dulint	b);	/*!< in: dulint */
 /*******************************************************//**
 Calculates the max of two dulints.
-@return	max(a, b) */
+@return	MYSQL_MAX(a, b) */
 UNIV_INLINE
 dulint
 ut_dulint_get_max(
@@ -108,7 +108,7 @@
 	dulint	b);	/*!< in: dulint */
 /*******************************************************//**
 Calculates the min of two dulints.
-@return	min(a, b) */
+@return	MYSQL_MIN(a, b) */
 UNIV_INLINE
 dulint
 ut_dulint_get_min(
diff -urN mysql-old/storage/myisam/ft_boolean_search.c mysql/storage/myisam/ft_boolean_search.c
--- mysql-old/storage/myisam/ft_boolean_search.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/ft_boolean_search.c	2009-12-10 00:57:23.435891307 -0100
@@ -46,9 +46,9 @@
     three subexpressions (including the top-level one),
     every one has its own max_docid, updated by its plus word.
     but for the search word6 uses
-    max(word1.max_docid, word3.max_docid, word5.max_docid),
+    MYSQL_MAX(word1.max_docid, word3.max_docid, word5.max_docid),
     while word4 uses, accordingly,
-    max(word1.max_docid, word3.max_docid).
+    MYSQL_MAX(word1.max_docid, word3.max_docid).
 */
 
 #define FT_CORE
diff -urN mysql-old/storage/myisam/ha_myisam.cc mysql/storage/myisam/ha_myisam.cc
--- mysql-old/storage/myisam/ha_myisam.cc	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/ha_myisam.cc	2009-12-10 00:57:23.436925199 -0100
@@ -1519,7 +1519,7 @@
 {
   DBUG_ENTER("ha_myisam::start_bulk_insert");
   THD *thd= current_thd;
-  ulong size= min(thd->variables.read_buff_size,
+  ulong size= MYSQL_MIN(thd->variables.read_buff_size,
                   (ulong) (table->s->avg_row_length*rows));
   DBUG_PRINT("info",("start_bulk_insert: rows %lu size %lu",
                      (ulong) rows, size));
diff -urN mysql-old/storage/myisam/mi_cache.c mysql/storage/myisam/mi_cache.c
--- mysql-old/storage/myisam/mi_cache.c	2009-12-10 00:54:18.717800958 -0100
+++ mysql/storage/myisam/mi_cache.c	2009-12-10 00:57:23.437924978 -0100
@@ -61,7 +61,7 @@
       (my_off_t) (info->read_end - info->request_pos))
   {
     in_buff_pos=info->request_pos+(uint) offset;
-    in_buff_length= min(length, (size_t) (info->read_end-in_buff_pos));
+    in_buff_length= MYSQL_MIN(length, (size_t) (info->read_end-in_buff_pos));
     memcpy(buff,info->request_pos+(uint) offset,(size_t) in_buff_length);
     if (!(length-=in_buff_length))
       DBUG_RETURN(0);
diff -urN mysql-old/storage/myisam/mi_check.c mysql/storage/myisam/mi_check.c
--- mysql-old/storage/myisam/mi_check.c	2009-12-10 00:54:18.717800958 -0100
+++ mysql/storage/myisam/mi_check.c	2009-12-10 00:57:23.439925308 -0100
@@ -2165,7 +2165,7 @@
   ulong buff_length;
   DBUG_ENTER("filecopy");
 
-  buff_length=(ulong) min(param->write_buffer_length,length);
+  buff_length=(ulong) MYSQL_MIN(param->write_buffer_length,length);
   if (!(buff=my_malloc(buff_length,MYF(0))))
   {
     buff=tmp_buff; buff_length=IO_SIZE;
@@ -2321,7 +2321,7 @@
   init_alloc_root(&sort_param.wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);
 
   if (share->data_file_type == DYNAMIC_RECORD)
-    length=max(share->base.min_pack_length+1,share->base.min_block_length);
+    length=MYSQL_MAX(share->base.min_pack_length+1,share->base.min_block_length);
   else if (share->data_file_type == COMPRESSED_RECORD)
     length=share->base.min_block_length;
   else
@@ -2772,7 +2772,7 @@
     my_seek(param->read_cache.file,0L,MY_SEEK_END,MYF(0));
 
   if (share->data_file_type == DYNAMIC_RECORD)
-    rec_length=max(share->base.min_pack_length+1,share->base.min_block_length);
+    rec_length=MYSQL_MAX(share->base.min_pack_length+1,share->base.min_block_length);
   else if (share->data_file_type == COMPRESSED_RECORD)
     rec_length=share->base.min_block_length;
   else
@@ -3967,7 +3967,7 @@
   ft_buf->buf=ft_buf->lastkey+a_len;
   /*
     32 is just a safety margin here
-    (at least max(val_len, sizeof(nod_flag)) should be there).
+    (at least MYSQL_MAX(val_len, sizeof(nod_flag)) should be there).
     May be better performance could be achieved if we'd put
       (sort_info->keyinfo->block_length-32)/XXX
       instead.
@@ -4318,7 +4318,7 @@
 
   VOID(mi_close(*org_info));
   bzero((char*) &create_info,sizeof(create_info));
-  create_info.max_rows=max(max_records,share.base.records);
+  create_info.max_rows=MYSQL_MAX(max_records,share.base.records);
   create_info.reloc_rows=share.base.reloc;
   create_info.old_options=(share.options |
 			   (unpack ? HA_OPTION_TEMP_COMPRESS_RECORD : 0));
diff -urN mysql-old/storage/myisam/mi_create.c mysql/storage/myisam/mi_create.c
--- mysql-old/storage/myisam/mi_create.c	2009-12-10 00:54:18.717800958 -0100
+++ mysql/storage/myisam/mi_create.c	2009-12-10 00:57:23.441925056 -0100
@@ -27,6 +27,7 @@
 #endif
 #endif
 #include <m_ctype.h>
+#include "my_global.h"
 
 /*
   Old options is used when recreating database, from myisamchk
@@ -439,8 +440,8 @@
     block_length= (keydef->block_length ? 
                    my_round_up_to_next_power(keydef->block_length) :
                    myisam_block_size);
-    block_length= max(block_length, MI_MIN_KEY_BLOCK_LENGTH);
-    block_length= min(block_length, MI_MAX_KEY_BLOCK_LENGTH);
+    block_length= MYSQL_MAX(block_length, MI_MIN_KEY_BLOCK_LENGTH);
+    block_length= MYSQL_MIN(block_length, MI_MAX_KEY_BLOCK_LENGTH);
 
     keydef->block_length= (uint16) MI_BLOCK_SIZE(length-real_length_diff,
                                                  pointer,MI_MAX_KEYPTR_SIZE,
@@ -529,7 +530,7 @@
     got from MYI file header (see also myisampack.c:save_state)
   */
   share.base.key_reflength=
-    mi_get_pointer_length(max(ci->key_file_length,tmp),3);
+    mi_get_pointer_length(MYSQL_MAX(ci->key_file_length,tmp),3);
   share.base.keys= share.state.header.keys= keys;
   share.state.header.uniques= uniques;
   share.state.header.fulltext_keys= fulltext_keys;
@@ -567,7 +568,7 @@
   share.base.min_block_length=
     (share.base.pack_reclength+3 < MI_EXTEND_BLOCK_LENGTH &&
      ! share.base.blobs) ?
-    max(share.base.pack_reclength,MI_MIN_BLOCK_LENGTH) :
+    MYSQL_MAX(share.base.pack_reclength,MI_MIN_BLOCK_LENGTH) :
     MI_EXTEND_BLOCK_LENGTH;
   if (! (flags & HA_DONT_TOUCH_DATA))
     share.state.create_time= (long) time((time_t*) 0);
diff -urN mysql-old/storage/myisam/mi_dynrec.c mysql/storage/myisam/mi_dynrec.c
--- mysql-old/storage/myisam/mi_dynrec.c	2009-12-10 00:54:18.717800958 -0100
+++ mysql/storage/myisam/mi_dynrec.c	2009-12-10 00:57:23.442925103 -0100
@@ -850,7 +850,7 @@
 	uint tmp=MY_ALIGN(reclength - length + 3 +
 			  test(reclength >= 65520L),MI_DYN_ALIGN_SIZE);
 	/* Don't create a block bigger than MI_MAX_BLOCK_LENGTH */
-	tmp= min(length+tmp, MI_MAX_BLOCK_LENGTH)-length;
+	tmp= MYSQL_MIN(length+tmp, MI_MAX_BLOCK_LENGTH)-length;
 	/* Check if we can extend this block */
 	if (block_info.filepos + block_info.block_len ==
 	    info->state->data_file_length &&
diff -urN mysql-old/storage/myisam/mi_extra.c mysql/storage/myisam/mi_extra.c
--- mysql-old/storage/myisam/mi_extra.c	2009-12-10 00:54:18.718800573 -0100
+++ mysql/storage/myisam/mi_extra.c	2009-12-10 00:57:23.443925275 -0100
@@ -99,7 +99,7 @@
       cache_size= (extra_arg ? *(ulong*) extra_arg :
 		   my_default_record_cache_size);
       if (!(init_io_cache(&info->rec_cache,info->dfile,
-			 (uint) min(info->state->data_file_length+1,
+			 (uint) MYSQL_MIN(info->state->data_file_length+1,
 				    cache_size),
 			  READ_CACHE,0L,(pbool) (info->lock_type != F_UNLCK),
 			  MYF(share->write_flag & MY_WAIT_IF_FULL))))
diff -urN mysql-old/storage/myisam/mi_open.c mysql/storage/myisam/mi_open.c
--- mysql-old/storage/myisam/mi_open.c	2009-12-10 00:54:18.718800573 -0100
+++ mysql/storage/myisam/mi_open.c	2009-12-10 00:57:23.444798045 -0100
@@ -328,7 +328,7 @@
     strmov(share->index_file_name,  index_name);
     strmov(share->data_file_name,   data_name);
 
-    share->blocksize=min(IO_SIZE,myisam_block_size);
+    share->blocksize=MYSQL_MIN(IO_SIZE,myisam_block_size);
     {
       HA_KEYSEG *pos=share->keyparts;
       uint32 ftkey_nr= 1;
@@ -501,7 +501,7 @@
     share->base.margin_key_file_length=(share->base.max_key_file_length -
 					(keys ? MI_INDEX_BLOCK_MARGIN *
 					 share->blocksize * keys : 0));
-    share->blocksize=min(IO_SIZE,myisam_block_size);
+    share->blocksize=MYSQL_MIN(IO_SIZE,myisam_block_size);
     share->data_file_type=STATIC_RECORD;
     if (share->options & HA_OPTION_COMPRESS_RECORD)
     {
@@ -711,10 +711,10 @@
     if (length == (ulong) -1)
     {
       if (info->s->options & HA_OPTION_COMPRESS_RECORD)
-        length= max(info->s->base.pack_reclength, info->s->max_pack_length);
+        length= MYSQL_MAX(info->s->base.pack_reclength, info->s->max_pack_length);
       else
         length= info->s->base.pack_reclength;
-      length= max(length, info->s->base.max_key_length);
+      length= MYSQL_MAX(length, info->s->base.max_key_length);
       /* Avoid unnecessary realloc */
       if (newptr && length == old_length)
 	return newptr;
diff -urN mysql-old/storage/myisam/mi_packrec.c mysql/storage/myisam/mi_packrec.c
--- mysql-old/storage/myisam/mi_packrec.c	2009-12-10 00:54:18.717800958 -0100
+++ mysql/storage/myisam/mi_packrec.c	2009-12-10 00:57:23.445902843 -0100
@@ -684,7 +684,7 @@
       return OFFSET_TABLE_SIZE;
     }
     length2= find_longest_bitstream(next, end) + 1;
-    length=max(length,length2);
+    length=MYSQL_MAX(length,length2);
   }
   return length;
 }
@@ -1399,7 +1399,7 @@
   info->filepos=filepos+head_length;
   if (file > 0)
   {
-    info->offset=min(info->rec_len, ref_length - head_length);
+    info->offset=MYSQL_MIN(info->rec_len, ref_length - head_length);
     memcpy(*rec_buff_p, header + head_length, info->offset);
   }
   return 0;
diff -urN mysql-old/storage/myisam/mi_test1.c mysql/storage/myisam/mi_test1.c
--- mysql-old/storage/myisam/mi_test1.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/mi_test1.c	2009-12-10 00:57:23.446924995 -0100
@@ -435,7 +435,7 @@
     uint tmp;
     uchar *ptr;;
     sprintf((char*) blob_record,"... row: %d", rownr);
-    strappend((char*) blob_record,max(MAX_REC_LENGTH-rownr,10),' ');
+    strappend((char*) blob_record,MYSQL_MAX(MAX_REC_LENGTH-rownr,10),' ');
     tmp=strlen((char*) blob_record);
     int4store(pos,tmp);
     ptr=blob_record;
diff -urN mysql-old/storage/myisam/mi_test2.c mysql/storage/myisam/mi_test2.c
--- mysql-old/storage/myisam/mi_test2.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/mi_test2.c	2009-12-10 00:57:23.447736213 -0100
@@ -601,7 +601,7 @@
     goto err;
 
   bmove(read_record2,read_record,reclength);
-  for (i=min(2,keys) ; i-- > 0 ;)
+  for (i=MYSQL_MIN(2,keys) ; i-- > 0 ;)
   {
     if (mi_rsame(file,read_record2,(int) i)) goto err;
     if (bcmp(read_record,read_record2,reclength) != 0)
diff -urN mysql-old/storage/myisam/myisamlog.c mysql/storage/myisam/myisamlog.c
--- mysql-old/storage/myisam/myisamlog.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/myisamlog.c	2009-12-10 00:57:23.448597030 -0100
@@ -90,7 +90,7 @@
   log_filename=myisam_log_filename;
   get_options(&argc,&argv);
   /* Number of MyISAM files we can have open at one time */
-  max_files= (my_set_max_open_files(min(max_files,8))-6)/2;
+  max_files= (my_set_max_open_files(MYSQL_MIN(max_files,8))-6)/2;
   if (update)
     printf("Trying to %s MyISAM files according to log '%s'\n",
 	   (recover ? "recover" : "update"),log_filename);
diff -urN mysql-old/storage/myisam/myisampack.c mysql/storage/myisam/myisampack.c
--- mysql-old/storage/myisam/myisampack.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/myisampack.c	2009-12-10 00:57:23.449833524 -0100
@@ -31,6 +31,7 @@
 #endif
 #include <my_getopt.h>
 #include <assert.h>
+#include "my_global.h"
 
 #if SIZEOF_LONG_LONG > 4
 #define BITS_SAVED 64
@@ -1239,7 +1240,7 @@
     {
       if (huff_counts->field_length > 2 &&
 	  huff_counts->empty_fields + (records - huff_counts->empty_fields)*
-	  (1+max_bit(max(huff_counts->max_pre_space,
+	  (1+max_bit(MYSQL_MAX(huff_counts->max_pre_space,
 			 huff_counts->max_end_space))) <
 	  records * max_bit(huff_counts->field_length))
       {
@@ -3001,7 +3002,7 @@
   if (mrg->src_file_has_indexes_disabled)
   {
     isam_file->s->state.state.key_file_length=
-      max(isam_file->s->state.state.key_file_length, new_length);
+      MYSQL_MAX(isam_file->s->state.state.key_file_length, new_length);
   }
   state.dellink= HA_OFFSET_ERROR;
   state.version=(ulong) time((time_t*) 0);
diff -urN mysql-old/storage/myisam/rt_mbr.c mysql/storage/myisam/rt_mbr.c
--- mysql-old/storage/myisam/rt_mbr.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/rt_mbr.c	2009-12-10 00:57:23.450925321 -0100
@@ -14,6 +14,7 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
 
 #include "myisamdef.h"
+#include "my_global.h"
 
 #ifdef HAVE_RTREE_KEYS
 
@@ -325,8 +326,8 @@
   bmin = korr_func(b); \
   amax = korr_func(a+len); \
   bmax = korr_func(b+len); \
-  amin = min(amin, bmin); \
-  amax = max(amax, bmax); \
+  amin = MYSQL_MIN(amin, bmin); \
+  amax = MYSQL_MAX(amax, bmax); \
   store_func(c, amin); \
   store_func(c+len, amax); \
 }
@@ -338,8 +339,8 @@
   get_func(bmin, b); \
   get_func(amax, a+len); \
   get_func(bmax, b+len); \
-  amin = min(amin, bmin); \
-  amax = max(amax, bmax); \
+  amin = MYSQL_MIN(amin, bmin); \
+  amax = MYSQL_MAX(amax, bmax); \
   store_func(c, amin); \
   store_func(c+len, amax); \
 }
@@ -417,8 +418,8 @@
   bmin = korr_func(b); \
   amax = korr_func(a+len); \
   bmax = korr_func(b+len); \
-  amin = max(amin, bmin); \
-  amax = min(amax, bmax); \
+  amin = MYSQL_MAX(amin, bmin); \
+  amax = MYSQL_MIN(amax, bmax); \
   if (amin >= amax) \
     return 0; \
   res *= amax - amin; \
@@ -431,8 +432,8 @@
   get_func(bmin, b); \
   get_func(amax, a+len); \
   get_func(bmax, b+len); \
-  amin = max(amin, bmin); \
-  amax = min(amax, bmax); \
+  amin = MYSQL_MAX(amin, bmin); \
+  amax = MYSQL_MIN(amax, bmax); \
   if (amin >= amax)  \
     return 0; \
   res *= amax - amin; \
@@ -508,7 +509,7 @@
    amax = korr_func(a+len); \
    bmax = korr_func(b+len); \
    a_area *= (((double)amax) - ((double)amin)); \
-   loc_ab_area *= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   loc_ab_area *= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 #define RT_AREA_INC_GET(type, get_func, len)\
@@ -519,7 +520,7 @@
    get_func(amax, a+len); \
    get_func(bmax, b+len); \
    a_area *= (((double)amax) - ((double)amin)); \
-   loc_ab_area *= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   loc_ab_area *= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 /*
@@ -604,7 +605,7 @@
    amax = korr_func(a+len); \
    bmax = korr_func(b+len); \
    a_perim+= (((double)amax) - ((double)amin)); \
-   *ab_perim+= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   *ab_perim+= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 #define RT_PERIM_INC_GET(type, get_func, len)\
@@ -615,7 +616,7 @@
    get_func(amax, a+len); \
    get_func(bmax, b+len); \
    a_perim+= (((double)amax) - ((double)amin)); \
-   *ab_perim+= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   *ab_perim+= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 /*
diff -urN mysql-old/storage/myisam/sort.c mysql/storage/myisam/sort.c
--- mysql-old/storage/myisam/sort.c	2009-12-10 00:54:18.716800276 -0100
+++ mysql/storage/myisam/sort.c	2009-12-10 00:57:23.451743818 -0100
@@ -131,7 +131,7 @@
   sort_keys= (uchar **) NULL; error= 1;
   maxbuffer=1;
 
-  memavl=max(sortbuff_size,MIN_SORT_MEMORY);
+  memavl=MYSQL_MAX(sortbuff_size,MIN_SORT_MEMORY);
   records=	info->sort_info->max_records;
   sort_length=	info->key_length;
   LINT_INIT(keys);
@@ -348,7 +348,7 @@
     bzero((char*) &sort_param->unique,  sizeof(sort_param->unique));
     sort_keys= (uchar **) NULL;
 
-    memavl=       max(sort_param->sortbuff_size, MIN_SORT_MEMORY);
+    memavl=       MYSQL_MAX(sort_param->sortbuff_size, MIN_SORT_MEMORY);
     idx=          (uint)sort_param->sort_info->max_records;
     sort_length=  sort_param->key_length;
     maxbuffer=    1;
@@ -813,7 +813,7 @@
   register uint count;
   uint length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(uchar*) buffpek->base,
                  (length= sort_length*count),buffpek->file_pos,MYF_RW))
@@ -834,7 +834,7 @@
   uint idx;
   uchar *buffp;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     buffp = buffpek->base;
 
diff -urN mysql-old/storage/myisammrg/ha_myisammrg.cc mysql/storage/myisammrg/ha_myisammrg.cc
--- mysql-old/storage/myisammrg/ha_myisammrg.cc	2009-12-10 00:54:18.715800244 -0100
+++ mysql/storage/myisammrg/ha_myisammrg.cc	2009-12-10 00:57:23.452925312 -0100
@@ -930,7 +930,7 @@
       memcpy((char*) table->key_info[0].rec_per_key,
 	     (char*) mrg_info.rec_per_key,
              sizeof(table->key_info[0].rec_per_key[0]) *
-             min(file->keys, table->s->key_parts));
+             MYSQL_MIN(file->keys, table->s->key_parts));
     }
   }
   if (flag & HA_STATUS_ERRKEY)
diff -urN mysql-old/storage/ndb/src/common/portlib/NdbTCP.cpp mysql/storage/ndb/src/common/portlib/NdbTCP.cpp
--- mysql-old/storage/ndb/src/common/portlib/NdbTCP.cpp	2009-12-10 00:54:18.713799851 -0100
+++ mysql/storage/ndb/src/common/portlib/NdbTCP.cpp	2009-12-10 00:57:23.453925275 -0100
@@ -30,7 +30,7 @@
 			    &tmp_errno);
     if (hp)
     {
-      memcpy(dst, hp->h_addr, min(sizeof(*dst), (size_t) hp->h_length));
+      memcpy(dst, hp->h_addr, MYSQL_MIN(sizeof(*dst), (size_t) hp->h_length));
       my_gethostbyname_r_free();
       return 0; //DBUG_RETURN(0);
     }
diff -urN mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp
--- mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp	2009-12-10 00:54:18.702801233 -0100
+++ mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp	2009-12-10 00:57:23.454888653 -0100
@@ -54,7 +54,7 @@
         ndbrequire(ah(entryData).getAttributeId() == descAttr.m_primaryAttrId);
         // sizes
         const unsigned size1 = ah(searchKey).getDataSize();
-        const unsigned size2 = min(ah(entryData).getDataSize(), len2);
+        const unsigned size2 = MYSQL_MIN(ah(entryData).getDataSize(), len2);
         len2 -= size2;
         // compare
         NdbSqlUtil::Cmp* const cmp = c_sqlCmp[start];
@@ -139,7 +139,7 @@
         ndbrequire(ah(entryData).getAttributeId() == descAttr.m_primaryAttrId);
         // sizes
         const unsigned size1 = ah(boundInfo).getDataSize();
-        const unsigned size2 = min(ah(entryData).getDataSize(), len2);
+        const unsigned size2 = MYSQL_MIN(ah(entryData).getDataSize(), len2);
         len2 -= size2;
         // compare
         NdbSqlUtil::Cmp* const cmp = c_sqlCmp[index];
diff -urN mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp
--- mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp	2009-12-10 00:54:18.702801233 -0100
+++ mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp	2009-12-10 00:57:23.454888653 -0100
@@ -212,7 +212,7 @@
     }
   }
   // return values
-  par.m_depth = 1 + max(cpar[0].m_depth, cpar[1].m_depth);
+  par.m_depth = 1 + MYSQL_MAX(cpar[0].m_depth, cpar[1].m_depth);
   par.m_occup = node.getOccup();
   for (unsigned i = 0; i <= 1; i++) {
     if (node.getLink(i) == NullTupLoc)
diff -urN mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp
--- mysql-old/storage/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp	2009-12-10 00:54:18.702801233 -0100
+++ mysql/storage/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp	2009-12-10 00:57:23.455625758 -0100
@@ -260,7 +260,7 @@
   selectNode(leafNode, leafLoc);
   if (semiNode.getOccup() < tree.m_minOccup) {
     jam();
-    unsigned cnt = min(leafNode.getOccup(), tree.m_minOccup - semiNode.getOccup());
+    unsigned cnt = MYSQL_MIN(leafNode.getOccup(), tree.m_minOccup - semiNode.getOccup());
     nodeSlide(semiNode, leafNode, cnt, i);
     if (leafNode.getOccup() == 0) {
       // remove empty leaf
@@ -290,7 +290,7 @@
       jam();
       if (parentNode.getOccup() < tree.m_minOccup) {
         jam();
-        unsigned cnt = min(leafNode.getOccup(), tree.m_minOccup - parentNode.getOccup());
+        unsigned cnt = MYSQL_MIN(leafNode.getOccup(), tree.m_minOccup - parentNode.getOccup());
         nodeSlide(parentNode, leafNode, cnt, i);
       }
     }
diff -urN mysql-old/storage/ndb/src/ndbapi/NdbBlob.cpp mysql/storage/ndb/src/ndbapi/NdbBlob.cpp
--- mysql-old/storage/ndb/src/ndbapi/NdbBlob.cpp	2009-12-10 00:54:18.698800891 -0100
+++ mysql/storage/ndb/src/ndbapi/NdbBlob.cpp	2009-12-10 00:57:23.456925414 -0100
@@ -1523,7 +1523,7 @@
   }
   // these buffers are always used
   theKeyBuf.alloc(theTable->m_keyLenInWords << 2);
-  thePackKeyBuf.alloc(max(theTable->m_keyLenInWords, theAccessTable->m_keyLenInWords) << 2);
+  thePackKeyBuf.alloc(MYSQL_MAX(theTable->m_keyLenInWords, theAccessTable->m_keyLenInWords) << 2);
   theHeadInlineBuf.alloc(sizeof(Head) + theInlineSize);
   theHead = (Head*)theHeadInlineBuf.data;
   theInlineData = theHeadInlineBuf.data + sizeof(Head);
diff -urN mysql-old/storage/ndb/test/ndbapi/test_event_merge.cpp mysql/storage/ndb/test/ndbapi/test_event_merge.cpp
--- mysql-old/storage/ndb/test/ndbapi/test_event_merge.cpp	2009-12-10 00:54:18.691800845 -0100
+++ mysql/storage/ndb/test/ndbapi/test_event_merge.cpp	2009-12-10 00:57:23.457924960 -0100
@@ -23,8 +23,8 @@
 // version >= 5.1 required
 
 #if !defined(min) || !defined(max)
-#define min(x, y) ((x) < (y) ? (x) : (y))
-#define max(x, y) ((x) > (y) ? (x) : (y))
+#define MYSQL_MIN(x, y) ((x) < (y) ? (x) : (y))
+#define MYSQL_MAX(x, y) ((x) > (y) ? (x) : (y))
 #endif
 
 /*
diff -urN mysql-old/storage/ndb/test/ndbapi/testIndexStat.cpp mysql/storage/ndb/test/ndbapi/testIndexStat.cpp
--- mysql-old/storage/ndb/test/ndbapi/testIndexStat.cpp	2009-12-10 00:54:18.692800942 -0100
+++ mysql/storage/ndb/test/ndbapi/testIndexStat.cpp	2009-12-10 00:57:23.459722163 -0100
@@ -32,8 +32,8 @@
 
 #undef min
 #undef max
-#define min(a, b) ((a) <= (b) ? (a) : (b))
-#define max(a, b) ((a) >= (b) ? (a) : (b))
+#define MYSQL_MIN(a, b) ((a) <= (b) ? (a) : (b))
+#define MYSQL_MAX(a, b) ((a) >= (b) ? (a) : (b))
 
 inline NdbOut&
 NdbOut::operator<<(double x)
@@ -784,13 +784,13 @@
 uint
 Range::minattrs() const
 {
-  return min(bnd[0].val.numattrs, bnd[1].val.numattrs);
+  return MYSQL_MIN(bnd[0].val.numattrs, bnd[1].val.numattrs);
 }
 
 uint
 Range::maxattrs() const
 {
-  return max(bnd[0].val.numattrs, bnd[1].val.numattrs);
+  return MYSQL_MAX(bnd[0].val.numattrs, bnd[1].val.numattrs);
 }
 
 int
@@ -856,8 +856,8 @@
       lim[i] = lo;
   }
   // the range
-  const int lo = max(lim[0], 0);
-  const int hi = min(lim[1], (int)g_sortcount - 1);
+  const int lo = MYSQL_MAX(lim[0], 0);
+  const int hi = MYSQL_MIN(lim[1], (int)g_sortcount - 1);
   if (! g_opts.nochecks) {
     int curr = -1;
     for (i = 0; i < (int)g_sortcount; i++) {
diff -urN mysql-old/storage/ndb/test/src/getarg.c mysql/storage/ndb/test/src/getarg.c
--- mysql-old/storage/ndb/test/src/getarg.c	2009-12-10 00:54:18.695800160 -0100
+++ mysql/storage/ndb/test/src/getarg.c	2009-12-10 00:57:23.459722163 -0100
@@ -66,7 +66,7 @@
 #define ISFLAG(X) ((X).type == arg_flag || (X).type == arg_negative_flag)
 
 #ifndef max
-#define max(a, b) (a) > (b) ? (a) : (b)
+#define MYSQL_MAX(a, b) (a) > (b) ? (a) : (b)
 #endif
 
 #ifdef HAVE___PROGNAME
@@ -306,7 +306,7 @@
 	}
 	if (args[i].long_name && args[i].short_name)
 	    len += 2; /* ", " */
-	max_len = max(max_len, len);
+	max_len = MYSQL_MAX(max_len, len);
     }
     if (extra_string) {
 	col = check_column(stderr, col, strlen(extra_string) + 1, columns);
diff -urN mysql-old/strings/ctype-big5.c mysql/strings/ctype-big5.c
--- mysql-old/strings/ctype-big5.c	2009-12-10 00:54:18.758802123 -0100
+++ mysql/strings/ctype-big5.c	2009-12-10 00:57:23.462925882 -0100
@@ -253,7 +253,7 @@
                              const uchar *b, size_t b_length,
                              my_bool b_is_prefix)
 {
-  size_t length= min(a_length, b_length);
+  size_t length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_big5_internal(&a, &b, length);
   return res ? res : (int)((b_is_prefix ? length : a_length) - b_length);
 }
@@ -266,7 +266,7 @@
 			       const uchar *b, size_t b_length,
                                my_bool diff_if_only_endspace_difference)
 {
-  size_t length= min(a_length, b_length);
+  size_t length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_big5_internal(&a, &b, length);
 
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
diff -urN mysql-old/strings/ctype-bin.c mysql/strings/ctype-bin.c
--- mysql-old/strings/ctype-bin.c	2009-12-10 00:54:18.754801046 -0100
+++ mysql/strings/ctype-bin.c	2009-12-10 00:57:23.466924829 -0100
@@ -80,7 +80,7 @@
                                const uchar *t, size_t tlen,
                                my_bool t_is_prefix)
 {
-  size_t len=min(slen,tlen);
+  size_t len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
@@ -131,7 +131,7 @@
                                  const uchar *t, size_t tlen,
                                  my_bool t_is_prefix)
 {
-  size_t len=min(slen,tlen);
+  size_t len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
@@ -175,7 +175,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
 
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -404,7 +404,7 @@
                               const uchar *src, size_t srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen,srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, 0);
   return dstlen;
@@ -417,7 +417,7 @@
                             const uchar *src, size_t srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen,srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -urN mysql-old/strings/ctype-gbk.c mysql/strings/ctype-gbk.c
--- mysql-old/strings/ctype-gbk.c	2009-12-10 00:54:18.756801544 -0100
+++ mysql/strings/ctype-gbk.c	2009-12-10 00:57:23.470925687 -0100
@@ -2616,7 +2616,7 @@
                      const uchar *b, size_t b_length,
                      my_bool b_is_prefix)
 {
-  size_t length= min(a_length, b_length);
+  size_t length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_gbk_internal(&a, &b, length);
   return res ? res : (int) ((b_is_prefix ? length : a_length) - b_length);
 }
@@ -2627,7 +2627,7 @@
 			      const uchar *b, size_t b_length,
                               my_bool diff_if_only_endspace_difference)
 {
-  size_t length= min(a_length, b_length);
+  size_t length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_gbk_internal(&a, &b, length);
 
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
diff -urN mysql-old/strings/ctype-mb.c mysql/strings/ctype-mb.c
--- mysql-old/strings/ctype-mb.c	2009-12-10 00:54:18.758802123 -0100
+++ mysql/strings/ctype-mb.c	2009-12-10 00:57:23.562756029 -0100
@@ -368,7 +368,7 @@
 				const uchar *t, size_t tlen,
                                 my_bool t_is_prefix)
 {
-  size_t len=min(slen,tlen);
+  size_t len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int) ((t_is_prefix ? len : slen) - tlen);
 }
@@ -412,7 +412,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
   
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -451,7 +451,7 @@
                                  const uchar *src, size_t srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen, srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen, srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -urN mysql-old/strings/ctype-simple.c mysql/strings/ctype-simple.c
--- mysql-old/strings/ctype-simple.c	2009-12-10 00:54:18.758802123 -0100
+++ mysql/strings/ctype-simple.c	2009-12-10 00:57:23.563925061 -0100
@@ -159,7 +159,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
 
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (map[*a++] != map[*b++])
@@ -873,7 +873,7 @@
     val= new_val;
   }
   
-  len= min(len, (size_t) (e-p));
+  len= MYSQL_MIN(len, (size_t) (e-p));
   memcpy(dst, p, len);
   return len+sign;
 }
@@ -927,7 +927,7 @@
     long_val= quo;
   }
   
-  len= min(len, (size_t) (e-p));
+  len= MYSQL_MIN(len, (size_t) (e-p));
 cnv:
   memcpy(dst, p, len);
   return len+sign;
@@ -1158,7 +1158,7 @@
 {
   size_t nbytes= (size_t) (end-start);
   *error= 0;
-  return min(nbytes, nchars);
+  return MYSQL_MIN(nbytes, nchars);
 }
 
 
diff -urN mysql-old/strings/ctype-tis620.c mysql/strings/ctype-tis620.c
--- mysql-old/strings/ctype-tis620.c	2009-12-10 00:54:18.755801042 -0100
+++ mysql/strings/ctype-tis620.c	2009-12-10 00:57:23.564925210 -0100
@@ -581,7 +581,7 @@
   a_length= thai2sortable(a, a_length);
   b_length= thai2sortable(b, b_length);
   
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -638,7 +638,7 @@
                           const uchar *src, size_t srclen)
 {
   size_t dstlen= len;
-  len= (size_t) (strmake((char*) dest, (char*) src, min(len, srclen)) -
+  len= (size_t) (strmake((char*) dest, (char*) src, MYSQL_MIN(len, srclen)) -
                  (char*) dest);
   len= thai2sortable(dest, len);
   if (dstlen > len)
diff -urN mysql-old/strings/ctype-uca.c mysql/strings/ctype-uca.c
--- mysql-old/strings/ctype-uca.c	2009-12-10 00:54:18.755801042 -0100
+++ mysql/strings/ctype-uca.c	2009-12-10 00:57:23.567925139 -0100
@@ -7567,7 +7567,7 @@
 {
   char tail[30];
   size_t len= lexem->end - lexem->prev;
-  strmake (tail, lexem->prev, (size_t) min(len, sizeof(tail)-1));
+  strmake (tail, lexem->prev, (size_t) MYSQL_MIN(len, sizeof(tail)-1));
   errstr[errsize-1]= '\0';
   my_snprintf(errstr,errsize-1,"%s at '%s'", txt, tail);
 }
diff -urN mysql-old/strings/ctype-ucs2.c mysql/strings/ctype-ucs2.c
--- mysql-old/strings/ctype-ucs2.c	2009-12-10 00:54:18.755801042 -0100
+++ mysql/strings/ctype-ucs2.c	2009-12-10 00:57:23.573924782 -0100
@@ -279,7 +279,7 @@
   se= s + slen;
   te= t + tlen;
 
-  for (minlen= min(slen, tlen); minlen; minlen-= 2)
+  for (minlen= MYSQL_MIN(slen, tlen); minlen; minlen-= 2)
   {
     int s_wc = uni_plane[s[0]] ? (int) uni_plane[s[0]][s[1]].sort :
                                  (((int) s[0]) << 8) + (int) s[1];
@@ -1331,7 +1331,7 @@
   size_t nbytes= ((size_t) (e-b)) & ~(size_t) 1;
   *error= 0;
   nchars*= 2;
-  return min(nbytes, nchars);
+  return MYSQL_MIN(nbytes, nchars);
 }
 
 
@@ -1425,7 +1425,7 @@
   se= s + slen;
   te= t + tlen;
 
-  for (minlen= min(slen, tlen); minlen; minlen-= 2)
+  for (minlen= MYSQL_MIN(slen, tlen); minlen; minlen-= 2)
   {
     int s_wc= s[0] * 256 + s[1];
     int t_wc= t[0] * 256 + t[1];
@@ -1472,7 +1472,7 @@
                             const uchar *src, size_t srclen)
 {
   if (dst != src)
-    memcpy(dst,src,srclen= min(dstlen,srclen));
+    memcpy(dst,src,srclen= MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     cs->cset->fill(cs, (char*) dst + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -urN mysql-old/strings/ctype-utf8.c mysql/strings/ctype-utf8.c
--- mysql-old/strings/ctype-utf8.c	2009-12-10 00:54:18.755801042 -0100
+++ mysql/strings/ctype-utf8.c	2009-12-10 00:57:23.575774954 -0100
@@ -1937,7 +1937,7 @@
                          const uchar *t, const uchar *te)
 {
   int slen= (int) (se-s), tlen= (int) (te-t);
-  int len=min(slen,tlen);
+  int len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : slen-tlen;
 }
diff -urN mysql-old/strings/decimal.c mysql/strings/decimal.c
--- mysql-old/strings/decimal.c	2009-12-10 00:54:18.754801046 -0100
+++ mysql/strings/decimal.c	2009-12-10 01:09:06.977551298 -0100
@@ -403,7 +403,7 @@
     for (; frac>0; frac-=DIG_PER_DEC1)
     {
       dec1 x=*buf++;
-      for (i=min(frac, DIG_PER_DEC1); i; i--)
+      for (i=MYSQL_MIN(frac, DIG_PER_DEC1); i; i--)
       {
         dec1 y=x/DIG_MASK;
         *s1++='0'+(uchar)y;
@@ -426,7 +426,7 @@
     for (buf=buf0+ROUND_UP(intg); intg>0; intg-=DIG_PER_DEC1)
     {
       dec1 x=*--buf;
-      for (i=min(intg, DIG_PER_DEC1); i; i--)
+      for (i=MYSQL_MIN(intg, DIG_PER_DEC1); i; i--)
       {
         dec1 y=x/10;
         *--s='0'+(uchar)(x-y*10);
@@ -1517,8 +1517,8 @@
 
   if (to != from || intg1>intg0)
   {
-    dec1 *p0= buf0+intg0+max(frac1, frac0);
-    dec1 *p1= buf1+intg1+max(frac1, frac0);
+    dec1 *p0= buf0+intg0+MYSQL_MAX(frac1, frac0);
+    dec1 *p1= buf1+intg1+MYSQL_MAX(frac1, frac0);
 
     while (buf0 < p0)
       *(--p1) = *(--p0);
@@ -1529,7 +1529,7 @@
     buf0=to->buf;
     buf1=to->buf;
     to->sign=from->sign;
-    to->intg=min(intg0, len)*DIG_PER_DEC1;
+    to->intg=MYSQL_MIN(intg0, len)*DIG_PER_DEC1;
   }
 
   if (frac0 > frac1)
@@ -1631,7 +1631,7 @@
         scale=frac0*DIG_PER_DEC1;
         error=E_DEC_TRUNCATED; /* XXX */
       }
-      for (buf1=to->buf+intg0+max(frac0,0); buf1 > to->buf; buf1--)
+      for (buf1=to->buf+intg0+MYSQL_MAX(frac0,0); buf1 > to->buf; buf1--)
       {
         buf1[0]=buf1[-1];
       }
@@ -1650,7 +1650,7 @@
         /* making 'zero' with the proper scale */
         dec1 *p0= to->buf + frac0 + 1;
         to->intg=1;
-        to->frac= max(scale, 0);
+        to->frac= MYSQL_MAX(scale, 0);
         to->sign= 0;
         for (buf1= to->buf; buf1<p0; buf1++)
           *buf1= 0;
@@ -1699,11 +1699,11 @@
 {
   switch (op) {
   case '-':
-    return ROUND_UP(max(from1->intg, from2->intg)) +
-           ROUND_UP(max(from1->frac, from2->frac));
+    return ROUND_UP(MYSQL_MAX(from1->intg, from2->intg)) +
+           ROUND_UP(MYSQL_MAX(from1->frac, from2->frac));
   case '+':
-    return ROUND_UP(max(from1->intg, from2->intg)+1) +
-           ROUND_UP(max(from1->frac, from2->frac));
+    return ROUND_UP(MYSQL_MAX(from1->intg, from2->intg)+1) +
+           ROUND_UP(MYSQL_MAX(from1->frac, from2->frac));
   case '*':
     return ROUND_UP(from1->intg+from2->intg)+
            ROUND_UP(from1->frac)+ROUND_UP(from2->frac);
@@ -1718,7 +1718,7 @@
 {
   int intg1=ROUND_UP(from1->intg), intg2=ROUND_UP(from2->intg),
       frac1=ROUND_UP(from1->frac), frac2=ROUND_UP(from2->frac),
-      frac0=max(frac1, frac2), intg0=max(intg1, intg2), error;
+      frac0=MYSQL_MAX(frac1, frac2), intg0=MYSQL_MAX(intg1, intg2), error;
   dec1 *buf1, *buf2, *buf0, *stop, *stop2, x, carry;
 
   sanity(to);
@@ -1743,7 +1743,7 @@
   buf0=to->buf+intg0+frac0;
 
   to->sign=from1->sign;
-  to->frac=max(from1->frac, from2->frac);
+  to->frac=MYSQL_MAX(from1->frac, from2->frac);
   to->intg=intg0*DIG_PER_DEC1;
   if (unlikely(error))
   {
@@ -1754,7 +1754,7 @@
     set_if_smaller(intg2, intg0);
   }
 
-  /* part 1 - max(frac) ... min (frac) */
+  /* part 1 - MYSQL_MAX(frac) ... MYSQL_MIN (frac) */
   if (frac1 > frac2)
   {
     buf1=from1->buf+intg1+frac1;
@@ -1772,14 +1772,14 @@
   while (buf1 > stop)
     *--buf0=*--buf1;
 
-  /* part 2 - min(frac) ... min(intg) */
+  /* part 2 - MYSQL_MIN(frac) ... MYSQL_MIN (intg) */
   carry=0;
   while (buf1 > stop2)
   {
     ADD(*--buf0, *--buf1, *--buf2, carry);
   }
 
-  /* part 3 - min(intg) ... max(intg) */
+  /* part 3 - MYSQL_MIN(intg) ... MYSQL_MAX(intg) */
   buf1= intg1 > intg2 ? ((stop=from1->buf)+intg1-intg2) :
                         ((stop=from2->buf)+intg2-intg1) ;
   while (buf1 > stop)
@@ -1800,7 +1800,7 @@
 {
   int intg1=ROUND_UP(from1->intg), intg2=ROUND_UP(from2->intg),
       frac1=ROUND_UP(from1->frac), frac2=ROUND_UP(from2->frac);
-  int frac0=max(frac1, frac2), error;
+  int frac0=MYSQL_MAX(frac1, frac2), error;
   dec1 *buf1, *buf2, *buf0, *stop1, *stop2, *start1, *start2, carry=0;
 
   /* let carry:=1 if from2 > from1 */
@@ -1875,7 +1875,7 @@
   FIX_INTG_FRAC_ERROR(to->len, intg1, frac0, error);
   buf0=to->buf+intg1+frac0;
 
-  to->frac=max(from1->frac, from2->frac);
+  to->frac=MYSQL_MAX(from1->frac, from2->frac);
   to->intg=intg1*DIG_PER_DEC1;
   if (unlikely(error))
   {
@@ -1886,7 +1886,7 @@
   }
   carry=0;
 
-  /* part 1 - max(frac) ... min (frac) */
+  /* part 1 - MYSQL_MAX(frac) ... MYSQL_MIN (frac) */
   if (frac1 > frac2)
   {
     buf1=start1+intg1+frac1;
@@ -1910,7 +1910,7 @@
     }
   }
 
-  /* part 2 - min(frac) ... intg2 */
+  /* part 2 - MYSQL_MIN(frac) ... intg2 */
   while (buf2 > start2)
   {
     SUB(*--buf0, *--buf1, *--buf2, carry);
@@ -2174,11 +2174,11 @@
   {
     /* we're calculating N1 % N2.
        The result will have
-         frac=max(frac1, frac2), as for subtraction
+         frac=MYSQL_MAX(frac1, frac2), as for subtraction
          intg=intg2
     */
     to->sign=from1->sign;
-    to->frac=max(from1->frac, from2->frac);
+    to->frac=MYSQL_MAX(from1->frac, from2->frac);
     frac0=0;
   }
   else
@@ -2302,7 +2302,7 @@
     /*
       now the result is in tmp1, it has
         intg=prec1-frac1
-        frac=max(frac1, frac2)=to->frac
+        frac=MYSQL_MAX(frac1, frac2)=to->frac
     */
     if (dcarry)
       *--start1=dcarry;
@@ -2340,7 +2340,7 @@
       }
       DBUG_ASSERT(intg0 <= ROUND_UP(from2->intg));
       stop1=start1+frac0+intg0;
-      to->intg=min(intg0*DIG_PER_DEC1, from2->intg);
+      to->intg=MYSQL_MIN(intg0*DIG_PER_DEC1, from2->intg);
     }
     if (unlikely(intg0+frac0 > to->len))
     {
diff -urN mysql-old/strings/my_vsnprintf.c mysql/strings/my_vsnprintf.c
--- mysql-old/strings/my_vsnprintf.c	2009-12-10 00:54:18.754801046 -0100
+++ mysql/strings/my_vsnprintf.c	2009-12-10 00:57:23.580804504 -0100
@@ -141,7 +141,7 @@
       /* If %#d syntax was used, we have to pre-zero/pre-space the string */
       if (store_start == buff)
       {
-	length= min(length, to_length);
+	length= MYSQL_MIN(length, to_length);
 	if (res_length < length)
 	{
 	  size_t diff= (length- res_length);
diff -urN mysql-old/strings/str2int.c mysql/strings/str2int.c
--- mysql-old/strings/str2int.c	2009-12-10 00:54:18.759801315 -0100
+++ mysql/strings/str2int.c	2009-12-10 00:57:23.580804504 -0100
@@ -82,7 +82,7 @@
       machines all, if +|n| is representable, so is -|n|, but on
       twos complement machines the converse is not true.  So the
       "maximum" representable number has a negative representative.
-      Limit is set to min(-|lower|,-|upper|); this is the "largest"
+      Limit is set to MYSQL_MIN(-|lower|,-|upper|); this is the "largest"
       number we are concerned with.	*/
 
   /*  Calculate Limit using Scale as a scratch variable  */
diff -urN mysql-old/tests/mysql_client_test.c mysql/tests/mysql_client_test.c
--- mysql-old/tests/mysql_client_test.c	2009-12-10 00:54:18.663800317 -0100
+++ mysql/tests/mysql_client_test.c	2009-12-10 00:57:23.584924840 -0100
@@ -587,7 +587,7 @@
     return row_count;
   }
 
-  field_count= min(mysql_num_fields(result), MAX_RES_FIELDS);
+  field_count= MYSQL_MIN(mysql_num_fields(result), MAX_RES_FIELDS);
 
   bzero((char*) buffer, sizeof(buffer));
   bzero((char*) length, sizeof(length));
diff -urN mysql-old/vio/viosocket.c mysql/vio/viosocket.c
--- mysql-old/vio/viosocket.c	2009-12-10 00:54:18.765800829 -0100
+++ mysql/vio/viosocket.c	2009-12-10 00:57:23.590799829 -0100
@@ -69,7 +69,7 @@
 
   if (vio->read_pos < vio->read_end)
   {
-    rc= min((size_t) (vio->read_end - vio->read_pos), size);
+    rc= MYSQL_MIN((size_t) (vio->read_end - vio->read_pos), size);
     memcpy(buf, vio->read_pos, rc);
     vio->read_pos+= rc;
     /*
