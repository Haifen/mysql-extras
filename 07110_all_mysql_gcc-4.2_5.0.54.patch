This patch was made against mysql-5.0.54 

X-Gentoo-Bug: 280843
X-Upstream-Bug: 30866
X-Gentoo-Bug-URL: http://bugs.gentoo.org/show_bug.cgi?id=280843
X-Upstream-Bug-URL: http://bugs.mysql.com/bug.php?id=30866

diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/mysqlbinlog.cc mysql/client/mysqlbinlog.cc
--- mysql.orig/client/mysqlbinlog.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/client/mysqlbinlog.cc	2008-01-15 02:53:13.369209185 -0800
@@ -1374,7 +1374,7 @@
       my_off_t length,tmp;
       for (length= start_position_mot ; length > 0 ; length-=tmp)
       {
-	tmp=min(length,sizeof(buff));
+	tmp=MYSQL_MIN(length,sizeof(buff));
 	if (my_b_read(file, buff, (uint) tmp))
         {
           error= 1;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/mysql.cc mysql/client/mysql.cc
--- mysql.orig/client/mysql.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/client/mysql.cc	2008-01-15 02:53:13.373375497 -0800
@@ -2501,9 +2501,9 @@
   {
     uint length= column_names ? field->name_length : 0;
     if (quick)
-      length=max(length,field->length);
+      length=MYSQL_MAX(length,field->length);
     else
-      length=max(length,field->max_length);
+      length=MYSQL_MAX(length,field->max_length);
     if (length < 4 && !IS_NOT_NULL(field->flags))
       length=4;					// Room for "NULL"
     field->max_length=length;
@@ -2523,7 +2523,7 @@
                                                   field->name,
                                                   field->name + name_length);
       uint display_length= field->max_length + name_length - numcells;
-      tee_fprintf(PAGER, " %-*s |",(int) min(display_length,
+      tee_fprintf(PAGER, " %-*s |",(int) MYSQL_MIN(display_length,
                                             MAX_COLUMN_LENGTH),
                   field->name);
       num_flag[off]= IS_NUM(field->type);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/mysqldump.c mysql/client/mysqldump.c
--- mysql.orig/client/mysqldump.c	2007-12-14 12:43:13.000000000 -0800
+++ mysql/client/mysqldump.c	2008-01-15 02:53:13.376714393 -0800
@@ -780,7 +780,7 @@
                                     &err_ptr, &err_len);
       if (err_len)
       {
-        strmake(buff, err_ptr, min(sizeof(buff), err_len));
+        strmake(buff, err_ptr, MYSQL_MIN(sizeof(buff), err_len));
         fprintf(stderr, "Invalid mode to --compatible: %s\n", buff);
         exit(1);
       }
@@ -3408,7 +3408,7 @@
 
       for (; pos != end && *pos != ','; pos++) ;
       var_len= (uint) (pos - start);
-      strmake(buff, start, min(sizeof(buff), var_len));
+      strmake(buff, start, MYSQL_MIN(sizeof(buff), var_len));
       find= find_type(buff, lib, var_len);
       if (!find)
       {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/mysqltest.c mysql/client/mysqltest.c
--- mysql.orig/client/mysqltest.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/client/mysqltest.c	2008-01-15 02:53:13.380049101 -0800
@@ -4548,9 +4548,9 @@
       }
       else if ((c == '{' &&
                 (!my_strnncoll_simple(charset_info, (const uchar*) "while", 5,
-                                      (uchar*) buf, min(5, p - buf), 0) ||
+                                      (uchar*) buf, MYSQL_MIN(5, p - buf), 0) ||
                  !my_strnncoll_simple(charset_info, (const uchar*) "if", 2,
-                                      (uchar*) buf, min(2, p - buf), 0))))
+                                      (uchar*) buf, MYSQL_MIN(2, p - buf), 0))))
       {
         /* Only if and while commands can be terminated by { */
         *p++= c;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/mysql_upgrade.c mysql/client/mysql_upgrade.c
--- mysql.orig/client/mysql_upgrade.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/client/mysql_upgrade.c	2008-01-15 03:02:22.301332298 -0800
@@ -398,7 +398,7 @@
     mysqlcheck). Thus if path ends in .libs/, step up one directory
     and execute the tools from there
   */
-  path[max((strlen(path)-1), 0)]= 0;   /* Chop off last / */
+  path[MYSQL_MAX((strlen(path)-1), 0)]= 0;   /* Chop off last / */
   if (strncmp(path + dirname_length(path), ".libs", 5) == 0)
   {
     DBUG_PRINT("info", ("Chopping off .libs from '%s'", path));
@@ -501,7 +501,7 @@
   if ((value_end= strchr(value_start, '\n')) == NULL)
     return 1; /* Unexpected result */
 
-  strncpy(value, value_start, min(FN_REFLEN, value_end-value_start));
+  strncpy(value, value_start, MYSQL_MIN(FN_REFLEN, value_end-value_start));
   return 0;
 }
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/client/sql_string.cc mysql/client/sql_string.cc
--- mysql.orig/client/sql_string.cc	2007-12-14 12:42:59.000000000 -0800
+++ mysql/client/sql_string.cc	2008-01-15 02:53:13.383382959 -0800
@@ -662,7 +662,7 @@
 {
   if (Alloced_length < str_length + space_needed)
   {
-    if (realloc(Alloced_length + max(space_needed, grow_by) - 1))
+    if (realloc(Alloced_length + MYSQL_MAX(space_needed, grow_by) - 1))
       return TRUE;
   }
   return FALSE;
@@ -748,7 +748,7 @@
 
 int stringcmp(const String *s,const String *t)
 {
-  uint32 s_len=s->length(),t_len=t->length(),len=min(s_len,t_len);
+  uint32 s_len=s->length(),t_len=t->length(),len=MYSQL_MIN(s_len,t_len);
   int cmp= memcmp(s->ptr(), t->ptr(), len);
   return (cmp) ? cmp : (int) (s_len - t_len);
 }
@@ -765,7 +765,7 @@
   }
   if (to->realloc(from_length))
     return from;				// Actually an error
-  if ((to->str_length=min(from->str_length,from_length)))
+  if ((to->str_length=MYSQL_MIN(from->str_length,from_length)))
     memcpy(to->Ptr,from->Ptr,to->str_length);
   to->str_charset=from->str_charset;
   return to;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/dbug/dbug.c mysql/dbug/dbug.c
--- mysql.orig/dbug/dbug.c	2007-12-14 12:42:59.000000000 -0800
+++ mysql/dbug/dbug.c	2008-01-15 03:18:56.346233975 -0800
@@ -959,7 +959,7 @@
     if (TRACING)
     {
       Indent (state->level + 1);
-      pos= min(max(state->level-stack->sub_level,0)*INDENT,80);
+      pos= MYSQL_MIN(MYSQL_MAX(state->level-stack->sub_level,0)*INDENT,80);
     }
     else
     {
@@ -1381,7 +1381,7 @@
 {
   REGISTER int count;
 
-  indent= max(indent-1-stack->sub_level,0)*INDENT;
+  indent= MYSQL_MAX(indent-1-stack->sub_level,0)*INDENT;
   for (count = 0; count < indent ; count++)
   {
     if ((count % INDENT) == 0)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/extra/yassl/src/ssl.cpp mysql/extra/yassl/src/ssl.cpp
--- mysql.orig/extra/yassl/src/ssl.cpp	2007-12-14 12:42:51.000000000 -0800
+++ mysql/extra/yassl/src/ssl.cpp	2008-01-15 02:53:13.386708995 -0800
@@ -38,6 +38,7 @@
 #include "file.hpp"             // for TaoCrypt Source
 #include "coding.hpp"           // HexDecoder
 #include "helpers.hpp"          // for placement new hack
+#include "my_global.h"
 #include <stdio.h>
 
 #ifdef _WIN32
@@ -113,7 +114,7 @@
                 // use file's salt for key derivation, but not real iv
                 TaoCrypt::Source source(info.iv, info.ivSz);
                 TaoCrypt::HexDecoder dec(source);
-                memcpy(info.iv, source.get_buffer(), min((uint)sizeof(info.iv),
+                memcpy(info.iv, source.get_buffer(), MYSQL_MIN((uint)sizeof(info.iv),
                                                          source.size()));
                 EVP_BytesToKey(info.name, "MD5", info.iv, (byte*)password,
                                passwordSz, 1, key, iv);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/extra/yassl/taocrypt/src/dh.cpp mysql/extra/yassl/taocrypt/src/dh.cpp
--- mysql.orig/extra/yassl/taocrypt/src/dh.cpp	2007-12-14 12:43:00.000000000 -0800
+++ mysql/extra/yassl/taocrypt/src/dh.cpp	2008-01-15 02:53:13.386708995 -0800
@@ -23,6 +23,7 @@
 #include "runtime.hpp"
 #include "dh.hpp"
 #include "asn.hpp"
+#include "my_global.h"
 #include <math.h>
 
 namespace TaoCrypt {
@@ -54,7 +55,7 @@
 // Generate private value
 void DH::GeneratePrivate(RandomNumberGenerator& rng, byte* priv)
 {
-    Integer x(rng, Integer::One(), min(p_ - 1,
+    Integer x(rng, Integer::One(), MYSQL_MIN(p_ - 1,
         Integer::Power2(2*DiscreteLogWorkFactor(p_.BitCount())) ) );
     x.Encode(priv, p_.ByteCount());
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/include/my_global.h mysql/include/my_global.h
--- mysql.orig/include/my_global.h	2007-12-14 12:43:42.000000000 -0800
+++ mysql/include/my_global.h	2008-01-15 02:53:13.386708995 -0800
@@ -462,10 +462,8 @@
 #endif
 
 /* Define some useful general macros */
-#if !defined(max)
-#define max(a, b)	((a) > (b) ? (a) : (b))
-#define min(a, b)	((a) < (b) ? (a) : (b))
-#endif
+#define MYSQL_MAX(a, b)	((a) > (b) ? (a) : (b))
+#define MYSQL_MIN(a, b)	((a) < (b) ? (a) : (b))
 
 #if defined(__EMX__) || !defined(HAVE_UINT)
 #undef HAVE_UINT
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/libmysql/libmysql.c mysql/libmysql/libmysql.c
--- mysql.orig/libmysql/libmysql.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysql/libmysql.c	2008-01-15 02:53:13.390042231 -0800
@@ -1558,7 +1558,7 @@
   my_net_set_read_timeout(net, CLIENT_NET_READ_TIMEOUT);
   my_net_set_write_timeout(net, CLIENT_NET_WRITE_TIMEOUT);
   net->retry_count=  1;
-  net->max_packet_size= max(net_buffer_length, max_allowed_packet);
+  net->max_packet_size= MYSQL_MAX(net_buffer_length, max_allowed_packet);
 }
 
 /*
@@ -3562,7 +3562,7 @@
       copy_length= end - start;
       /* We've got some data beyond offset: copy up to buffer_length bytes */
       if (param->buffer_length)
-        memcpy(buffer, start, min(copy_length, param->buffer_length));
+        memcpy(buffer, start, MYSQL_MIN(copy_length, param->buffer_length));
     }
     else
       copy_length= 0;
@@ -3794,9 +3794,9 @@
         precisions. This will ensure that on the same machine you get the
         same value as a string independent of the protocol you use.
       */
-      sprintf(buff, "%-*.*g", (int) min(sizeof(buff)-1,
+      sprintf(buff, "%-*.*g", (int) MYSQL_MIN(sizeof(buff)-1,
                                         param->buffer_length),
-	      min(14,width), value);
+	      MYSQL_MIN(14,width), value);
       end= strcend(buff, ' ');
       *end= 0;
     }
@@ -4113,7 +4113,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   *param->length= length;
   *param->error= copy_length < length;
@@ -4125,7 +4125,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   /* Add an end null if there is room in the buffer */
   if (copy_length != param->buffer_length)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/libmysqld/lib_sql.cc mysql/libmysqld/lib_sql.cc
--- mysql.orig/libmysqld/lib_sql.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/lib_sql.cc	2008-01-15 02:53:13.393375384 -0800
@@ -792,7 +792,7 @@
     is cleared between substatements, and mysqltest gets confused
   */
   thd->cur_data->embedded_info->warning_count=
-    (thd->spcont ? 0 : min(thd->total_warn_count, 65535));
+    (thd->spcont ? 0 : MYSQL_MIN(thd->total_warn_count, 65535));
 }
 
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/array.c mysql/mysys/array.c
--- mysql.orig/mysys/array.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/mysys/array.c	2008-01-15 02:53:13.393375384 -0800
@@ -45,7 +45,7 @@
   DBUG_ENTER("init_dynamic_array");
   if (!alloc_increment)
   {
-    alloc_increment=max((8192-MALLOC_OVERHEAD)/element_size,16);
+    alloc_increment=MYSQL_MAX((8192-MALLOC_OVERHEAD)/element_size,16);
     if (init_alloc > 8 && alloc_increment > init_alloc * 2)
       alloc_increment=init_alloc*2;
   }
@@ -263,7 +263,7 @@
 
 void freeze_size(DYNAMIC_ARRAY *array)
 {
-  uint elements=max(array->elements,1);
+  uint elements=MYSQL_MAX(array->elements,1);
 
   if (array->buffer && array->max_element != elements)
   {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/default.c mysql/mysys/default.c
--- mysql.orig/mysys/default.c	2007-12-14 12:43:25.000000000 -0800
+++ mysql/mysys/default.c	2008-01-15 03:21:47.211529003 -0800
@@ -732,7 +732,7 @@
       for ( ; my_isspace(&my_charset_latin1,end[-1]) ; end--) ;/* Remove end space */
       end[0]=0;
 
-      strnmov(curr_gr, ptr, min((uint) (end-ptr)+1, 4096));
+      strnmov(curr_gr, ptr, MYSQL_MIN((uint) (end-ptr)+1, 4096));
       continue;
     }
     if (!found_group)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/mf_format.c mysql/mysys/mf_format.c
--- mysql.orig/mysys/mf_format.c	2007-12-14 12:43:15.000000000 -0800
+++ mysql/mysys/mf_format.c	2008-01-15 03:21:32.169043847 -0800
@@ -80,7 +80,7 @@
       return NullS;
     tmp_length=strlength(startpos);
     DBUG_PRINT("error",("dev: '%s'  ext: '%s'  length: %d",dev,ext,length));
-    (void) strmake(to,startpos,min(tmp_length,FN_REFLEN-1));
+    (void) strmake(to,startpos,MYSQL_MIN(tmp_length,FN_REFLEN-1));
   }
   else
   {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/mf_iocache.c mysql/mysys/mf_iocache.c
--- mysql.orig/mysys/mf_iocache.c	2007-12-14 12:43:25.000000000 -0800
+++ mysql/mysys/mf_iocache.c	2008-01-15 03:21:21.279059069 -0800
@@ -1090,7 +1090,7 @@
   */
   while (write_length)
   {
-    uint copy_length= min(write_length, write_cache->buffer_length);
+    uint copy_length= MYSQL_MIN(write_length, write_cache->buffer_length);
     int  __attribute__((unused)) rc;
 
     rc= lock_io_cache(write_cache, write_cache->pos_in_file);
@@ -1250,7 +1250,7 @@
       TODO: figure out if the assert below is needed or correct.
     */
     DBUG_ASSERT(pos_in_file == info->end_of_file);
-    copy_len=min(Count, len_in_buff);
+    copy_len=MYSQL_MIN(Count, len_in_buff);
     memcpy(Buffer, info->append_read_pos, copy_len);
     info->append_read_pos += copy_len;
     Count -= copy_len;
@@ -1358,7 +1358,7 @@
     }
 #endif
 	/* Copy found bytes to buffer */
-    length=min(Count,read_length);
+    length=MYSQL_MIN(Count,read_length);
     memcpy(Buffer,info->read_pos,(size_t) length);
     Buffer+=length;
     Count-=length;
@@ -1392,7 +1392,7 @@
       if ((read_length=my_read(info->file,info->request_pos,
 			       read_length, info->myflags)) == (uint) -1)
         return info->error= -1;
-      use_length=min(Count,read_length);
+      use_length=MYSQL_MIN(Count,read_length);
       memcpy(Buffer,info->request_pos,(size_t) use_length);
       info->read_pos=info->request_pos+Count;
       info->read_end=info->request_pos+read_length;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/my_alloc.c mysql/mysys/my_alloc.c
--- mysql.orig/mysys/my_alloc.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/mysys/my_alloc.c	2008-01-15 03:21:10.692646904 -0800
@@ -196,7 +196,7 @@
   {						/* Time to alloc new block */
     block_size= mem_root->block_size * (mem_root->block_num >> 2);
     get_size= Size+ALIGN_SIZE(sizeof(USED_MEM));
-    get_size= max(get_size, block_size);
+    get_size= MYSQL_MAX(get_size, block_size);
 
     if (!(next = (USED_MEM*) my_malloc(get_size,MYF(MY_WME))))
     {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/my_bitmap.c mysql/mysys/my_bitmap.c
--- mysql.orig/mysys/my_bitmap.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/mysys/my_bitmap.c	2008-01-15 03:20:51.573526320 -0800
@@ -321,7 +321,7 @@
   bitmap_lock(map);
   bitmap_lock((MY_BITMAP *)map2);
 
-  end= to+min(len,len2);
+  end= to+MYSQL_MIN(len,len2);
 
   while (to < end)
     *to++ &= *from++;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/my_file.c mysql/mysys/my_file.c
--- mysql.orig/mysys/my_file.c	2007-12-14 12:43:41.000000000 -0800
+++ mysql/mysys/my_file.c	2008-01-15 02:53:13.400041859 -0800
@@ -94,7 +94,7 @@
 static int set_max_open_files(uint max_file_limit)
 {
   /* We don't know the limit. Return best guess */
-  return min(max_file_limit, OS_FILE_LIMIT);
+  return MYSQL_MIN(max_file_limit, OS_FILE_LIMIT);
 }
 #endif
 
@@ -116,7 +116,7 @@
   DBUG_ENTER("my_set_max_open_files");
   DBUG_PRINT("enter",("files: %u  my_file_limit: %u", files, my_file_limit));
 
-  files= set_max_open_files(min(files, OS_FILE_LIMIT));
+  files= set_max_open_files(MYSQL_MIN(files, OS_FILE_LIMIT));
   if (files <= MY_NFILE)
     DBUG_RETURN(files);
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/my_handler.c mysql/mysys/my_handler.c
--- mysql.orig/mysys/my_handler.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/mysys/my_handler.c	2008-01-15 02:53:13.403375075 -0800
@@ -33,7 +33,7 @@
 static int compare_bin(uchar *a, uint a_length, uchar *b, uint b_length,
                        my_bool part_key, my_bool skip_end_space)
 {
-  uint length= min(a_length,b_length);
+  uint length= MYSQL_MIN(a_length,b_length);
   uchar *end= a+ length;
   int flag;
 
@@ -161,7 +161,7 @@
         continue;                               /* To next key part */
       }
     }
-    end= a+ min(keyseg->length,key_length);
+    end= a+ MYSQL_MIN(keyseg->length,key_length);
     next_key_length=key_length-keyseg->length;
 
     switch ((enum ha_base_keytype) keyseg->type) {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/mysys/safemalloc.c mysql/mysys/safemalloc.c
--- mysql.orig/mysys/safemalloc.c	2007-12-14 12:43:51.000000000 -0800
+++ mysql/mysys/safemalloc.c	2008-01-15 03:19:08.615759551 -0800
@@ -237,7 +237,7 @@
 
   if ((data= _mymalloc(size,filename,lineno,MyFlags))) /* Allocate new area */
   {
-    size=min(size, irem->datasize);		/* Move as much as possibly */
+    size=MYSQL_MIN(size, irem->datasize);		/* Move as much as possibly */
     memcpy((byte*) data, ptr, (size_t) size);	/* Copy old data */
     _myfree(ptr, filename, lineno, 0);		/* Free not needed area */
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/server-tools/instance-manager/buffer.cc mysql/server-tools/instance-manager/buffer.cc
--- mysql.orig/server-tools/instance-manager/buffer.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/server-tools/instance-manager/buffer.cc	2008-01-15 03:01:47.733444331 -0800
@@ -83,8 +83,8 @@
   if (position + len_arg >= buffer_size)
   {
     buffer= (char*) my_realloc(buffer,
-                                min(MAX_BUFFER_SIZE,
-                                    max((uint) (buffer_size*1.5),
+                                MYSQL_MIN(MAX_BUFFER_SIZE,
+                                    MYSQL_MAX((uint) (buffer_size*1.5),
                                         position + len_arg)), MYF(0));
     if (!(buffer))
       goto err;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/server-tools/instance-manager/listener.cc mysql/server-tools/instance-manager/listener.cc
--- mysql.orig/server-tools/instance-manager/listener.cc	2007-12-14 12:42:50.000000000 -0800
+++ mysql/server-tools/instance-manager/listener.cc	2008-01-15 02:53:13.406708559 -0800
@@ -140,7 +140,7 @@
 
   /* II. Listen sockets and spawn childs */
   for (i= 0; i < num_sockets; i++)
-    n= max(n, sockets[i]);
+    n= MYSQL_MAX(n, sockets[i]);
   n++;
 
   timeval tv;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/client.c mysql/sql/client.c
--- mysql.orig/sql/client.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/client.c	2008-01-15 02:53:13.406708559 -0800
@@ -630,7 +630,7 @@
 	pos+= SQLSTATE_LENGTH+1;
       }
       (void) strmake(net->last_error,(char*) pos,
-		     min((uint) len,(uint) sizeof(net->last_error)-1));
+		     MYSQL_MIN((uint) len,(uint) sizeof(net->last_error)-1));
     }
     else
       set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
@@ -2026,7 +2026,7 @@
 	goto error;
       }
       memcpy(&sock_addr.sin_addr, hp->h_addr,
-             min(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
+             MYSQL_MIN(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
       my_gethostbyname_r_free();
     }
     sock_addr.sin_port = (ushort) htons((ushort) port);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/field.cc mysql/sql/field.cc
--- mysql.orig/sql/field.cc	2007-12-14 12:42:41.000000000 -0800
+++ mysql/sql/field.cc	2008-01-15 03:18:10.419060594 -0800
@@ -49,7 +49,7 @@
 #define LONGLONG_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define DECIMAL_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define BLOB_PACK_LENGTH_TO_MAX_LENGH(arg) \
-((ulong) ((LL(1) << min(arg, 4) * 8) - LL(1)))
+((ulong) ((LL(1) << MYSQL_MIN(arg, 4) * 8) - LL(1)))
 
 /*
   Rules for merging different types of fields in UNION
@@ -1889,7 +1889,7 @@
     tmp_uint=tmp_dec+(uint)(int_digits_end-int_digits_from);
   else if (expo_sign_char == '-') 
   {
-    tmp_uint=min(exponent,(uint)(int_digits_end-int_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(int_digits_end-int_digits_from));
     frac_digits_added_zeros=exponent-tmp_uint;
     int_digits_end -= tmp_uint;
     frac_digits_head_end=int_digits_end+tmp_uint;
@@ -1897,7 +1897,7 @@
   }
   else // (expo_sign_char=='+') 
   {
-    tmp_uint=min(exponent,(uint)(frac_digits_end-frac_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(frac_digits_end-frac_digits_from));
     int_digits_added_zeros=exponent-tmp_uint;
     int_digits_tail_from=frac_digits_from;
     frac_digits_from=frac_digits_from+tmp_uint;
@@ -2708,7 +2708,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,5*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,5*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
 
@@ -2914,7 +2914,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,7*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,7*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   short j;
@@ -3125,7 +3125,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,10*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,10*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   long j= unsigned_flag ? (long) uint3korr(ptr) : sint3korr(ptr);
@@ -3338,7 +3338,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,12*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,12*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   int32 j;
@@ -3573,7 +3573,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,22*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,22*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   longlong j;
@@ -3750,7 +3750,7 @@
 #endif
     memcpy_fixed((byte*) &nr,ptr,sizeof(nr));
 
-  uint to_length=max(field_length,70);
+  uint to_length=MYSQL_MAX(field_length,70);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -4085,7 +4085,7 @@
 #endif
     doubleget(nr,ptr);
 
-  uint to_length=max(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
+  uint to_length=MYSQL_MAX(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -5968,13 +5968,13 @@
     calculate the maximum number of significant digits if the 'f'-format
     would be used (+1 for decimal point if the number has a fractional part).
   */
-  digits= max(0, (int) max_length - fractional);
+  digits= MYSQL_MAX(0, (int) max_length - fractional);
   /*
     If the exponent is negative, decrease digits by the number of leading zeros
     after the decimal point that do not count as significant digits.
   */
   if (exp < 0)
-    digits= max(0, (int) digits + exp);
+    digits= MYSQL_MAX(0, (int) digits + exp);
   /*
     'e'-format is used only if the exponent is less than -4 or greater than or
     equal to the precision. In this case we need to adjust the number of
@@ -5982,7 +5982,7 @@
     We also have to reserve one additional character if abs(exp) >= 100.
   */
   if (exp >= (int) digits || exp < -4)
-    digits= max(0, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
+    digits= MYSQL_MAX(0, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
 
   /* Limit precision to DBL_DIG to avoid garbage past significant digits */
   set_if_smaller(digits, DBL_DIG);
@@ -6171,7 +6171,7 @@
 
 char *Field_string::pack(char *to, const char *from, uint max_length)
 {
-  uint length=      min(field_length,max_length);
+  uint length=      MYSQL_MIN(field_length,max_length);
   uint local_char_length= max_length/field_charset->mbmaxlen;
   if (length > local_char_length)
     local_char_length= my_charpos(field_charset, from, from+length,
@@ -6997,7 +6997,7 @@
     from= tmpstr.ptr();
   }
 
-  new_length= min(max_data_length(), field_charset->mbmaxlen * length);
+  new_length= MYSQL_MIN(max_data_length(), field_charset->mbmaxlen * length);
   if (value.alloc(new_length))
     goto oom_error;
 
@@ -7142,7 +7142,7 @@
   b_length=get_length(b_ptr);
   if (b_length > max_length)
     b_length=max_length;
-  diff=memcmp(a,b,min(a_length,b_length));
+  diff=memcmp(a,b,MYSQL_MIN(a_length,b_length));
   return diff ? diff : (int) (a_length - b_length);
 }
 
@@ -8148,7 +8148,7 @@
                            String *val_ptr __attribute__((unused)))
 {
   char buff[sizeof(longlong)];
-  uint length= min(pack_length(), sizeof(longlong));
+  uint length= MYSQL_MIN(pack_length(), sizeof(longlong));
   ulonglong bits= val_int();
   mi_int8store(buff,bits);
 
@@ -8204,7 +8204,7 @@
     *buff++= bits;
     length--;
   }
-  uint data_length = min(length, bytes_in_rec);
+  uint data_length = MYSQL_MIN(length, bytes_in_rec);
   memcpy(buff, ptr, data_length);
   return data_length + 1;
 }
@@ -8228,7 +8228,7 @@
     uchar bits= get_rec_bits(bit_ptr, bit_ofs, bit_len);
     *to++= bits;
   }
-  length= min(bytes_in_rec, max_length - (bit_len > 0));
+  length= MYSQL_MIN(bytes_in_rec, max_length - (bit_len > 0));
   memcpy(to, from, length);
   return to + length;
 }
@@ -8606,7 +8606,7 @@
         and 19 as length of 4.1 compatible representation.
       */
       length= ((length+1)/2)*2; /* purecov: inspected */
-      length= min(length, MAX_DATETIME_COMPRESSED_WIDTH); /* purecov: inspected */
+      length= MYSQL_MIN(length, MAX_DATETIME_COMPRESSED_WIDTH); /* purecov: inspected */
     }
     flags|= ZEROFILL_FLAG | UNSIGNED_FLAG;
     if (fld_default_value)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/filesort.cc mysql/sql/filesort.cc
--- mysql.orig/sql/filesort.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql/filesort.cc	2008-01-15 03:17:40.017664193 -0800
@@ -175,7 +175,7 @@
 #ifdef CAN_TRUST_RANGE
   if (select && select->quick && select->quick->records > 0L)
   {
-    records=min((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
+    records=MYSQL_MIN((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
 		table->file->records)+EXTRA_RECORDS;
     selected_records_file=0;
   }
@@ -197,12 +197,12 @@
     goto err;
 
   memavl= thd->variables.sortbuff_size;
-  min_sort_memory= max(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
+  min_sort_memory= MYSQL_MAX(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
   while (memavl >= min_sort_memory)
   {
     ulong old_memavl;
     ulong keys= memavl/(param.rec_length+sizeof(char*));
-    param.keys=(uint) min(records+1, keys);
+    param.keys=(uint) MYSQL_MIN(records+1, keys);
     if ((table_sort.sort_keys=
 	 (uchar **) make_char_array((char **) table_sort.sort_keys,
                                     param.keys, param.rec_length, MYF(0))))
@@ -976,7 +976,7 @@
   register uint count;
   uint length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(byte*) buffpek->base,
 		 (length= rec_length*count),buffpek->file_pos,MYF_RW))
@@ -1239,7 +1239,7 @@
          != -1 && error != 0);
 
 end:
-  lastbuff->count= min(org_max_rows-max_rows, param->max_rows);
+  lastbuff->count= MYSQL_MIN(org_max_rows-max_rows, param->max_rows);
   lastbuff->file_pos= to_start_filepos;
 err:
   delete_queue(&queue);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/ha_ndbcluster.cc mysql/sql/ha_ndbcluster.cc
--- mysql.orig/sql/ha_ndbcluster.cc	2007-12-14 12:42:59.000000000 -0800
+++ mysql/sql/ha_ndbcluster.cc	2008-01-15 03:17:27.770220746 -0800
@@ -741,7 +741,7 @@
 
       DBUG_PRINT("value", ("set blob ptr: %p  len: %u",
                            blob_ptr, blob_len));
-      DBUG_DUMP("value", (char*)blob_ptr, min(blob_len, 26));
+      DBUG_DUMP("value", (char*)blob_ptr, MYSQL_MIN(blob_len, 26));
 
       if (set_blob_value)
         *set_blob_value= TRUE;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/handler.h mysql/sql/handler.h
--- mysql.orig/sql/handler.h	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/handler.h	2008-01-15 02:53:13.426708779 -0800
@@ -863,15 +863,15 @@
   { return (HA_ERR_WRONG_COMMAND); }
 
   uint max_record_length() const
-  { return min(HA_MAX_REC_LENGTH, max_supported_record_length()); }
+  { return MYSQL_MIN(HA_MAX_REC_LENGTH, max_supported_record_length()); }
   uint max_keys() const
-  { return min(MAX_KEY, max_supported_keys()); }
+  { return MYSQL_MIN(MAX_KEY, max_supported_keys()); }
   uint max_key_parts() const
-  { return min(MAX_REF_PARTS, max_supported_key_parts()); }
+  { return MYSQL_MIN(MAX_REF_PARTS, max_supported_key_parts()); }
   uint max_key_length() const
-  { return min(MAX_KEY_LENGTH, max_supported_key_length()); }
+  { return MYSQL_MIN(MAX_KEY_LENGTH, max_supported_key_length()); }
   uint max_key_part_length() const
-  { return min(MAX_KEY_LENGTH, max_supported_key_part_length()); }
+  { return MYSQL_MIN(MAX_KEY_LENGTH, max_supported_key_part_length()); }
 
   virtual uint max_supported_record_length() const { return HA_MAX_REC_LENGTH; }
   virtual uint max_supported_keys() const { return 0; }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_buff.cc mysql/sql/item_buff.cc
--- mysql.orig/sql/item_buff.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/sql/item_buff.cc	2008-01-15 02:53:13.426708779 -0800
@@ -51,7 +51,7 @@
 */
 
 Cached_item_str::Cached_item_str(THD *thd, Item *arg)
-  :item(arg), value(min(arg->max_length, thd->variables.max_sort_length))
+  :item(arg), value(MYSQL_MIN(arg->max_length, thd->variables.max_sort_length))
 {}
 
 bool Cached_item_str::cmp(void)
@@ -60,7 +60,7 @@
   bool tmp;
 
   if ((res=item->val_str(&tmp_value)))
-    res->length(min(res->length(), value.alloced_length()));
+    res->length(MYSQL_MIN(res->length(), value.alloced_length()));
   if (null_value != item->null_value)
   {
     if ((null_value= item->null_value))
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item.cc mysql/sql/item.cc
--- mysql.orig/sql/item.cc	2007-12-14 12:42:41.000000000 -0800
+++ mysql/sql/item.cc	2008-01-15 02:53:13.430041699 -0800
@@ -73,7 +73,7 @@
 Hybrid_type_traits_decimal::fix_length_and_dec(Item *item, Item *arg) const
 {
   item->decimals= arg->decimals;
-  item->max_length= min(arg->max_length + DECIMAL_LONGLONG_DIGITS,
+  item->max_length= MYSQL_MIN(arg->max_length + DECIMAL_LONGLONG_DIGITS,
                         DECIMAL_MAX_STR_LENGTH);
 }
 
@@ -429,9 +429,9 @@
   Item_result restype= result_type();
 
   if ((restype == DECIMAL_RESULT) || (restype == INT_RESULT))
-    return min(my_decimal_length_to_precision(max_length, decimals, unsigned_flag),
+    return MYSQL_MIN(my_decimal_length_to_precision(max_length, decimals, unsigned_flag),
                DECIMAL_MAX_PRECISION);
-  return min(max_length, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(max_length, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -720,7 +720,7 @@
 				   &res_length);
   }
   else
-    name= sql_strmake(str, (name_length= min(length,MAX_ALIAS_NAME)));
+    name= sql_strmake(str, (name_length= MYSQL_MIN(length,MAX_ALIAS_NAME)));
 }
 
 
@@ -4774,7 +4774,7 @@
   // following assert is redundant, because fixed=1 assigned in constructor
   DBUG_ASSERT(fixed == 1);
   char *end=(char*) str_value.ptr()+str_value.length(),
-       *ptr=end-min(str_value.length(),sizeof(longlong));
+       *ptr=end-MYSQL_MIN(str_value.length(),sizeof(longlong));
 
   ulonglong value=0;
   for (; ptr != end ; ptr++)
@@ -6686,12 +6686,12 @@
     /* fix variable decimals which always is NOT_FIXED_DEC */
     if (Field::result_merge_type(fld_type) == INT_RESULT)
       item_decimals= 0;
-    decimals= max(decimals, item_decimals);
+    decimals= MYSQL_MAX(decimals, item_decimals);
   }
   if (Field::result_merge_type(fld_type) == DECIMAL_RESULT)
   {
-    decimals= min(max(decimals, item->decimals), DECIMAL_MAX_SCALE);
-    int precision= min(max(prev_decimal_int_part, item->decimal_int_part())
+    decimals= MYSQL_MIN(MYSQL_MAX(decimals, item->decimals), DECIMAL_MAX_SCALE);
+    int precision= MYSQL_MIN(MYSQL_MAX(prev_decimal_int_part, item->decimal_int_part())
                        + decimals, DECIMAL_MAX_PRECISION);
     unsigned_flag&= item->unsigned_flag;
     max_length= my_decimal_precision_to_length(precision, decimals,
@@ -6722,7 +6722,7 @@
      */
     if (collation.collation != &my_charset_bin)
     {
-      max_length= max(old_max_chars * collation.collation->mbmaxlen,
+      max_length= MYSQL_MAX(old_max_chars * collation.collation->mbmaxlen,
                       display_length(item) /
                       item->collation.collation->mbmaxlen *
                       collation.collation->mbmaxlen);
@@ -6737,7 +6737,7 @@
     {
       int delta1= max_length_orig - decimals_orig;
       int delta2= item->max_length - item->decimals;
-      max_length= max(delta1, delta2) + decimals;
+      max_length= MYSQL_MAX(delta1, delta2) + decimals;
       if (fld_type == MYSQL_TYPE_FLOAT && max_length > FLT_DIG + 2) 
       {
         max_length= FLT_DIG + 6;
@@ -6754,7 +6754,7 @@
     break;
   }
   default:
-    max_length= max(max_length, display_length(item));
+    max_length= MYSQL_MAX(max_length, display_length(item));
   };
   maybe_null|= item->maybe_null;
   get_full_info(item);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_cmpfunc.cc mysql/sql/item_cmpfunc.cc
--- mysql.orig/sql/item_cmpfunc.cc	2007-12-14 12:43:41.000000000 -0800
+++ mysql/sql/item_cmpfunc.cc	2008-01-15 03:17:13.172408641 -0800
@@ -554,7 +554,7 @@
   {
     if ((*a)->decimals < NOT_FIXED_DEC && (*b)->decimals < NOT_FIXED_DEC)
     {
-      precision= 5 / log_10[max((*a)->decimals, (*b)->decimals) + 1];
+      precision= 5 / log_10[MYSQL_MAX((*a)->decimals, (*b)->decimals) + 1];
       if (func == &Arg_comparator::compare_real)
         func= &Arg_comparator::compare_real_fixed;
       else if (func == &Arg_comparator::compare_e_real)
@@ -1039,7 +1039,7 @@
       owner->null_value= 0;
       uint res1_length= res1->length();
       uint res2_length= res2->length();
-      int cmp= memcmp(res1->ptr(), res2->ptr(), min(res1_length,res2_length));
+      int cmp= memcmp(res1->ptr(), res2->ptr(), MYSQL_MIN(res1_length,res2_length));
       return cmp ? cmp : (int) (res1_length - res2_length);
     }
   }
@@ -2062,7 +2062,7 @@
 {
   agg_result_type(&hybrid_type, args, 2);
   maybe_null=args[1]->maybe_null;
-  decimals= max(args[0]->decimals, args[1]->decimals);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
   unsigned_flag= args[0]->unsigned_flag && args[1]->unsigned_flag;
 
   if (hybrid_type == DECIMAL_RESULT || hybrid_type == INT_RESULT) 
@@ -2073,10 +2073,10 @@
     int len1= args[1]->max_length - args[1]->decimals
       - (args[1]->unsigned_flag ? 0 : 1);
 
-    max_length= max(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
+    max_length= MYSQL_MAX(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[0]->max_length, args[1]->max_length);
+    max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 
   switch (hybrid_type) {
   case STRING_RESULT:
@@ -2098,8 +2098,8 @@
 
 uint Item_func_ifnull::decimal_precision() const
 {
-  int max_int_part=max(args[0]->decimal_int_part(),args[1]->decimal_int_part());
-  return min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  int max_int_part=MYSQL_MAX(args[0]->decimal_int_part(),args[1]->decimal_int_part());
+  return MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -2228,7 +2228,7 @@
 Item_func_if::fix_length_and_dec()
 {
   maybe_null=args[1]->maybe_null || args[2]->maybe_null;
-  decimals= max(args[1]->decimals, args[2]->decimals);
+  decimals= MYSQL_MAX(args[1]->decimals, args[2]->decimals);
   unsigned_flag=args[1]->unsigned_flag && args[2]->unsigned_flag;
 
   enum Item_result arg1_type=args[1]->result_type();
@@ -2272,18 +2272,18 @@
     int len2= args[2]->max_length - args[2]->decimals
       - (args[2]->unsigned_flag ? 0 : 1);
 
-    max_length=max(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
+    max_length=MYSQL_MAX(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[1]->max_length, args[2]->max_length);
+    max_length= MYSQL_MAX(args[1]->max_length, args[2]->max_length);
 }
 
 
 uint Item_func_if::decimal_precision() const
 {
-  int precision=(max(args[1]->decimal_int_part(),args[2]->decimal_int_part())+
+  int precision=(MYSQL_MAX(args[1]->decimal_int_part(),args[2]->decimal_int_part())+
                  decimals);
-  return min(precision, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(precision, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -2708,7 +2708,7 @@
 
   if (else_expr_num != -1) 
     set_if_bigger(max_int_part, args[else_expr_num]->decimal_int_part());
-  return min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -4507,7 +4507,7 @@
       else
       {
 	if (i < g)
-	  g = i; // g = min(i, g)
+	  g = i; // g = MYSQL_MIN(i, g)
 	f = i;
 	while (g >= 0 && pattern[g] == pattern[g + plm1 - f])
 	  g--;
@@ -4526,7 +4526,7 @@
       else
       {
 	if (i < g)
-	  g = i; // g = min(i, g)
+	  g = i; // g = MYSQL_MIN(i, g)
 	f = i;
 	while (g >= 0 &&
 	       likeconv(cs, pattern[g]) == likeconv(cs, pattern[g + plm1 - f]))
@@ -4647,14 +4647,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) (uchar) text[i + j]] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
@@ -4678,14 +4678,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) likeconv(cs, text[i + j])] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_func.cc mysql/sql/item_func.cc
--- mysql.orig/sql/item_func.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/sql/item_func.cc	2008-01-15 03:16:19.162403717 -0800
@@ -539,7 +539,7 @@
     set_if_bigger(max_int_part, args[i]->decimal_int_part());
     set_if_smaller(unsigned_flag, args[i]->unsigned_flag);
   }
-  int precision= min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  int precision= MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length(precision, decimals,
                                              unsigned_flag);
 }
@@ -1155,10 +1155,10 @@
 */
 void Item_func_additive_op::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
-  int max_int_part= max(args[0]->decimal_precision() - args[0]->decimals,
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
+  int max_int_part= MYSQL_MAX(args[0]->decimal_precision() - args[0]->decimals,
                         args[1]->decimal_precision() - args[1]->decimals);
-  int precision= min(max_int_part + 1 + decimals, DECIMAL_MAX_PRECISION);
+  int precision= MYSQL_MIN(max_int_part + 1 + decimals, DECIMAL_MAX_PRECISION);
 
   /* Integer operations keep unsigned_flag if one of arguments is unsigned */
   if (result_type() == INT_RESULT)
@@ -1266,8 +1266,8 @@
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
-  int precision= min(args[0]->decimal_precision() + args[1]->decimal_precision(),
+  decimals= MYSQL_MIN(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
+  int precision= MYSQL_MIN(args[0]->decimal_precision() + args[1]->decimal_precision(),
                      DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length(precision, decimals,unsigned_flag);
 }
@@ -1315,14 +1315,14 @@
 
 void Item_func_div::result_precision()
 {
-  uint precision=min(args[0]->decimal_precision() + prec_increment,
+  uint precision=MYSQL_MIN(args[0]->decimal_precision() + prec_increment,
                      DECIMAL_MAX_PRECISION);
   /* Integer operations keep unsigned_flag if one of arguments is unsigned */
   if (result_type() == INT_RESULT)
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+  decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
   max_length= my_decimal_precision_to_length(precision, decimals,
                                              unsigned_flag);
 }
@@ -1336,7 +1336,7 @@
   switch(hybrid_type) {
   case REAL_RESULT:
   {
-    decimals=max(args[0]->decimals,args[1]->decimals)+prec_increment;
+    decimals=MYSQL_MAX(args[0]->decimals,args[1]->decimals)+prec_increment;
     set_if_smaller(decimals, NOT_FIXED_DEC);
     max_length=args[0]->max_length - args[0]->decimals + decimals;
     uint tmp=float_length(decimals);
@@ -1458,8 +1458,8 @@
 
 void Item_func_mod::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
-  max_length= max(args[0]->max_length, args[1]->max_length);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
+  max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 }
 
 
@@ -1977,7 +1977,7 @@
   if (args[0]->decimals == NOT_FIXED_DEC)
   {
     max_length= args[0]->max_length;
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     hybrid_type= REAL_RESULT;
     return;
   }
@@ -1986,7 +1986,7 @@
   case REAL_RESULT:
   case STRING_RESULT:
     hybrid_type= REAL_RESULT;
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     max_length= float_length(decimals);
     break;
   case INT_RESULT:
@@ -2003,7 +2003,7 @@
   case DECIMAL_RESULT:
   {
     hybrid_type= DECIMAL_RESULT;
-    decimals_to_set= min(DECIMAL_MAX_SCALE, decimals_to_set);
+    decimals_to_set= MYSQL_MIN(DECIMAL_MAX_SCALE, decimals_to_set);
     int decimals_delta= args[0]->decimals - decimals_to_set;
     int precision= args[0]->decimal_precision();
     int length_increase= ((decimals_delta <= 0) || truncate) ? 0:1;
@@ -2110,7 +2110,7 @@
   longlong dec= args[1]->val_int();
   if (dec > 0 || (dec < 0 && args[1]->unsigned_flag))
   {
-    dec= min((ulonglong) dec, decimals);
+    dec= MYSQL_MIN((ulonglong) dec, decimals);
     decimals= (uint8) dec; // to get correct output
   }
   else if (dec < INT_MIN)
@@ -2965,7 +2965,7 @@
       free_udf(u_d);
       DBUG_RETURN(TRUE);
     }
-    func->max_length=min(initid.max_length,MAX_BLOB_WIDTH);
+    func->max_length=MYSQL_MIN(initid.max_length,MAX_BLOB_WIDTH);
     func->maybe_null=initid.maybe_null;
     const_item_cache=initid.const_item;
     /* 
@@ -2974,7 +2974,7 @@
     */  
     if (!const_item_cache && !used_tables_cache)
       used_tables_cache= RAND_TABLE_BIT;
-    func->decimals=min(initid.decimals,NOT_FIXED_DEC);
+    func->decimals=MYSQL_MIN(initid.decimals,NOT_FIXED_DEC);
   }
   initialized=1;
   if (error)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_strfunc.cc mysql/sql/item_strfunc.cc
--- mysql.orig/sql/item_strfunc.cc	2007-12-14 12:43:24.000000000 -0800
+++ mysql/sql/item_strfunc.cc	2008-01-15 02:53:13.440042183 -0800
@@ -1138,7 +1138,7 @@
 
   length= res->charpos((int) length, (uint32) start);
   tmp_length= res->length() - start;
-  length= min(length, tmp_length);
+  length= MYSQL_MIN(length, tmp_length);
 
   if (!start && (longlong) res->length() == length)
     return res;
@@ -1158,7 +1158,7 @@
     if (start < 0)
       max_length= ((uint)(-start) > max_length) ? 0 : (uint)(-start);
     else
-      max_length-= min((uint)(start - 1), max_length);
+      max_length-= MYSQL_MIN((uint)(start - 1), max_length);
   }
   if (arg_count == 3 && args[2]->const_item())
   {
@@ -1832,7 +1832,7 @@
   if ((null_value= args[0]->null_value))
     return 0; /* purecov: inspected */
 
-  if (tmp_value.alloc(max(res->length(), 4 * cs->mbminlen)))
+  if (tmp_value.alloc(MYSQL_MAX(res->length(), 4 * cs->mbminlen)))
     return str; /* purecov: inspected */
   char *to= (char *) tmp_value.ptr();
   char *to_end= to + tmp_value.alloced_length();
@@ -2933,11 +2933,11 @@
 
 void Item_func_export_set::fix_length_and_dec()
 {
-  uint length=max(args[1]->max_length,args[2]->max_length);
+  uint length=MYSQL_MAX(args[1]->max_length,args[2]->max_length);
   uint sep_length=(arg_count > 3 ? args[3]->max_length : 1);
   max_length=length*64+sep_length*63;
 
-  if (agg_arg_charsets(collation, args+1, min(4,arg_count)-1,
+  if (agg_arg_charsets(collation, args+1, MYSQL_MIN(4,arg_count)-1,
                        MY_COLL_ALLOW_CONV, 1))
     return;
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_sum.cc mysql/sql/item_sum.cc
--- mysql.orig/sql/item_sum.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/sql/item_sum.cc	2008-01-15 02:53:13.443375111 -0800
@@ -1063,7 +1063,7 @@
     AVG() will divide val by count. We need to reserve digits
     after decimal point as the result can be fractional.
   */
-  decimals= min(decimals + prec_increment, NOT_FIXED_DEC);
+  decimals= MYSQL_MIN(decimals + prec_increment, NOT_FIXED_DEC);
 }
 
 
@@ -1126,15 +1126,15 @@
   if (hybrid_type == DECIMAL_RESULT)
   {
     int precision= args[0]->decimal_precision() + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length(precision, decimals,
                                                unsigned_flag);
-    f_precision= min(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
+    f_precision= MYSQL_MIN(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
     f_scale=  args[0]->decimals;
     dec_bin_size= my_decimal_get_binary_size(f_precision, f_scale);
   }
   else {
-    decimals= min(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
     max_length= args[0]->max_length + prec_increment;
   }
 }
@@ -1313,13 +1313,13 @@
   switch (args[0]->result_type()) {
   case REAL_RESULT:
   case STRING_RESULT:
-    decimals= min(args[0]->decimals + 4, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + 4, NOT_FIXED_DEC);
     break;
   case INT_RESULT:
   case DECIMAL_RESULT:
   {
     int precision= args[0]->decimal_precision()*2 + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length(precision, decimals,
                                                unsigned_flag);
 
@@ -3380,7 +3380,7 @@
       duplicate values (according to the syntax of this function). If there
       is no DISTINCT or ORDER BY clauses, we don't create this tree.
     */
-    init_tree(tree, (uint) min(thd->variables.max_heap_table_size,
+    init_tree(tree, (uint) MYSQL_MIN(thd->variables.max_heap_table_size,
                                thd->variables.sortbuff_size/16), 0,
               tree_key_length, compare_key, 0, NULL, (void*) this);
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/item_timefunc.cc mysql/sql/item_timefunc.cc
--- mysql.orig/sql/item_timefunc.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/sql/item_timefunc.cc	2008-01-15 02:53:13.443375111 -0800
@@ -306,14 +306,14 @@
       switch (*++ptr) {
 	/* Year */
       case 'Y':
-	tmp= (char*) val + min(4, val_len);
+	tmp= (char*) val + MYSQL_MIN(4, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
         if ((int) (tmp-val) <= 2)
           l_time->year= year_2000_handling(l_time->year);
 	val= tmp;
 	break;
       case 'y':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
         l_time->year= year_2000_handling(l_time->year);
@@ -322,7 +322,7 @@
 	/* Month */
       case 'm':
       case 'c':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->month= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -339,15 +339,15 @@
 	/* Day */
       case 'd':
       case 'e':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
       case 'D':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	/* Skip 'st, 'nd, 'th .. */
-	val= tmp + min((int) (val_end-tmp), 2);
+	val= tmp + MYSQL_MIN((int) (val_end-tmp), 2);
 	break;
 
 	/* Hour */
@@ -358,14 +358,14 @@
 	/* fall through */
       case 'k':
       case 'H':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->hour= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
 
 	/* Minute */
       case 'i':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->minute= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -373,7 +373,7 @@
 	/* Second */
       case 's':
       case 'S':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->second= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -425,7 +425,7 @@
 	val= tmp;
 	break;
       case 'j':
-	tmp= (char*) val + min(val_len, 3);
+	tmp= (char*) val + MYSQL_MIN(val_len, 3);
 	yearday= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -437,7 +437,7 @@
       case 'u':
         sunday_first_n_first_week_non_iso= (*ptr=='U' || *ptr== 'V');
         strict_week_number= (*ptr=='V' || *ptr=='v');
-	tmp= (char*) val + min(val_len, 2);
+	tmp= (char*) val + MYSQL_MIN(val_len, 2);
 	if ((week_number= (int) my_strtoll10(val, &tmp, &error)) < 0 ||
             strict_week_number && !week_number ||
             week_number > 53)
@@ -449,7 +449,7 @@
       case 'X':
       case 'x':
         strict_week_number_year_type= (*ptr=='X');
-        tmp= (char*) val + min(4, val_len);
+        tmp= (char*) val + MYSQL_MIN(4, val_len);
         strict_week_number_year= (int) my_strtoll10(val, &tmp, &error);
         val= tmp;
         break;
@@ -594,7 +594,7 @@
 err:
   {
     char buff[128];
-    strmake(buff, val_begin, min(length, sizeof(buff)-1));
+    strmake(buff, val_begin, MYSQL_MIN(length, sizeof(buff)-1));
     push_warning_printf(current_thd, MYSQL_ERROR::WARN_LEVEL_ERROR,
                         ER_WRONG_VALUE_FOR_TYPE, ER(ER_WRONG_VALUE_FOR_TYPE),
                         date_time_type, buff, "str_to_time");
@@ -1731,7 +1731,7 @@
   else
   {
     fixed_length=0;
-    max_length=min(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
+    max_length=MYSQL_MIN(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
                    collation.collation->mbmaxlen;
     set_if_smaller(max_length,MAX_BLOB_WIDTH);
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/key.cc mysql/sql/key.cc
--- mysql.orig/sql/key.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/sql/key.cc	2008-01-15 03:15:49.819808086 -0800
@@ -110,13 +110,13 @@
         key_part->key_part_flag & HA_VAR_LENGTH_PART)
     {
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       key_part->field->get_key_image((char*) to_key, length, Field::itRAW);
       to_key+= HA_KEY_BLOB_LENGTH;
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       Field *field= key_part->field;
       CHARSET_INFO *cs= field->charset();
       uint bytes= field->get_key_image((char*) to_key, length, Field::itRAW);
@@ -191,13 +191,13 @@
     else if (key_part->key_part_flag & HA_VAR_LENGTH_PART)
     {
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       key_part->field->set_key_image((char *) from_key, length);
       from_key+= HA_KEY_BLOB_LENGTH;
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       memcpy(to_record + key_part->offset, from_key, (size_t) length);
     }
     from_key+= length;
@@ -257,7 +257,7 @@
 	return 1;
       continue;
     }
-    length= min((uint) (key_end-key), store_length);
+    length= MYSQL_MIN((uint) (key_end-key), store_length);
     if (!(key_part->key_type & (FIELDFLAG_NUMBER+FIELDFLAG_BINARY+
                                 FIELDFLAG_PACK)))
     {
@@ -311,7 +311,7 @@
     {
       field->val_str(&tmp);
       if (key_part->length < field->pack_length())
-	tmp.length(min(tmp.length(),key_part->length));
+	tmp.length(MYSQL_MIN(tmp.length(),key_part->length));
       to->append(tmp);
     }
     else
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/log.cc mysql/sql/log.cc
--- mysql.orig/sql/log.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/sql/log.cc	2008-01-15 03:15:05.616156542 -0800
@@ -458,7 +458,7 @@
   {
     char *p = fn_ext(log_name);
     uint length=(uint) (p-log_name);
-    strmake(buff,log_name,min(length,FN_REFLEN));
+    strmake(buff, log_name, MYSQL_MIN(length, FN_REFLEN));
     return (const char*)buff;
   }
   return log_name;
@@ -2407,7 +2407,7 @@
   DBUG_ENTER("print_buffer_to_nt_eventlog");
 
   /* Add ending CR/LF's to string, overwrite last chars if necessary */
-  strmov(buffptr+min(length, buffLen-5), "\r\n\r\n");
+  strmov(buffptr+MYSQL_MIN(length, buffLen-5), "\r\n\r\n");
 
   setup_windows_event_source();
   if ((event= RegisterEventSource(NULL,"MySQL")))
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/log_event.cc mysql/sql/log_event.cc
--- mysql.orig/sql/log_event.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/sql/log_event.cc	2008-01-15 03:14:08.952844393 -0800
@@ -772,7 +772,7 @@
     of 13 bytes, whereas LOG_EVENT_MINIMAL_HEADER_LEN is 19 bytes (it's
     "minimal" over the set {MySQL >=4.0}).
   */
-  uint header_size= min(description_event->common_header_len,
+  uint header_size= MYSQL_MIN(description_event->common_header_len,
                         LOG_EVENT_MINIMAL_HEADER_LEN);
 
   LOCK_MUTEX;
@@ -3936,7 +3936,7 @@
   char buf[UV_NAME_LEN_SIZE];
   char buf1[UV_VAL_IS_NULL + UV_VAL_TYPE_SIZE + 
 	    UV_CHARSET_NUMBER_SIZE + UV_VAL_LEN_SIZE];
-  char buf2[max(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
+  char buf2[MYSQL_MAX(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
   uint buf1_length;
   ulong event_length;
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/mysqld.cc mysql/sql/mysqld.cc
--- mysql.orig/sql/mysqld.cc	2007-12-14 12:42:59.000000000 -0800
+++ mysql/sql/mysqld.cc	2008-01-15 02:53:13.456709723 -0800
@@ -2784,7 +2784,7 @@
       can't get max_connections*5 but still got no less than was
       requested (value of wanted_files).
     */
-    max_open_files= max(max(wanted_files, max_connections*5),
+    max_open_files= MYSQL_MAX(MYSQL_MAX(wanted_files, max_connections*5),
                         open_files_limit);
     files= my_set_max_open_files(max_open_files);
 
@@ -2796,15 +2796,15 @@
           If we have requested too much file handles than we bring
           max_connections in supported bounds.
         */
-        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,
+        max_connections= (ulong) MYSQL_MIN(files-10-TABLE_OPEN_CACHE_MIN*2,
                                      max_connections);
         /*
           Decrease table_cache_size according to max_connections, but
-          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we
+          not below TABLE_OPEN_CACHE_MIN.  Outer MYSQL_MIN() ensures that we
           never increase table_cache_size automatically (that could
           happen if max_connections is decreased above).
         */
-        table_cache_size= (ulong) min(max((files-10-max_connections)/2,
+        table_cache_size= (ulong) MYSQL_MIN(MYSQL_MAX((files-10-max_connections)/2,
                                           TABLE_OPEN_CACHE_MIN),
                                       table_cache_size);    
 	DBUG_PRINT("warning",
@@ -4147,7 +4147,7 @@
 {
   my_socket sock,new_sock;
   uint error_count=0;
-  uint max_used_connection= (uint) (max(ip_sock,unix_sock)+1);
+  uint max_used_connection= (uint) (MYSQL_MAX(ip_sock,unix_sock)+1);
   fd_set readFDs,clientFDs;
   THD *thd;
   struct sockaddr_in cAddr;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/my_time.c mysql/sql/my_time.c
--- mysql.orig/sql/my_time.c	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql/my_time.c	2008-01-15 02:53:13.460042805 -0800
@@ -251,7 +251,7 @@
     2003-03-03 20:00:20 AM
     20:00:20.000000 AM 03-03-2000
   */
-  i= max((uint) format_position[0], (uint) format_position[1]);
+  i= MYSQL_MAX((uint) format_position[0], (uint) format_position[1]);
   set_if_bigger(i, (uint) format_position[2]);
   allow_space= ((1 << i) | (1 << format_position[6]));
   allow_space&= (1 | 2 | 4 | 8);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/net_serv.cc mysql/sql/net_serv.cc
--- mysql.orig/sql/net_serv.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/net_serv.cc	2008-01-15 03:13:30.665764742 -0800
@@ -759,7 +759,7 @@
   {
     while (remain > 0)
     {
-      uint length= min(remain, net->max_packet);
+      uint length= MYSQL_MIN(remain, net->max_packet);
       if (net_safe_read(net, (char*) net->buff, length, alarmed))
 	DBUG_RETURN(1);
       update_statistics(thd_increment_bytes_received(length));
@@ -930,7 +930,7 @@
 	len=uint3korr(net->buff+net->where_b);
 	if (!len)				/* End of big multi-packet */
 	  goto end;
-	helping = max(len,*complen) + net->where_b;
+	helping = MYSQL_MAX(len,*complen) + net->where_b;
 	/* The necessary size of net->buff */
 	if (helping >= net->max_packet)
 	{
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/opt_range.cc mysql/sql/opt_range.cc
--- mysql.orig/sql/opt_range.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/opt_range.cc	2008-01-15 03:13:09.015766060 -0800
@@ -2446,7 +2446,7 @@
     {
       imerge_trp->read_cost= imerge_cost;
       imerge_trp->records= non_cpk_scan_records + cpk_scan_records;
-      imerge_trp->records= min(imerge_trp->records,
+      imerge_trp->records= MYSQL_MIN(imerge_trp->records,
                                param->table->file->records);
       imerge_trp->range_scans= range_scans;
       imerge_trp->range_scans_end= range_scans + n_child_scans;
@@ -5876,7 +5876,7 @@
   char *tmp_min_key, *tmp_max_key;
   uint8 save_first_null_comp= param->first_null_comp;
 
-  param->max_key_part=max(param->max_key_part,key_tree->part);
+  param->max_key_part=MYSQL_MAX(param->max_key_part,key_tree->part);
   if (key_tree->left != &null_element)
   {
     /*
@@ -6765,13 +6765,13 @@
   /* Do not allocate the buffers twice. */
   if (multi_range_length)
   {
-    DBUG_ASSERT(multi_range_length == min(multi_range_count, ranges.elements));
+    DBUG_ASSERT(multi_range_length == MYSQL_MIN(multi_range_count, ranges.elements));
     DBUG_RETURN(0);
   }
 
   /* Allocate the ranges array. */
   DBUG_ASSERT(ranges.elements);
-  multi_range_length= min(multi_range_count, ranges.elements);
+  multi_range_length= MYSQL_MIN(multi_range_count, ranges.elements);
   DBUG_ASSERT(multi_range_length > 0);
   while (multi_range_length && ! (multi_range= (KEY_MULTI_RANGE*)
                                   my_malloc(multi_range_length *
@@ -6790,7 +6790,7 @@
   /* Allocate the handler buffer if necessary.  */
   if (file->table_flags() & HA_NEED_READ_RANGE_BUFFER)
   {
-    mrange_bufsiz= min(multi_range_bufsiz,
+    mrange_bufsiz= MYSQL_MIN(multi_range_bufsiz,
                        ((uint)QUICK_SELECT_I::records + 1)* head->s->reclength);
 
     while (mrange_bufsiz &&
@@ -6858,7 +6858,7 @@
       }
     }
 
-    uint count= min(multi_range_length, ranges.elements -
+    uint count= MYSQL_MIN(multi_range_length, ranges.elements -
                     (cur_range - (QUICK_RANGE**) ranges.buffer));
     if (count == 0)
     {
@@ -6959,12 +6959,12 @@
     last_range= *(cur_range++);
 
     start_key.key=    (const byte*) last_range->min_key;
-    start_key.length= min(last_range->min_length, prefix_length);
+    start_key.length= MYSQL_MIN(last_range->min_length, prefix_length);
     start_key.flag=   ((last_range->flag & NEAR_MIN) ? HA_READ_AFTER_KEY :
 		       (last_range->flag & EQ_RANGE) ?
 		       HA_READ_KEY_EXACT : HA_READ_KEY_OR_NEXT);
     end_key.key=      (const byte*) last_range->max_key;
-    end_key.length=   min(last_range->max_length, prefix_length);
+    end_key.length=   MYSQL_MIN(last_range->max_length, prefix_length);
     /*
       We use READ_AFTER_KEY here because if we are reading on a key
       prefix we want to find all keys with this prefix
@@ -7260,7 +7260,7 @@
   KEY_PART *key_part = key_parts,
            *key_part_end= key_part+used_key_parts;
 
-  for (offset= 0,  end = min(range_arg->min_length, range_arg->max_length) ;
+  for (offset= 0,  end = MYSQL_MIN(range_arg->min_length, range_arg->max_length) ;
        offset < end && key_part != key_part_end ;
        offset+= key_part++->store_length)
   {
@@ -7605,7 +7605,7 @@
 
   TODO
   - What happens if the query groups by the MIN/MAX field, and there is no
-    other field as in: "select min(a) from t1 group by a" ?
+    other field as in: "select MYSQL_MIN(a) from t1 group by a" ?
   - We assume that the general correctness of the GROUP-BY query was checked
     before this point. Is this correct, or do we have to check it completely?
   - Lift the limitation in condition (B3), that is, make this access method 
@@ -7835,7 +7835,7 @@
         cur_group_prefix_len+= cur_part->store_length;
         cur_used_key_parts.set_bit(key_part_nr);
         ++cur_group_key_parts;
-        max_key_part= max(max_key_part,key_part_nr);
+        max_key_part= MYSQL_MAX(max_key_part,key_part_nr);
       }
       /*
         Check that used key parts forms a prefix of the index.
@@ -8440,9 +8440,9 @@
     {
       double blocks_per_group= (double) num_blocks / (double) num_groups;
       p_overlap= (blocks_per_group * (keys_per_subgroup - 1)) / keys_per_group;
-      p_overlap= min(p_overlap, 1.0);
+      p_overlap= MYSQL_MIN(p_overlap, 1.0);
     }
-    io_cost= (double) min(num_groups * (1 + p_overlap), num_blocks);
+    io_cost= (double) MYSQL_MIN(num_groups * (1 + p_overlap), num_blocks);
   }
   else
     io_cost= (keys_per_group > keys_per_block) ?
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/protocol.cc mysql/sql/protocol.cc
--- mysql.orig/sql/protocol.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/protocol.cc	2008-01-15 02:53:13.473379287 -0800
@@ -190,7 +190,7 @@
   length=sizeof(text_pos)-1;
 #endif
   length=my_vsnprintf(my_const_cast(char*) (text_pos),
-                      min(length, sizeof(net->last_error)),
+                      MYSQL_MIN(length, sizeof(net->last_error)),
                       format,args);
   va_end(args);
 
@@ -296,7 +296,7 @@
     pos+=2;
 
     /* We can only return up to 65535 warnings in two bytes */
-    uint tmp= min(thd->total_warn_count, 65535);
+    uint tmp= MYSQL_MIN(thd->total_warn_count, 65535);
     int2store(pos, tmp);
     pos+= 2;
   }
@@ -371,7 +371,7 @@
       Don't send warn count during SP execution, as the warn_list
       is cleared between substatements, and mysqltest gets confused
     */
-    uint tmp= (thd->spcont ? 0 : min(thd->total_warn_count, 65535));
+    uint tmp= (thd->spcont ? 0 : MYSQL_MIN(thd->total_warn_count, 65535));
     buff[0]= 254;
     int2store(buff+1, tmp);
     /*
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/set_var.cc mysql/sql/set_var.cc
--- mysql.orig/sql/set_var.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/sql/set_var.cc	2008-01-15 03:11:39.577022864 -0800
@@ -1813,7 +1813,7 @@
 					    &not_used));
     if (error_len)
     {
-      strmake(buff, error, min(sizeof(buff) - 1, error_len));
+      strmake(buff, error, MYSQL_MIN(sizeof(buff) - 1, error_len));
       goto err;
     }
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/slave.cc mysql/sql/slave.cc
--- mysql.orig/sql/slave.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/sql/slave.cc	2008-01-15 03:09:44.315795304 -0800
@@ -2543,7 +2543,7 @@
         special marker to say "consider we have caught up".
       */
       protocol->store((longlong)(mi->rli.last_master_timestamp ?
-                                 max(0, time_diff) : 0));
+                                 MYSQL_MAX(0, time_diff) : 0));
     }
     else
       protocol->store_null();
@@ -3434,7 +3434,7 @@
             exec_res= 0;
 	    end_trans(thd, ROLLBACK);
 	    /* chance for concurrent connection to get more locks */
-            safe_sleep(thd, min(rli->trans_retries, MAX_SLAVE_RETRY_PAUSE),
+            safe_sleep(thd, MYSQL_MIN(rli->trans_retries, MAX_SLAVE_RETRY_PAUSE),
 		       (CHECK_KILLED_FUNC)sql_slave_killed, (void*)rli);
             pthread_mutex_lock(&rli->data_lock); // because of SHOW STATUS
 	    rli->trans_retries++;
@@ -4849,7 +4849,7 @@
     relay_log_pos	Current log pos
     pending		Number of bytes already processed from the event
   */
-  rli->event_relay_log_pos= max(rli->event_relay_log_pos, BIN_LOG_HEADER_SIZE);
+  rli->event_relay_log_pos= MYSQL_MAX(rli->event_relay_log_pos, BIN_LOG_HEADER_SIZE);
   my_b_seek(cur_log,rli->event_relay_log_pos);
   DBUG_RETURN(cur_log);
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/spatial.h mysql/sql/spatial.h
--- mysql.orig/sql/spatial.h	2007-12-14 12:43:24.000000000 -0800
+++ mysql/sql/spatial.h	2008-01-15 02:53:58.130038225 -0800
@@ -180,8 +180,8 @@
     if (d != mbr->dimension() || d <= 0 || contains(mbr) || within(mbr))
       return 0;
 
-    MBR intersection(max(xmin, mbr->xmin), max(ymin, mbr->ymin),
-                     min(xmax, mbr->xmax), min(ymax, mbr->ymax));
+    MBR intersection(MYSQL_MAX(xmin, mbr->xmin), MYSQL_MAX(ymin, mbr->ymin),
+                     MYSQL_MIN(xmax, mbr->xmax), MYSQL_MIN(ymax, mbr->ymax));
 
     return (d == intersection.dimension());
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sp_head.cc mysql/sql/sp_head.cc
--- mysql.orig/sql/sp_head.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/sql/sp_head.cc	2008-01-15 03:09:01.051306283 -0800
@@ -2161,7 +2161,7 @@
   field_list.push_back(new Item_empty_string("sql_mode", sql_mode_len));
   // 1024 is for not to confuse old clients
   Item_empty_string *definition=
-    new Item_empty_string("Create Procedure", max(buffer.length(),1024));
+    new Item_empty_string("Create Procedure", MYSQL_MAX(buffer.length(),1024));
   definition->maybe_null= TRUE;
   field_list.push_back(definition);
 
@@ -2231,7 +2231,7 @@
   field_list.push_back(new Item_empty_string("Function",NAME_LEN));
   field_list.push_back(new Item_empty_string("sql_mode", sql_mode_len));
   Item_empty_string *definition=
-    new Item_empty_string("Create Function", max(buffer.length(),1024));
+    new Item_empty_string("Create Function", MYSQL_MAX(buffer.length(),1024));
   definition->maybe_null= TRUE;
   field_list.push_back(definition);
 
@@ -2380,7 +2380,7 @@
   field_list.push_back(new Item_uint("Pos", 9));
   // 1024 is for not to confuse old clients
   field_list.push_back(new Item_empty_string("Instruction",
-					     max(buffer.length(), 1024)));
+					     MYSQL_MAX(buffer.length(), 1024)));
   if (protocol->send_fields(&field_list, Protocol::SEND_NUM_ROWS |
                                          Protocol::SEND_EOF))
     DBUG_RETURN(1);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_acl.cc mysql/sql/sql_acl.cc
--- mysql.orig/sql/sql_acl.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/sql_acl.cc	2008-01-15 02:53:58.136704647 -0800
@@ -676,7 +676,7 @@
         chars= 128;                             // Marker that chars existed
       }
     }
-    sort= (sort << 8) + (wild_pos ? min(wild_pos, 127) : chars);
+    sort= (sort << 8) + (wild_pos ? MYSQL_MIN(wild_pos, 127) : chars);
   }
   va_end(args);
   return sort;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_analyse.cc mysql/sql/sql_analyse.cc
--- mysql.orig/sql/sql_analyse.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/sql/sql_analyse.cc	2008-01-15 03:07:35.602475062 -0800
@@ -281,16 +281,16 @@
   {
     if (((longlong) info->ullval) < 0)
       return 0; // Impossible to store as a negative number
-    ev_info->llval =  -(longlong) max((ulonglong) -ev_info->llval, 
+    ev_info->llval =  -(longlong) MYSQL_MAX((ulonglong) -ev_info->llval, 
 				      info->ullval);
-    ev_info->min_dval = (double) -max(-ev_info->min_dval, info->dval);
+    ev_info->min_dval = (double) -MYSQL_MAX(-ev_info->min_dval, info->dval);
   }
   else		// ulonglong is as big as bigint in MySQL
   {
     if ((check_ulonglong(num, info->integers) == DECIMAL_NUM))
       return 0;
-    ev_info->ullval = (ulonglong) max(ev_info->ullval, info->ullval);
-    ev_info->max_dval =  (double) max(ev_info->max_dval, info->dval);
+    ev_info->ullval = (ulonglong) MYSQL_MAX(ev_info->ullval, info->ullval);
+    ev_info->max_dval =  (double) MYSQL_MAX(ev_info->max_dval, info->dval);
   }
   return 1;
 } // get_ev_num_info
@@ -1044,7 +1044,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &avg_val, sum+cur_sum, &num, prec_increment);
   /* TODO remove this after decimal_div returns proper frac */
   my_decimal_round(E_DEC_FATAL_ERROR, &avg_val,
-                   min(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
+                   MYSQL_MIN(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
                    FALSE,&rounded_avg);
   my_decimal2string(E_DEC_FATAL_ERROR, &rounded_avg, 0, 0, '0', s);
   return s;
@@ -1069,7 +1069,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &tmp, &sum2, &num, prec_increment);
   my_decimal2double(E_DEC_FATAL_ERROR, &tmp, &std_sqr);
   s->set(((double) std_sqr <= 0.0 ? 0.0 : sqrt(std_sqr)),
-         min(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
+         MYSQL_MIN(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
 
   return s;
 }
@@ -1186,7 +1186,7 @@
   func_items[8] = new Item_proc_string("Std", 255);
   func_items[8]->maybe_null = 1;
   func_items[9] = new Item_proc_string("Optimal_fieldtype",
-				       max(64, output_str_length));
+				       MYSQL_MAX(64, output_str_length));
 
   for (uint i = 0; i < array_elements(func_items); i++)
     field_list.push_back(func_items[i]);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_cache.cc mysql/sql/sql_cache.cc
--- mysql.orig/sql/sql_cache.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/sql/sql_cache.cc	2008-01-15 03:07:17.752468035 -0800
@@ -753,7 +753,7 @@
 
     last_result_block= header->result()->prev;
     allign_size= ALIGN_SIZE(last_result_block->used);
-    len= max(query_cache.min_allocation_unit, allign_size);
+    len= MYSQL_MAX(query_cache.min_allocation_unit, allign_size);
     if (last_result_block->length >= query_cache.min_allocation_unit + len)
       query_cache.split_block(last_result_block,len);
 
@@ -2076,7 +2076,7 @@
   DBUG_ENTER("Query_cache::write_block_data");
   DBUG_PRINT("qcache", ("data: %ld, header: %ld, all header: %ld",
 		      data_len, header_len, all_headers_len));
-  Query_cache_block *block = allocate_block(max(align_len, 
+  Query_cache_block *block = allocate_block(MYSQL_MAX(align_len, 
 						min_allocation_unit),
 					    1, 0, under_guard);
   if (block != 0)
@@ -2141,7 +2141,7 @@
   ulong append_min = get_min_append_result_data_size();
   if (last_block_free_space < data_len &&
       append_next_free_block(last_block,
-			     max(tail, append_min)))
+			     MYSQL_MAX(tail, append_min)))
     last_block_free_space = last_block->length - last_block->used;
   // If no space in last block (even after join) allocate new block
   if (last_block_free_space < data_len)
@@ -2173,7 +2173,7 @@
   // Now finally write data to the last block
   if (success && last_block_free_space > 0)
   {
-    ulong to_copy = min(data_len,last_block_free_space);
+    ulong to_copy = MYSQL_MIN(data_len,last_block_free_space);
     DBUG_PRINT("qcache", ("use free space %lub at block 0x%lx to copy %lub",
 			last_block_free_space, (ulong)last_block, to_copy));
     memcpy((void*) (((byte*) last_block) + last_block->used), (void*) data,
@@ -2262,8 +2262,8 @@
   if (queries_in_cache < QUERY_CACHE_MIN_ESTIMATED_QUERIES_NUMBER)
     return min_result_data_size;
   ulong avg_result = (query_cache_size - free_memory) / queries_in_cache;
-  avg_result = min(avg_result, query_cache_limit);
-  return max(min_result_data_size, avg_result);
+  avg_result = MYSQL_MIN(avg_result, query_cache_limit);
+  return MYSQL_MAX(min_result_data_size, avg_result);
 }
 
 inline ulong Query_cache::get_min_append_result_data_size()
@@ -2295,7 +2295,7 @@
     ulong len= data_len + all_headers_len;
     ulong align_len= ALIGN_SIZE(len);
 
-    if (!(new_block= allocate_block(max(min_size, align_len),
+    if (!(new_block= allocate_block(MYSQL_MAX(min_size, align_len),
 				    min_result_data_size == 0,
 				    all_headers_len + min_result_data_size,
 				    1)))
@@ -2305,7 +2305,7 @@
     }
 
     new_block->n_tables = 0;
-    new_block->used = min(len, new_block->length);
+    new_block->used = MYSQL_MIN(len, new_block->length);
     new_block->type = Query_cache_block::RES_INCOMPLETE;
     new_block->next = new_block->prev = new_block;
     Query_cache_result *header = new_block->result();
@@ -2630,7 +2630,7 @@
   DBUG_PRINT("qcache", ("len %lu, not less %d, min %lu, uder_guard %d",
 		      len, not_less,min,under_guard));
 
-  if (len >= min(query_cache_size, query_cache_limit))
+  if (len >= MYSQL_MIN(query_cache_size, query_cache_limit))
   {
     DBUG_PRINT("qcache", ("Query cache hase only %lu memory and limit %lu",
 			query_cache_size, query_cache_limit));
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_class.cc mysql/sql/sql_class.cc
--- mysql.orig/sql/sql_class.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/sql/sql_class.cc	2008-01-15 02:53:58.146704342 -0800
@@ -1315,7 +1315,7 @@
     else
     {
       if (fixed_row_size)
-	used_length=min(res->length(),item->max_length);
+	used_length=MYSQL_MIN(res->length(),item->max_length);
       else
 	used_length=res->length();
       if ((result_type == STRING_RESULT || is_unsafe_field_sep) &&
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_client.cc mysql/sql/sql_client.cc
--- mysql.orig/sql/sql_client.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/sql_client.cc	2008-01-15 02:53:58.146704342 -0800
@@ -34,7 +34,7 @@
                            (uint)global_system_variables.net_write_timeout);
 
   net->retry_count=  (uint) global_system_variables.net_retry_count;
-  net->max_packet_size= max(global_system_variables.net_buffer_length,
+  net->max_packet_size= MYSQL_MAX(global_system_variables.net_buffer_length,
 			    global_system_variables.max_allowed_packet);
 #endif
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_load.cc mysql/sql/sql_load.cc
--- mysql.orig/sql/sql_load.cc	2007-12-14 12:43:32.000000000 -0800
+++ mysql/sql/sql_load.cc	2008-01-15 02:55:25.622528525 -0800
@@ -917,7 +917,7 @@
 
 
   /* Set of a stack for unget if long terminators */
-  uint length=max(field_term_length,line_term_length)+1;
+  uint length=MYSQL_MAX(field_term_length,line_term_length)+1;
   set_if_bigger(length,line_start.length());
   stack=stack_pos=(int*) sql_alloc(sizeof(int)*length);
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_parse.cc mysql/sql/sql_parse.cc
--- mysql.orig/sql/sql_parse.cc	2007-12-14 12:43:41.000000000 -0800
+++ mysql/sql/sql_parse.cc	2008-01-15 02:55:25.626717333 -0800
@@ -5804,7 +5804,7 @@
     return 1;
   }
 #ifndef DBUG_OFF
-  max_stack_used= max(max_stack_used, stack_used);
+  max_stack_used= MYSQL_MAX(max_stack_used, stack_used);
 #endif
   return 0;
 }
@@ -7232,7 +7232,7 @@
     char command[80];
     Lex_input_stream *lip= thd->m_lip;
     strmake(command, lip->yylval->symbol.str,
-	    min(lip->yylval->symbol.length, sizeof(command)-1));
+	    MYSQL_MIN(lip->yylval->symbol.length, sizeof(command)-1));
     my_error(ER_CANT_USE_OPTION_HERE, MYF(0), command);
     return 1;
   }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_prepare.cc mysql/sql/sql_prepare.cc
--- mysql.orig/sql/sql_prepare.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/sql/sql_prepare.cc	2008-01-15 02:55:53.545869502 -0800
@@ -228,7 +228,7 @@
   int2store(buff+5, columns);
   int2store(buff+7, stmt->param_count);
   buff[9]= 0;                                   // Guard against a 4.1 client
-  tmp= min(stmt->thd->total_warn_count, 65535);
+  tmp= MYSQL_MIN(stmt->thd->total_warn_count, 65535);
   int2store(buff+10, tmp);
 
   /*
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_repl.cc mysql/sql/sql_repl.cc
--- mysql.orig/sql/sql_repl.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql/sql_repl.cc	2008-01-15 02:55:53.545869502 -0800
@@ -1180,12 +1180,12 @@
    {
      /*
        Sometimes mi->rli.master_log_pos == 0 (it happens when the SQL thread is
-       not initialized), so we use a max().
+       not initialized), so we use a MYSQL_MAX().
        What happens to mi->rli.master_log_pos during the initialization stages
        of replication is not 100% clear, so we guard against problems using
        max().
       */
-     mi->master_log_pos = max(BIN_LOG_HEADER_SIZE,
+     mi->master_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE,
 			      mi->rli.group_master_log_pos);
      strmake(mi->master_log_name, mi->rli.group_master_log_name,
              sizeof(mi->master_log_name)-1);
@@ -1323,7 +1323,7 @@
     LEX_MASTER_INFO *lex_mi= &thd->lex->mi;
     SELECT_LEX_UNIT *unit= &thd->lex->unit;
     ha_rows event_count, limit_start, limit_end;
-    my_off_t pos = max(BIN_LOG_HEADER_SIZE, lex_mi->pos); // user-friendly
+    my_off_t pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, lex_mi->pos); // user-friendly
     char search_file_name[FN_REFLEN], *name;
     const char *log_file_name = lex_mi->log_file_name;
     pthread_mutex_t *log_lock = mysql_bin_log.get_log_lock();
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_select.cc mysql/sql/sql_select.cc
--- mysql.orig/sql/sql_select.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/sql_select.cc	2008-01-15 03:04:34.729142890 -0800
@@ -2715,7 +2715,7 @@
       This is can't be to high as otherwise we are likely to use
       table scan.
     */
-    s->worst_seeks= min((double) s->found_records / 10,
+    s->worst_seeks= MYSQL_MIN((double) s->found_records / 10,
 			(double) s->read_time*3);
     if (s->worst_seeks < 2.0)			// Fix for small tables
       s->worst_seeks=2.0;
@@ -3578,7 +3578,7 @@
   uint	and_level,i,found_eq_constant;
   KEY_FIELD *key_fields, *end, *field;
   uint sz;
-  uint m= max(select_lex->max_equal_elems,1);
+  uint m= MYSQL_MAX(select_lex->max_equal_elems,1);
   
   /* 
     We use the same piece of memory to store both  KEY_FIELD 
@@ -3601,7 +3601,7 @@
     can be not more than select_lex->max_equal_elems such 
     substitutions.
   */ 
-  sz= max(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
+  sz= MYSQL_MAX(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
       (((thd->lex->current_select->cond_count+1)*2 +
 	thd->lex->current_select->between_count)*m+1);
   if (!(key_fields=(KEY_FIELD*)	thd->alloc(sz)))
@@ -3750,7 +3750,7 @@
       if (map == 1)			// Only one table
       {
 	TABLE *tmp_table=join->all_tables[tablenr];
-	keyuse->ref_table_rows= max(tmp_table->file->records, 100);
+	keyuse->ref_table_rows= MYSQL_MAX(tmp_table->file->records, 100);
       }
     }
     /*
@@ -4064,7 +4064,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
         }
         else
@@ -4208,7 +4208,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
           else
             tmp= best_time;                    // Do nothing
@@ -5107,7 +5107,7 @@
   {
     uint blob_length=(uint) (join_tab->table->file->mean_rec_length-
 			     (join_tab->table->s->reclength- rec_length));
-    rec_length+=(uint) max(4,blob_length);
+    rec_length+=(uint) MYSQL_MAX(4,blob_length);
   }
   join_tab->used_fields=fields;
   join_tab->used_fieldlength=rec_length;
@@ -9021,7 +9021,7 @@
                                                item->unsigned_flag) - len;
 
       if (overflow > 0)
-        dec= max(0, dec - overflow);            // too long, discard fract
+        dec= MYSQL_MAX(0, dec - overflow);            // too long, discard fract
       else
         len -= item->decimals - dec;            // corrected value fits
     }
@@ -13109,7 +13109,7 @@
     count++;
   if (!sortorder)
     sortorder= (SORT_FIELD*) sql_alloc(sizeof(SORT_FIELD) *
-                                       (max(count, *length) + 1));
+                                       (MYSQL_MAX(count, *length) + 1));
   pos= sort= sortorder;
 
   if (!pos)
@@ -13227,7 +13227,7 @@
   cache->length=length+blobs*sizeof(char*);
   cache->blobs=blobs;
   *blob_ptr=0;					/* End sequentel */
-  size=max(thd->variables.join_buff_size, cache->length);
+  size=MYSQL_MAX(thd->variables.join_buff_size, cache->length);
   if (!(cache->buff=(uchar*) my_malloc(size,MYF(0))))
     DBUG_RETURN(1);				/* Don't use cache */ /* purecov: inspected */
   cache->end=cache->buff+size;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_show.cc mysql/sql/sql_show.cc
--- mysql.orig/sql/sql_show.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql/sql_show.cc	2008-01-15 03:02:45.792495815 -0800
@@ -428,14 +428,14 @@
   {
     field_list.push_back(new Item_empty_string("View",NAME_LEN));
     field_list.push_back(new Item_empty_string("Create View",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
   }
   else
   {
     field_list.push_back(new Item_empty_string("Table",NAME_LEN));
     // 1024 is for not to confuse old clients
     field_list.push_back(new Item_empty_string("Create Table",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
   }
 
   if (protocol->send_fields(&field_list,
@@ -1390,7 +1390,7 @@
 	    the comment in sql_class.h why this prevents crashes in possible
             races with query_length
           */
-          uint length= min(max_query_length, tmp->query_length);
+          uint length= MYSQL_MIN(max_query_length, tmp->query_length);
           thd_info->query=(char*) thd->strmake(tmp->query,length);
         }
         thread_infos.append(thd_info);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_string.cc mysql/sql/sql_string.cc
--- mysql.orig/sql/sql_string.cc	2007-12-14 12:42:59.000000000 -0800
+++ mysql/sql/sql_string.cc	2008-01-15 02:55:53.559192993 -0800
@@ -662,7 +662,7 @@
 {
   if (Alloced_length < str_length + space_needed)
   {
-    if (realloc(Alloced_length + max(space_needed, grow_by) - 1))
+    if (realloc(Alloced_length + MYSQL_MAX(space_needed, grow_by) - 1))
       return TRUE;
   }
   return FALSE;
@@ -748,7 +748,7 @@
 
 int stringcmp(const String *s,const String *t)
 {
-  uint32 s_len=s->length(),t_len=t->length(),len=min(s_len,t_len);
+  uint32 s_len=s->length(),t_len=t->length(),len=MYSQL_MIN(s_len,t_len);
   int cmp= memcmp(s->ptr(), t->ptr(), len);
   return (cmp) ? cmp : (int) (s_len - t_len);
 }
@@ -765,7 +765,7 @@
   }
   if (to->realloc(from_length))
     return from;				// Actually an error
-  if ((to->str_length=min(from->str_length,from_length)))
+  if ((to->str_length=MYSQL_MIN(from->str_length,from_length)))
     memcpy(to->Ptr,from->Ptr,to->str_length);
   to->str_charset=from->str_charset;
   return to;
@@ -906,7 +906,7 @@
 
     if (to_cs == &my_charset_bin)
     {
-      res= min(min(nchars, to_length), from_length);
+      res= MYSQL_MIN(MYSQL_MIN(nchars, to_length), from_length);
       memmove(to, from, res);
       *from_end_pos= from + res;
       *well_formed_error_pos= NULL;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_table.cc mysql/sql/sql_table.cc
--- mysql.orig/sql/sql_table.cc	2007-12-14 12:43:14.000000000 -0800
+++ mysql/sql/sql_table.cc	2008-01-15 02:55:53.559192993 -0800
@@ -1355,7 +1355,7 @@
 	  if ((length=column->length) > max_key_length ||
 	      length > file->max_key_part_length())
 	  {
-	    length=min(max_key_length, file->max_key_part_length());
+	    length=MYSQL_MIN(max_key_length, file->max_key_part_length());
 	    if (key->type == Key::MULTIPLE)
 	    {
 	      /* not a critical problem */
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_yacc.cc mysql/sql/sql_yacc.cc
--- mysql.orig/sql/sql_yacc.cc	2007-12-14 12:56:33.000000000 -0800
+++ mysql/sql/sql_yacc.cc	2008-01-15 02:55:53.572525507 -0800
@@ -14535,7 +14535,7 @@
               from 0" (4 in fact), unspecified means "don't change the position
               (keep the preceding value)").
            */
-           Lex->mi.pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
+           Lex->mi.pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
          }
     break;
 
@@ -14551,7 +14551,7 @@
     {
            Lex->mi.relay_log_pos = (yyvsp[0].ulong_num);
            /* Adjust if < BIN_LOG_HEADER_SIZE (same comment as Lex->mi.pos) */
-           Lex->mi.relay_log_pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
+           Lex->mi.relay_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
          }
     break;
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/sql_yacc.yy mysql/sql/sql_yacc.yy
--- mysql.orig/sql/sql_yacc.yy	2007-12-14 12:43:24.000000000 -0800
+++ mysql/sql/sql_yacc.yy	2008-01-15 02:55:53.579192451 -0800
@@ -1452,7 +1452,7 @@
               from 0" (4 in fact), unspecified means "don't change the position
               (keep the preceding value)").
            */
-           Lex->mi.pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
+           Lex->mi.pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
          }
        | RELAY_LOG_FILE_SYM EQ TEXT_STRING_sys
          {
@@ -1462,7 +1462,7 @@
          {
            Lex->mi.relay_log_pos = $3;
            /* Adjust if < BIN_LOG_HEADER_SIZE (same comment as Lex->mi.pos) */
-           Lex->mi.relay_log_pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
+           Lex->mi.relay_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
          }
        ;
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/stacktrace.c mysql/sql/stacktrace.c
--- mysql.orig/sql/stacktrace.c	2007-12-14 12:43:14.000000000 -0800
+++ mysql/sql/stacktrace.c	2008-01-15 02:55:53.579192451 -0800
@@ -146,7 +146,7 @@
 
   if (!stack_bottom || (gptr) stack_bottom > (gptr) &fp)
   {
-    ulong tmp= min(0x10000,thread_stack);
+    ulong tmp= MYSQL_MIN(0x10000,thread_stack);
     /* Assume that the stack starts at the previous even 65K */
     stack_bottom= (gptr) (((ulong) &fp + tmp) &
 			  ~(ulong) 0xFFFF);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/thr_malloc.cc mysql/sql/thr_malloc.cc
--- mysql.orig/sql/thr_malloc.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/thr_malloc.cc	2008-01-15 02:55:53.579192451 -0800
@@ -103,7 +103,7 @@
   if ((from_cs == &my_charset_bin) || (to_cs == &my_charset_bin))
   {
     // Safety if to_cs->mbmaxlen > 0
-    new_length= min(arg_length, max_res_length);
+    new_length= MYSQL_MIN(arg_length, max_res_length);
     memcpy(pos, str, new_length);
   }
   else
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/tztime.cc mysql/sql/tztime.cc
--- mysql.orig/sql/tztime.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/sql/tztime.cc	2008-01-15 02:55:53.582526325 -0800
@@ -167,7 +167,7 @@
       char buf[sizeof(struct tzhead) + sizeof(my_time_t) * TZ_MAX_TIMES +
                TZ_MAX_TIMES + sizeof(TRAN_TYPE_INFO) * TZ_MAX_TYPES +
 #ifdef ABBR_ARE_USED
-               max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
+               MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
 #endif
                sizeof(LS_INFO) * TZ_MAX_LEAPS];
     } u;
@@ -396,7 +396,7 @@
       Let us choose end_t as point before next time type change or leap
       second correction.
     */
-    end_t= min((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
+    end_t= MYSQL_MIN((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
                                                 MY_TIME_T_MAX,
                (next_leap_idx < sp->leapcnt) ?
                  sp->lsis[next_leap_idx].ls_trans - 1: MY_TIME_T_MAX);
@@ -1866,7 +1866,7 @@
   unsigned char types[TZ_MAX_TIMES];
   TRAN_TYPE_INFO ttis[TZ_MAX_TYPES];
 #ifdef ABBR_ARE_USED
-  char chars[max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
+  char chars[MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
 #endif
 
   DBUG_ENTER("tz_load_from_open_tables");
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql/unireg.cc mysql/sql/unireg.cc
--- mysql.orig/sql/unireg.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/unireg.cc	2008-01-15 02:55:53.582526325 -0800
@@ -360,7 +360,7 @@
     }
     cfield->row=(uint8) row;
     cfield->col=(uint8) (length+1);
-    cfield->sc_length=(uint8) min(cfield->length,cols-(length+2));
+    cfield->sc_length=(uint8) MYSQL_MIN(cfield->length,cols-(length+2));
   }
   length=(uint) (pos-start_screen);
   int2store(start_screen,length);
@@ -579,7 +579,7 @@
     DBUG_RETURN(1);
   }
   /* Hack to avoid bugs with small static rows in MySQL */
-  reclength=max(file->min_record_length(table_options),reclength);
+  reclength=MYSQL_MAX(file->min_record_length(table_options),reclength);
   if (info_length+(ulong) create_fields.elements*FCOMP+288+
       n_length+int_length+com_length > 65535L || int_count > 255)
   {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql-common/client.c mysql/sql-common/client.c
--- mysql.orig/sql-common/client.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql-common/client.c	2008-01-15 02:55:53.582526325 -0800
@@ -630,7 +630,7 @@
 	pos+= SQLSTATE_LENGTH+1;
       }
       (void) strmake(net->last_error,(char*) pos,
-		     min((uint) len,(uint) sizeof(net->last_error)-1));
+		     MYSQL_MIN((uint) len,(uint) sizeof(net->last_error)-1));
     }
     else
       set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
@@ -2026,7 +2026,7 @@
 	goto error;
       }
       memcpy(&sock_addr.sin_addr, hp->h_addr,
-             min(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
+             MYSQL_MIN(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
       my_gethostbyname_r_free();
     }
     sock_addr.sin_port = (ushort) htons((ushort) port);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/sql-common/my_time.c mysql/sql-common/my_time.c
--- mysql.orig/sql-common/my_time.c	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql-common/my_time.c	2008-01-15 02:55:53.585859414 -0800
@@ -251,7 +251,7 @@
     2003-03-03 20:00:20 AM
     20:00:20.000000 AM 03-03-2000
   */
-  i= max((uint) format_position[0], (uint) format_position[1]);
+  i= MYSQL_MAX((uint) format_position[0], (uint) format_position[1]);
   set_if_bigger(i, (uint) format_position[2]);
   allow_space= ((1 << i) | (1 << format_position[6]));
   allow_space&= (1 | 2 | 4 | 8);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-big5.c mysql/strings/ctype-big5.c
--- mysql.orig/strings/ctype-big5.c	2007-12-14 12:42:50.000000000 -0800
+++ mysql/strings/ctype-big5.c	2008-01-15 03:23:09.812731349 -0800
@@ -253,7 +253,7 @@
                              const uchar *b, uint b_length,
                              my_bool b_is_prefix)
 {
-  uint length= min(a_length, b_length);
+  uint length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_big5_internal(&a, &b, length);
   return res ? res : (int)((b_is_prefix ? length : a_length) - b_length);
 }
@@ -266,7 +266,7 @@
 			       const uchar *b, uint b_length,
                                my_bool diff_if_only_endspace_difference)
 {
-  uint length= min(a_length, b_length);
+  uint length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_big5_internal(&a, &b, length);
 
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-bin.c mysql/strings/ctype-bin.c
--- mysql.orig/strings/ctype-bin.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/strings/ctype-bin.c	2008-01-15 03:22:59.871697030 -0800
@@ -80,7 +80,7 @@
                                const uchar *t, uint tlen,
                                my_bool t_is_prefix)
 {
-  uint len=min(slen,tlen);
+  uint len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
@@ -131,7 +131,7 @@
                                  const uchar *t, uint tlen,
                                  my_bool t_is_prefix)
 {
-  uint len=min(slen,tlen);
+  uint len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
@@ -175,7 +175,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
 
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -402,7 +402,7 @@
                            const uchar *src, uint srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen,srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, 0);
   return dstlen;
@@ -415,7 +415,7 @@
                          const uchar *src, uint srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen,srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-gbk.c mysql/strings/ctype-gbk.c
--- mysql.orig/strings/ctype-gbk.c	2007-12-14 12:43:51.000000000 -0800
+++ mysql/strings/ctype-gbk.c	2008-01-15 03:22:50.485708147 -0800
@@ -2616,7 +2616,7 @@
                      const uchar *b, uint b_length,
                      my_bool b_is_prefix)
 {
-  uint length= min(a_length, b_length);
+  uint length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_gbk_internal(&a, &b, length);
   return res ? res : (int) ((b_is_prefix ? length : a_length) - b_length);
 }
@@ -2627,7 +2627,7 @@
 			      const uchar *b, uint b_length,
                               my_bool diff_if_only_endspace_difference)
 {
-  uint length= min(a_length, b_length);
+  uint length= MYSQL_MIN(a_length, b_length);
   int res= my_strnncoll_gbk_internal(&a, &b, length);
 
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-mb.c mysql/strings/ctype-mb.c
--- mysql.orig/strings/ctype-mb.c	2007-12-14 12:43:15.000000000 -0800
+++ mysql/strings/ctype-mb.c	2008-01-15 03:22:36.899082525 -0800
@@ -364,7 +364,7 @@
 				const uchar *t, uint tlen,
                                 my_bool t_is_prefix)
 {
-  uint len=min(slen,tlen);
+  uint len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : (int) ((t_is_prefix ? len : slen) - tlen);
 }
@@ -408,7 +408,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
   
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -447,7 +447,7 @@
                               const uchar *src, uint srclen)
 {
   if (dest != src)
-    memcpy(dest, src, min(dstlen, srclen));
+    memcpy(dest, src, MYSQL_MIN(dstlen, srclen));
   if (dstlen > srclen)
     bfill(dest + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-simple.c mysql/strings/ctype-simple.c
--- mysql.orig/strings/ctype-simple.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/strings/ctype-simple.c	2008-01-15 03:22:31.829033671 -0800
@@ -153,7 +153,7 @@
   diff_if_only_endspace_difference= 0;
 #endif
 
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (map[*a++] != map[*b++])
@@ -865,7 +865,7 @@
     val= new_val;
   }
   
-  len= min(len, (uint) (e-p));
+  len= MYSQL_MIN(len, (uint) (e-p));
   memcpy(dst, p, len);
   return (int) len+sign;
 }
@@ -918,7 +918,7 @@
     long_val= quo;
   }
   
-  len= min(len, (uint) (e-p));
+  len= MYSQL_MIN(len, (uint) (e-p));
 cnv:
   memcpy(dst, p, len);
   return len+sign;
@@ -1148,7 +1148,7 @@
 {
   uint nbytes= (uint) (end-start);
   *error= 0;
-  return min(nbytes, nchars);
+  return MYSQL_MIN(nbytes, nchars);
 }
 
 
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-tis620.c mysql/strings/ctype-tis620.c
--- mysql.orig/strings/ctype-tis620.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/strings/ctype-tis620.c	2008-01-15 03:22:20.655702553 -0800
@@ -581,7 +581,7 @@
   a_length= thai2sortable(a, a_length);
   b_length= thai2sortable(b, b_length);
   
-  end= a + (length= min(a_length, b_length));
+  end= a + (length= MYSQL_MIN(a_length, b_length));
   while (a < end)
   {
     if (*a++ != *b++)
@@ -638,7 +638,7 @@
                        const uchar * src, uint srclen)
 {
   uint dstlen= len;
-  len= (uint) (strmake((char*) dest, (char*) src, min(len, srclen)) -
+  len= (uint) (strmake((char*) dest, (char*) src, MYSQL_MIN(len, srclen)) -
 	       (char*) dest);
   len= thai2sortable(dest, len);
   if (dstlen > len)
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-uca.c mysql/strings/ctype-uca.c
--- mysql.orig/strings/ctype-uca.c	2007-12-14 12:43:33.000000000 -0800
+++ mysql/strings/ctype-uca.c	2008-01-15 03:22:03.369781512 -0800
@@ -7566,7 +7566,7 @@
 {
   char tail[30];
   size_t len= lexem->end - lexem->prev;
-  strmake (tail, lexem->prev, (uint) min(len, sizeof(tail)-1));
+  strmake (tail, lexem->prev, (uint) MYSQL_MIN(len, sizeof(tail)-1));
   errstr[errsize-1]= '\0';
   my_snprintf(errstr,errsize-1,"%s at '%s'", txt, tail);
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-ucs2.c mysql/strings/ctype-ucs2.c
--- mysql.orig/strings/ctype-ucs2.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/strings/ctype-ucs2.c	2008-01-15 02:59:21.079171475 -0800
@@ -279,7 +279,7 @@
   se= s + slen;
   te= t + tlen;
 
-  for (minlen= min(slen, tlen); minlen; minlen-= 2)
+  for (minlen= MYSQL_MIN(slen, tlen); minlen; minlen-= 2)
   {
     int s_wc = uni_plane[s[0]] ? (int) uni_plane[s[0]][s[1]].sort :
                                  (((int) s[0]) << 8) + (int) s[1];
@@ -1332,7 +1332,7 @@
   uint nbytes= ((uint) (e-b)) & ~(uint) 1;
   *error= 0;
   nchars*= 2;
-  return min(nbytes, nchars);
+  return MYSQL_MIN(nbytes, nchars);
 }
 
 
@@ -1427,7 +1427,7 @@
   se= s + slen;
   te= t + tlen;
 
-  for (minlen= min(slen, tlen); minlen; minlen-= 2)
+  for (minlen= MYSQL_MIN(slen, tlen); minlen; minlen-= 2)
   {
     int s_wc= s[0] * 256 + s[1];
     int t_wc= t[0] * 256 + t[1];
@@ -1474,7 +1474,7 @@
 			 const uchar *src, uint srclen)
 {
   if (dst != src)
-    memcpy(dst,src,srclen= min(dstlen,srclen));
+    memcpy(dst,src,srclen= MYSQL_MIN(dstlen,srclen));
   if (dstlen > srclen)
     cs->cset->fill(cs, (char*) dst + srclen, dstlen - srclen, ' ');
   return dstlen;
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/ctype-utf8.c mysql/strings/ctype-utf8.c
--- mysql.orig/strings/ctype-utf8.c	2007-12-14 12:43:24.000000000 -0800
+++ mysql/strings/ctype-utf8.c	2008-01-15 02:59:21.082505011 -0800
@@ -1935,7 +1935,7 @@
                          const uchar *t, const uchar *te)
 {
   int slen= (int) (se-s), tlen= (int) (te-t);
-  int len=min(slen,tlen);
+  int len=MYSQL_MIN(slen,tlen);
   int cmp= memcmp(s,t,len);
   return cmp ? cmp : slen-tlen;
 }
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/decimal.c mysql/strings/decimal.c
--- mysql.orig/strings/decimal.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/strings/decimal.c	2008-01-15 02:59:21.082505011 -0800
@@ -403,7 +403,7 @@
     for (; frac>0; frac-=DIG_PER_DEC1)
     {
       dec1 x=*buf++;
-      for (i=min(frac, DIG_PER_DEC1); i; i--)
+      for (i=MYSQL_MIN(frac, DIG_PER_DEC1); i; i--)
       {
         dec1 y=x/DIG_MASK;
         *s1++='0'+(uchar)y;
@@ -426,7 +426,7 @@
     for (buf=buf0+ROUND_UP(intg); intg>0; intg-=DIG_PER_DEC1)
     {
       dec1 x=*--buf;
-      for (i=min(intg, DIG_PER_DEC1); i; i--)
+      for (i=MYSQL_MIN(intg, DIG_PER_DEC1); i; i--)
       {
         dec1 y=x/10;
         *--s='0'+(uchar)(x-y*10);
@@ -1514,8 +1514,8 @@
 
   if (to != from || intg1>intg0)
   {
-    dec1 *p0= buf0+intg0+max(frac1, frac0);
-    dec1 *p1= buf1+intg1+max(frac1, frac0);
+    dec1 *p0= buf0+intg0+MYSQL_MAX(frac1, frac0);
+    dec1 *p1= buf1+intg1+MYSQL_MAX(frac1, frac0);
 
     while (buf0 < p0)
       *(--p1) = *(--p0);
@@ -1526,7 +1526,7 @@
     buf0=to->buf;
     buf1=to->buf;
     to->sign=from->sign;
-    to->intg=min(intg0, len)*DIG_PER_DEC1;
+    to->intg=MYSQL_MIN(intg0, len)*DIG_PER_DEC1;
   }
 
   if (frac0 > frac1)
@@ -1616,7 +1616,7 @@
         scale=frac0*DIG_PER_DEC1;
         error=E_DEC_TRUNCATED; /* XXX */
       }
-      for (buf1=to->buf+intg0+max(frac0,0); buf1 > to->buf; buf1--)
+      for (buf1=to->buf+intg0+MYSQL_MAX(frac0,0); buf1 > to->buf; buf1--)
       {
         buf1[0]=buf1[-1];
       }
@@ -1635,7 +1635,7 @@
         /* making 'zero' with the proper scale */
         dec1 *p0= to->buf + frac0 + 1;
         to->intg=1;
-        to->frac= max(scale, 0);
+        to->frac= MYSQL_MAX(scale, 0);
         to->sign= 0;
         for (buf1= to->buf; buf1<p0; buf1++)
           *buf1= 0;
@@ -1684,11 +1684,11 @@
 {
   switch (op) {
   case '-':
-    return ROUND_UP(max(from1->intg, from2->intg)) +
-           ROUND_UP(max(from1->frac, from2->frac));
+    return ROUND_UP(MYSQL_MAX(from1->intg, from2->intg)) +
+           ROUND_UP(MYSQL_MAX(from1->frac, from2->frac));
   case '+':
-    return ROUND_UP(max(from1->intg, from2->intg)+1) +
-           ROUND_UP(max(from1->frac, from2->frac));
+    return ROUND_UP(MYSQL_MAX(from1->intg, from2->intg)+1) +
+           ROUND_UP(MYSQL_MAX(from1->frac, from2->frac));
   case '*':
     return ROUND_UP(from1->intg+from2->intg)+
            ROUND_UP(from1->frac)+ROUND_UP(from2->frac);
@@ -1703,7 +1703,7 @@
 {
   int intg1=ROUND_UP(from1->intg), intg2=ROUND_UP(from2->intg),
       frac1=ROUND_UP(from1->frac), frac2=ROUND_UP(from2->frac),
-      frac0=max(frac1, frac2), intg0=max(intg1, intg2), error;
+      frac0=MYSQL_MAX(frac1, frac2), intg0=MYSQL_MAX(intg1, intg2), error;
   dec1 *buf1, *buf2, *buf0, *stop, *stop2, x, carry;
 
   sanity(to);
@@ -1728,7 +1728,7 @@
   buf0=to->buf+intg0+frac0;
 
   to->sign=from1->sign;
-  to->frac=max(from1->frac, from2->frac);
+  to->frac=MYSQL_MAX(from1->frac, from2->frac);
   to->intg=intg0*DIG_PER_DEC1;
   if (unlikely(error))
   {
@@ -1757,14 +1757,14 @@
   while (buf1 > stop)
     *--buf0=*--buf1;
 
-  /* part 2 - min(frac) ... min(intg) */
+  /* part 2 - MYSQL_MIN(frac) ... MYSQL_MIN(intg) */
   carry=0;
   while (buf1 > stop2)
   {
     ADD(*--buf0, *--buf1, *--buf2, carry);
   }
 
-  /* part 3 - min(intg) ... max(intg) */
+  /* part 3 - MYSQL_MIN(intg) ... MYSQL_MAX(intg)  */
   buf1= intg1 > intg2 ? ((stop=from1->buf)+intg1-intg2) :
                         ((stop=from2->buf)+intg2-intg1) ;
   while (buf1 > stop)
@@ -1785,7 +1785,7 @@
 {
   int intg1=ROUND_UP(from1->intg), intg2=ROUND_UP(from2->intg),
       frac1=ROUND_UP(from1->frac), frac2=ROUND_UP(from2->frac);
-  int frac0=max(frac1, frac2), error;
+  int frac0=MYSQL_MAX(frac1, frac2), error;
   dec1 *buf1, *buf2, *buf0, *stop1, *stop2, *start1, *start2, carry=0;
 
   /* let carry:=1 if from2 > from1 */
@@ -1860,7 +1860,7 @@
   FIX_INTG_FRAC_ERROR(to->len, intg1, frac0, error);
   buf0=to->buf+intg1+frac0;
 
-  to->frac=max(from1->frac, from2->frac);
+  to->frac=MYSQL_MAX(from1->frac, from2->frac);
   to->intg=intg1*DIG_PER_DEC1;
   if (unlikely(error))
   {
@@ -1895,7 +1895,7 @@
     }
   }
 
-  /* part 2 - min(frac) ... intg2 */
+  /* part 2 - MYSQL_MIN(frac) ... intg2 */
   while (buf2 > start2)
   {
     SUB(*--buf0, *--buf1, *--buf2, carry);
@@ -2153,11 +2153,11 @@
   {
     /* we're calculating N1 % N2.
        The result will have
-         frac=max(frac1, frac2), as for subtraction
+         frac=MYSQL_MAX(frac1, frac2), as for subtraction
          intg=intg2
     */
     to->sign=from1->sign;
-    to->frac=max(from1->frac, from2->frac);
+    to->frac=MYSQL_MAX(from1->frac, from2->frac);
     frac0=0;
   }
   else
@@ -2281,7 +2281,7 @@
     /*
       now the result is in tmp1, it has
         intg=prec1-frac1
-        frac=max(frac1, frac2)=to->frac
+        frac=MYSQL_MAX(frac1, frac2)=to->frac
     */
     if (dcarry)
       *--start1=dcarry;
@@ -2319,7 +2319,7 @@
       }
       DBUG_ASSERT(intg0 <= ROUND_UP(from2->intg));
       stop1=start1+frac0+intg0;
-      to->intg=min(intg0*DIG_PER_DEC1, from2->intg);
+      to->intg=MYSQL_MIN(intg0*DIG_PER_DEC1, from2->intg);
     }
     if (unlikely(intg0+frac0 > to->len))
     {
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/my_vsnprintf.c mysql/strings/my_vsnprintf.c
--- mysql.orig/strings/my_vsnprintf.c	2007-12-14 12:43:33.000000000 -0800
+++ mysql/strings/my_vsnprintf.c	2008-01-15 02:59:21.085838998 -0800
@@ -140,7 +140,7 @@
       /* If %#d syntax was used, we have to pre-zero/pre-space the string */
       if (store_start == buff)
       {
-	length= min(length, to_length);
+	length= MYSQL_MIN(length, to_length);
 	if (res_length < length)
 	{
 	  uint diff= (length- res_length);
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/strings/str2int.c mysql/strings/str2int.c
--- mysql.orig/strings/str2int.c	2007-12-14 12:43:51.000000000 -0800
+++ mysql/strings/str2int.c	2008-01-15 02:59:21.085838998 -0800
@@ -82,7 +82,7 @@
       machines all, if +|n| is representable, so is -|n|, but on
       twos complement machines the converse is not true.  So the
       "maximum" representable number has a negative representative.
-      Limit is set to min(-|lower|,-|upper|); this is the "largest"
+      Limit is set to MYSQL_MIN(-|lower|,-|upper|); this is the "largest"
       number we are concerned with.	*/
 
   /*  Calculate Limit using Scale as a scratch variable  */
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/tests/mysql_client_test.c mysql/tests/mysql_client_test.c
--- mysql.orig/tests/mysql_client_test.c	2008-01-15 02:51:18.252555000 -0800
+++ mysql/tests/mysql_client_test.c	2008-01-15 02:59:21.092504605 -0800
@@ -562,7 +562,7 @@
     return row_count;
   }
 
-  field_count= min(mysql_num_fields(result), MAX_RES_FIELDS);
+  field_count= MYSQL_MIN(mysql_num_fields(result), MAX_RES_FIELDS);
 
   bzero((char*) buffer, sizeof(buffer));
   bzero((char*) length, sizeof(length));
diff -Nuar --exclude mysql_client_test.c.orig mysql.orig/vio/viosocket.c mysql/vio/viosocket.c
--- mysql.orig/vio/viosocket.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/vio/viosocket.c	2008-01-15 03:18:31.319897345 -0800
@@ -67,7 +67,7 @@
 
   if (vio->read_pos < vio->read_end)
   {
-    rc= min(vio->read_end - vio->read_pos, size);
+    rc= MYSQL_MIN(vio->read_end - vio->read_pos, size);
     memcpy(buf, vio->read_pos, rc);
     vio->read_pos+= rc;
     /*
diff -Nuar --exclude list mysql.orig/heap/hp_create.c mysql/heap/hp_create.c
--- mysql.orig/heap/hp_create.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/heap/hp_create.c	2008-01-15 05:20:18.576923482 -0800
@@ -215,7 +215,7 @@
 {
   uint i,recbuffer,records_in_block;
 
-  max_records= max(min_records,max_records);
+  max_records= MYSQL_MAX(min_records,max_records);
   if (!max_records)
     max_records= 1000;			/* As good as quess as anything */
   recbuffer= (uint) (reclength + sizeof(byte**) - 1) & ~(sizeof(byte**) - 1);
diff -Nuar --exclude list mysql.orig/heap/hp_test2.c mysql/heap/hp_test2.c
--- mysql.orig/heap/hp_test2.c	2007-12-14 12:42:50.000000000 -0800
+++ mysql/heap/hp_test2.c	2008-01-15 05:20:21.899846014 -0800
@@ -136,7 +136,7 @@
 
   for (i=0 ; i < recant ; i++)
   {
-    n1=rnd(1000); n2=rnd(100); n3=rnd(min(recant*5,MAX_RECORDS));
+    n1=rnd(1000); n2=rnd(100); n3=rnd(MYSQL_MIN(recant*5,MAX_RECORDS));
     make_record(record,n1,n2,n3,"Pos",write_count);
 
     if (heap_write(file,record))
@@ -217,7 +217,7 @@
   printf("- Update\n");
   for (i=0 ; i < write_count/10 ; i++)
   {
-    n1=rnd(1000); n2=rnd(100); n3=rnd(min(recant*2,MAX_RECORDS));
+    n1=rnd(1000); n2=rnd(100); n3=rnd(MYSQL_MIN(recant*2,MAX_RECORDS));
     make_record(record2, n1, n2, n3, "XXX", update);
     if (rnd(2) == 1)
     {
diff -Nuar --exclude list mysql.orig/libmysqld/client.c mysql/libmysqld/client.c
--- mysql.orig/libmysqld/client.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/client.c	2008-01-15 05:00:06.807069490 -0800
@@ -630,7 +630,7 @@
 	pos+= SQLSTATE_LENGTH+1;
       }
       (void) strmake(net->last_error,(char*) pos,
-		     min((uint) len,(uint) sizeof(net->last_error)-1));
+		     MYSQL_MIN((uint) len,(uint) sizeof(net->last_error)-1));
     }
     else
       set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
@@ -2026,7 +2026,7 @@
 	goto error;
       }
       memcpy(&sock_addr.sin_addr, hp->h_addr,
-             min(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
+             MYSQL_MIN(sizeof(sock_addr.sin_addr), (size_t) hp->h_length));
       my_gethostbyname_r_free();
     }
     sock_addr.sin_port = (ushort) htons((ushort) port);
diff -Nuar --exclude list mysql.orig/libmysqld/examples/mysql.cc mysql/libmysqld/examples/mysql.cc
--- mysql.orig/libmysqld/examples/mysql.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/libmysqld/examples/mysql.cc	2008-01-15 04:54:16.436515243 -0800
@@ -2501,9 +2501,9 @@
   {
     uint length= column_names ? field->name_length : 0;
     if (quick)
-      length=max(length,field->length);
+      length=MYSQL_MAX(length,field->length);
     else
-      length=max(length,field->max_length);
+      length=MYSQL_MAX(length,field->max_length);
     if (length < 4 && !IS_NOT_NULL(field->flags))
       length=4;					// Room for "NULL"
     field->max_length=length;
@@ -2523,7 +2523,7 @@
                                                   field->name,
                                                   field->name + name_length);
       uint display_length= field->max_length + name_length - numcells;
-      tee_fprintf(PAGER, " %-*s |",(int) min(display_length,
+      tee_fprintf(PAGER, " %-*s |",(int) MYSQL_MIN(display_length,
                                             MAX_COLUMN_LENGTH),
                   field->name);
       num_flag[off]= IS_NUM(field->type);
diff -Nuar --exclude list mysql.orig/libmysqld/examples/mysql_client_test.c mysql/libmysqld/examples/mysql_client_test.c
--- mysql.orig/libmysqld/examples/mysql_client_test.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/examples/mysql_client_test.c	2008-01-15 04:53:59.241817964 -0800
@@ -562,7 +562,7 @@
     return row_count;
   }
 
-  field_count= min(mysql_num_fields(result), MAX_RES_FIELDS);
+  field_count= MYSQL_MIN(mysql_num_fields(result), MAX_RES_FIELDS);
 
   bzero((char*) buffer, sizeof(buffer));
   bzero((char*) length, sizeof(length));
diff -Nuar --exclude list mysql.orig/libmysqld/examples/mysqltest.c mysql/libmysqld/examples/mysqltest.c
--- mysql.orig/libmysqld/examples/mysqltest.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/libmysqld/examples/mysqltest.c	2008-01-15 04:53:54.975161976 -0800
@@ -4548,9 +4548,9 @@
       }
       else if ((c == '{' &&
                 (!my_strnncoll_simple(charset_info, (const uchar*) "while", 5,
-                                      (uchar*) buf, min(5, p - buf), 0) ||
+                                      (uchar*) buf, MYSQL_MIN(5, p - buf), 0) ||
                  !my_strnncoll_simple(charset_info, (const uchar*) "if", 2,
-                                      (uchar*) buf, min(2, p - buf), 0))))
+                                      (uchar*) buf, MYSQL_MIN(2, p - buf), 0))))
       {
         /* Only if and while commands can be terminated by { */
         *p++= c;
diff -Nuar --exclude list mysql.orig/libmysqld/field.cc mysql/libmysqld/field.cc
--- mysql.orig/libmysqld/field.cc	2007-12-14 12:42:41.000000000 -0800
+++ mysql/libmysqld/field.cc	2008-01-15 04:59:59.525947525 -0800
@@ -49,7 +49,7 @@
 #define LONGLONG_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define DECIMAL_TO_STRING_CONVERSION_BUFFER_SIZE 128
 #define BLOB_PACK_LENGTH_TO_MAX_LENGH(arg) \
-((ulong) ((LL(1) << min(arg, 4) * 8) - LL(1)))
+((ulong) ((LL(1) << MYSQL_MIN(arg, 4) * 8) - LL(1)))
 
 /*
   Rules for merging different types of fields in UNION
@@ -1889,7 +1889,7 @@
     tmp_uint=tmp_dec+(uint)(int_digits_end-int_digits_from);
   else if (expo_sign_char == '-') 
   {
-    tmp_uint=min(exponent,(uint)(int_digits_end-int_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(int_digits_end-int_digits_from));
     frac_digits_added_zeros=exponent-tmp_uint;
     int_digits_end -= tmp_uint;
     frac_digits_head_end=int_digits_end+tmp_uint;
@@ -1897,7 +1897,7 @@
   }
   else // (expo_sign_char=='+') 
   {
-    tmp_uint=min(exponent,(uint)(frac_digits_end-frac_digits_from));
+    tmp_uint=MYSQL_MIN(exponent,(uint)(frac_digits_end-frac_digits_from));
     int_digits_added_zeros=exponent-tmp_uint;
     int_digits_tail_from=frac_digits_from;
     frac_digits_from=frac_digits_from+tmp_uint;
@@ -2708,7 +2708,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,5*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,5*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
 
@@ -2914,7 +2914,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,7*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,7*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   short j;
@@ -3125,7 +3125,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,10*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,10*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   long j= unsigned_flag ? (long) uint3korr(ptr) : sint3korr(ptr);
@@ -3338,7 +3338,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,12*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,12*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   int32 j;
@@ -3573,7 +3573,7 @@
 {
   CHARSET_INFO *cs= &my_charset_bin;
   uint length;
-  uint mlength=max(field_length+1,22*cs->mbmaxlen);
+  uint mlength=MYSQL_MAX(field_length+1,22*cs->mbmaxlen);
   val_buffer->alloc(mlength);
   char *to=(char*) val_buffer->ptr();
   longlong j;
@@ -3750,7 +3750,7 @@
 #endif
     memcpy_fixed((byte*) &nr,ptr,sizeof(nr));
 
-  uint to_length=max(field_length,70);
+  uint to_length=MYSQL_MAX(field_length,70);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -4085,7 +4085,7 @@
 #endif
     doubleget(nr,ptr);
 
-  uint to_length=max(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
+  uint to_length=MYSQL_MAX(field_length, DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE);
   val_buffer->alloc(to_length);
   char *to=(char*) val_buffer->ptr();
 
@@ -5968,13 +5968,13 @@
     calculate the maximum number of significant digits if the 'f'-format
     would be used (+1 for decimal point if the number has a fractional part).
   */
-  digits= max(0, (int) max_length - fractional);
+  digits= MYSQL_MAX(0, (int) max_length - fractional);
   /*
     If the exponent is negative, decrease digits by the number of leading zeros
     after the decimal point that do not count as significant digits.
   */
   if (exp < 0)
-    digits= max(0, (int) digits + exp);
+    digits= MYSQL_MAX(0, (int) digits + exp);
   /*
     'e'-format is used only if the exponent is less than -4 or greater than or
     equal to the precision. In this case we need to adjust the number of
@@ -5982,7 +5982,7 @@
     We also have to reserve one additional character if abs(exp) >= 100.
   */
   if (exp >= (int) digits || exp < -4)
-    digits= max(0, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
+    digits= MYSQL_MAX(0, (int) (max_length - 5 - (exp >= 100 || exp <= -100)));
 
   /* Limit precision to DBL_DIG to avoid garbage past significant digits */
   set_if_smaller(digits, DBL_DIG);
@@ -6171,7 +6171,7 @@
 
 char *Field_string::pack(char *to, const char *from, uint max_length)
 {
-  uint length=      min(field_length,max_length);
+  uint length=      MYSQL_MIN(field_length,max_length);
   uint local_char_length= max_length/field_charset->mbmaxlen;
   if (length > local_char_length)
     local_char_length= my_charpos(field_charset, from, from+length,
@@ -6997,7 +6997,7 @@
     from= tmpstr.ptr();
   }
 
-  new_length= min(max_data_length(), field_charset->mbmaxlen * length);
+  new_length= MYSQL_MIN(max_data_length(), field_charset->mbmaxlen * length);
   if (value.alloc(new_length))
     goto oom_error;
 
@@ -7142,7 +7142,7 @@
   b_length=get_length(b_ptr);
   if (b_length > max_length)
     b_length=max_length;
-  diff=memcmp(a,b,min(a_length,b_length));
+  diff=memcmp(a,b,MYSQL_MIN(a_length,b_length));
   return diff ? diff : (int) (a_length - b_length);
 }
 
@@ -8148,7 +8148,7 @@
                            String *val_ptr __attribute__((unused)))
 {
   char buff[sizeof(longlong)];
-  uint length= min(pack_length(), sizeof(longlong));
+  uint length= MYSQL_MIN(pack_length(), sizeof(longlong));
   ulonglong bits= val_int();
   mi_int8store(buff,bits);
 
@@ -8204,7 +8204,7 @@
     *buff++= bits;
     length--;
   }
-  uint data_length = min(length, bytes_in_rec);
+  uint data_length = MYSQL_MIN(length, bytes_in_rec);
   memcpy(buff, ptr, data_length);
   return data_length + 1;
 }
@@ -8228,7 +8228,7 @@
     uchar bits= get_rec_bits(bit_ptr, bit_ofs, bit_len);
     *to++= bits;
   }
-  length= min(bytes_in_rec, max_length - (bit_len > 0));
+  length= MYSQL_MIN(bytes_in_rec, max_length - (bit_len > 0));
   memcpy(to, from, length);
   return to + length;
 }
@@ -8606,7 +8606,7 @@
         and 19 as length of 4.1 compatible representation.
       */
       length= ((length+1)/2)*2; /* purecov: inspected */
-      length= min(length, MAX_DATETIME_COMPRESSED_WIDTH); /* purecov: inspected */
+      length= MYSQL_MIN(length, MAX_DATETIME_COMPRESSED_WIDTH); /* purecov: inspected */
     }
     flags|= ZEROFILL_FLAG | UNSIGNED_FLAG;
     if (fld_default_value)
diff -Nuar --exclude list mysql.orig/libmysqld/filesort.cc mysql/libmysqld/filesort.cc
--- mysql.orig/libmysqld/filesort.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/libmysqld/filesort.cc	2008-01-15 04:59:40.890111247 -0800
@@ -175,7 +175,7 @@
 #ifdef CAN_TRUST_RANGE
   if (select && select->quick && select->quick->records > 0L)
   {
-    records=min((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
+    records=MYSQL_MIN((ha_rows) (select->quick->records*2+EXTRA_RECORDS*2),
 		table->file->records)+EXTRA_RECORDS;
     selected_records_file=0;
   }
@@ -197,12 +197,12 @@
     goto err;
 
   memavl= thd->variables.sortbuff_size;
-  min_sort_memory= max(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
+  min_sort_memory= MYSQL_MAX(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2);
   while (memavl >= min_sort_memory)
   {
     ulong old_memavl;
     ulong keys= memavl/(param.rec_length+sizeof(char*));
-    param.keys=(uint) min(records+1, keys);
+    param.keys=(uint) MYSQL_MIN(records+1, keys);
     if ((table_sort.sort_keys=
 	 (uchar **) make_char_array((char **) table_sort.sort_keys,
                                     param.keys, param.rec_length, MYF(0))))
@@ -976,7 +976,7 @@
   register uint count;
   uint length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(byte*) buffpek->base,
 		 (length= rec_length*count),buffpek->file_pos,MYF_RW))
@@ -1239,7 +1239,7 @@
          != -1 && error != 0);
 
 end:
-  lastbuff->count= min(org_max_rows-max_rows, param->max_rows);
+  lastbuff->count= MYSQL_MIN(org_max_rows-max_rows, param->max_rows);
   lastbuff->file_pos= to_start_filepos;
 err:
   delete_queue(&queue);
diff -Nuar --exclude list mysql.orig/libmysqld/ha_berkeley.cc mysql/libmysqld/ha_berkeley.cc
--- mysql.orig/libmysqld/ha_berkeley.cc	2007-12-14 12:43:32.000000000 -0800
+++ mysql/libmysqld/ha_berkeley.cc	2008-01-15 04:59:28.155118105 -0800
@@ -159,7 +159,7 @@
   */
   if (!berkeley_log_buffer_size)
   {
-    berkeley_log_buffer_size= max(table_cache_size*512,32*1024);
+    berkeley_log_buffer_size= MYSQL_MAX(table_cache_size*512,32*1024);
   }
   /*
     Berkeley DB require that
@@ -167,7 +167,7 @@
   */
   berkeley_log_file_size= berkeley_log_buffer_size*4;
   berkeley_log_file_size= MY_ALIGN(berkeley_log_file_size,1024*1024L);
-  berkeley_log_file_size= max(berkeley_log_file_size, 10*1024*1024L);
+  berkeley_log_file_size= MYSQL_MAX(berkeley_log_file_size, 10*1024*1024L);
 
   if (db_env_create(&db_env,0))
     goto error;
diff -Nuar --exclude list mysql.orig/libmysqld/ha_federated.cc mysql/libmysqld/ha_federated.cc
--- mysql.orig/libmysqld/ha_federated.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/ha_federated.cc	2008-01-15 04:59:24.729605914 -0800
@@ -511,7 +511,7 @@
     my_free((gptr) share->scheme, MYF(0));
     share->scheme= 0;
   }
-  buf_len= min(table->s->connect_string.length,
+  buf_len= MYSQL_MIN(table->s->connect_string.length,
                FEDERATED_QUERY_BUFFER_SIZE-1);
   strmake(buf, table->s->connect_string.str, buf_len);
   my_error(error_num, MYF(0), buf);
@@ -1086,7 +1086,7 @@
     {
       Field *field= key_part->field;
       uint store_length= key_part->store_length;
-      uint part_length= min(store_length, length);
+      uint part_length= MYSQL_MIN(store_length, length);
       needs_quotes= 1;
       DBUG_DUMP("key, start of loop", (char *) ptr, length);
 
diff -Nuar --exclude list mysql.orig/libmysqld/ha_innodb.cc mysql/libmysqld/ha_innodb.cc
--- mysql.orig/libmysqld/ha_innodb.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/libmysqld/ha_innodb.cc	2008-01-15 04:59:35.739052196 -0800
@@ -627,7 +627,7 @@
 			max_query_len = 300;
 		}
 
-		len = min(thd->query_length, max_query_len);
+		len = MYSQL_MIN(thd->query_length, max_query_len);
 
 		if (len > (sizeof(buf) - 1))
 		{
@@ -6900,7 +6900,7 @@
   			goto func_exit;
   		}
   	} else {
-		/* Initialize to max(col) + 1; we use
+		/* Initialize to MYSQL_MAX(col) + 1; we use
 		'found_next_number_field' below because MySQL in SHOW TABLE
 		STATUS does not seem to set 'next_number_field'. The comment
 		in table.h says that 'next_number_field' is set when it is
diff -Nuar --exclude list mysql.orig/libmysqld/ha_myisam.cc mysql/libmysqld/ha_myisam.cc
--- mysql.orig/libmysqld/ha_myisam.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/libmysqld/ha_myisam.cc	2008-01-15 04:59:21.293632296 -0800
@@ -1411,7 +1411,7 @@
 {
   DBUG_ENTER("ha_myisam::start_bulk_insert");
   THD *thd= current_thd;
-  ulong size= min(thd->variables.read_buff_size,
+  ulong size= MYSQL_MIN(thd->variables.read_buff_size,
                   (ulong) (table->s->avg_row_length*rows));
   DBUG_PRINT("info",("start_bulk_insert: rows %lu size %lu",
                      (ulong) rows, size));
diff -Nuar --exclude list mysql.orig/libmysqld/ha_myisammrg.cc mysql/libmysqld/ha_myisammrg.cc
--- mysql.orig/libmysqld/ha_myisammrg.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/ha_myisammrg.cc	2008-01-15 04:59:18.685951474 -0800
@@ -407,7 +407,7 @@
       memcpy((char*) table->key_info[0].rec_per_key,
 	     (char*) mrg_info.rec_per_key,
              sizeof(table->key_info[0].rec_per_key) *
-             min(file->keys, table->s->key_parts));
+             MYSQL_MIN(file->keys, table->s->key_parts));
     }
   }
   return 0;
diff -Nuar --exclude list mysql.orig/libmysqld/item_buff.cc mysql/libmysqld/item_buff.cc
--- mysql.orig/libmysqld/item_buff.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/libmysqld/item_buff.cc	2008-01-15 04:59:03.295160585 -0800
@@ -51,7 +51,7 @@
 */
 
 Cached_item_str::Cached_item_str(THD *thd, Item *arg)
-  :item(arg), value(min(arg->max_length, thd->variables.max_sort_length))
+  :item(arg), value(MYSQL_MIN(arg->max_length, thd->variables.max_sort_length))
 {}
 
 bool Cached_item_str::cmp(void)
@@ -60,7 +60,7 @@
   bool tmp;
 
   if ((res=item->val_str(&tmp_value)))
-    res->length(min(res->length(), value.alloced_length()));
+    res->length(MYSQL_MIN(res->length(), value.alloced_length()));
   if (null_value != item->null_value)
   {
     if ((null_value= item->null_value))
diff -Nuar --exclude list mysql.orig/libmysqld/item.cc mysql/libmysqld/item.cc
--- mysql.orig/libmysqld/item.cc	2007-12-14 12:42:41.000000000 -0800
+++ mysql/libmysqld/item.cc	2008-01-15 04:59:16.415129429 -0800
@@ -73,7 +73,7 @@
 Hybrid_type_traits_decimal::fix_length_and_dec(Item *item, Item *arg) const
 {
   item->decimals= arg->decimals;
-  item->max_length= min(arg->max_length + DECIMAL_LONGLONG_DIGITS,
+  item->max_length= MYSQL_MIN(arg->max_length + DECIMAL_LONGLONG_DIGITS,
                         DECIMAL_MAX_STR_LENGTH);
 }
 
@@ -429,9 +429,9 @@
   Item_result restype= result_type();
 
   if ((restype == DECIMAL_RESULT) || (restype == INT_RESULT))
-    return min(my_decimal_length_to_precision(max_length, decimals, unsigned_flag),
+    return MYSQL_MIN(my_decimal_length_to_precision(max_length, decimals, unsigned_flag),
                DECIMAL_MAX_PRECISION);
-  return min(max_length, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(max_length, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -720,7 +720,7 @@
 				   &res_length);
   }
   else
-    name= sql_strmake(str, (name_length= min(length,MAX_ALIAS_NAME)));
+    name= sql_strmake(str, (name_length= MYSQL_MIN(length,MAX_ALIAS_NAME)));
 }
 
 
@@ -4774,7 +4774,7 @@
   // following assert is redundant, because fixed=1 assigned in constructor
   DBUG_ASSERT(fixed == 1);
   char *end=(char*) str_value.ptr()+str_value.length(),
-       *ptr=end-min(str_value.length(),sizeof(longlong));
+       *ptr=end-MYSQL_MIN(str_value.length(),sizeof(longlong));
 
   ulonglong value=0;
   for (; ptr != end ; ptr++)
@@ -4826,7 +4826,7 @@
 void Item_hex_string::print(String *str)
 {
   char *end= (char*) str_value.ptr() + str_value.length(),
-       *ptr= end - min(str_value.length(), sizeof(longlong));
+       *ptr= end - MYSQL_MIN(str_value.length(), sizeof(longlong));
   str->append("0x");
   for (; ptr != end ; ptr++)
   {
@@ -6686,12 +6686,12 @@
     /* fix variable decimals which always is NOT_FIXED_DEC */
     if (Field::result_merge_type(fld_type) == INT_RESULT)
       item_decimals= 0;
-    decimals= max(decimals, item_decimals);
+    decimals= MYSQL_MAX(decimals, item_decimals);
   }
   if (Field::result_merge_type(fld_type) == DECIMAL_RESULT)
   {
-    decimals= min(max(decimals, item->decimals), DECIMAL_MAX_SCALE);
-    int precision= min(max(prev_decimal_int_part, item->decimal_int_part())
+    decimals= MYSQL_MIN(MYSQL_MAX(decimals, item->decimals), DECIMAL_MAX_SCALE);
+    int precision= MYSQL_MIN(MYSQL_MAX(prev_decimal_int_part, item->decimal_int_part())
                        + decimals, DECIMAL_MAX_PRECISION);
     unsigned_flag&= item->unsigned_flag;
     max_length= my_decimal_precision_to_length(precision, decimals,
@@ -6722,7 +6722,7 @@
      */
     if (collation.collation != &my_charset_bin)
     {
-      max_length= max(old_max_chars * collation.collation->mbmaxlen,
+      max_length= MYSQL_MAX(old_max_chars * collation.collation->mbmaxlen,
                       display_length(item) /
                       item->collation.collation->mbmaxlen *
                       collation.collation->mbmaxlen);
@@ -6737,7 +6737,7 @@
     {
       int delta1= max_length_orig - decimals_orig;
       int delta2= item->max_length - item->decimals;
-      max_length= max(delta1, delta2) + decimals;
+      max_length= MYSQL_MAX(delta1, delta2) + decimals;
       if (fld_type == MYSQL_TYPE_FLOAT && max_length > FLT_DIG + 2) 
       {
         max_length= FLT_DIG + 6;
@@ -6754,7 +6754,7 @@
     break;
   }
   default:
-    max_length= max(max_length, display_length(item));
+    max_length= MYSQL_MAX(max_length, display_length(item));
   };
   maybe_null|= item->maybe_null;
   get_full_info(item);
diff -Nuar --exclude list mysql.orig/libmysqld/item_cmpfunc.cc mysql/libmysqld/item_cmpfunc.cc
--- mysql.orig/libmysqld/item_cmpfunc.cc	2007-12-14 12:43:41.000000000 -0800
+++ mysql/libmysqld/item_cmpfunc.cc	2008-01-15 04:58:58.609723157 -0800
@@ -554,7 +554,7 @@
   {
     if ((*a)->decimals < NOT_FIXED_DEC && (*b)->decimals < NOT_FIXED_DEC)
     {
-      precision= 5 / log_10[max((*a)->decimals, (*b)->decimals) + 1];
+      precision= 5 / log_10[MYSQL_MAX((*a)->decimals, (*b)->decimals) + 1];
       if (func == &Arg_comparator::compare_real)
         func= &Arg_comparator::compare_real_fixed;
       else if (func == &Arg_comparator::compare_e_real)
@@ -1039,7 +1039,7 @@
       owner->null_value= 0;
       uint res1_length= res1->length();
       uint res2_length= res2->length();
-      int cmp= memcmp(res1->ptr(), res2->ptr(), min(res1_length,res2_length));
+      int cmp= memcmp(res1->ptr(), res2->ptr(), MYSQL_MIN(res1_length,res2_length));
       return cmp ? cmp : (int) (res1_length - res2_length);
     }
   }
@@ -2062,7 +2062,7 @@
 {
   agg_result_type(&hybrid_type, args, 2);
   maybe_null=args[1]->maybe_null;
-  decimals= max(args[0]->decimals, args[1]->decimals);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
   unsigned_flag= args[0]->unsigned_flag && args[1]->unsigned_flag;
 
   if (hybrid_type == DECIMAL_RESULT || hybrid_type == INT_RESULT) 
@@ -2073,10 +2073,10 @@
     int len1= args[1]->max_length - args[1]->decimals
       - (args[1]->unsigned_flag ? 0 : 1);
 
-    max_length= max(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
+    max_length= MYSQL_MAX(len0, len1) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[0]->max_length, args[1]->max_length);
+    max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 
   switch (hybrid_type) {
   case STRING_RESULT:
@@ -2098,8 +2098,8 @@
 
 uint Item_func_ifnull::decimal_precision() const
 {
-  int max_int_part=max(args[0]->decimal_int_part(),args[1]->decimal_int_part());
-  return min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  int max_int_part=MYSQL_MAX(args[0]->decimal_int_part(),args[1]->decimal_int_part());
+  return MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -2228,7 +2228,7 @@
 Item_func_if::fix_length_and_dec()
 {
   maybe_null=args[1]->maybe_null || args[2]->maybe_null;
-  decimals= max(args[1]->decimals, args[2]->decimals);
+  decimals= MYSQL_MAX(args[1]->decimals, args[2]->decimals);
   unsigned_flag=args[1]->unsigned_flag && args[2]->unsigned_flag;
 
   enum Item_result arg1_type=args[1]->result_type();
@@ -2272,18 +2272,18 @@
     int len2= args[2]->max_length - args[2]->decimals
       - (args[2]->unsigned_flag ? 0 : 1);
 
-    max_length=max(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
+    max_length=MYSQL_MAX(len1, len2) + decimals + (unsigned_flag ? 0 : 1);
   }
   else
-    max_length= max(args[1]->max_length, args[2]->max_length);
+    max_length= MYSQL_MAX(args[1]->max_length, args[2]->max_length);
 }
 
 
 uint Item_func_if::decimal_precision() const
 {
-  int precision=(max(args[1]->decimal_int_part(),args[2]->decimal_int_part())+
+  int precision=(MYSQL_MAX(args[1]->decimal_int_part(),args[2]->decimal_int_part())+
                  decimals);
-  return min(precision, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(precision, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -2708,7 +2708,7 @@
 
   if (else_expr_num != -1) 
     set_if_bigger(max_int_part, args[else_expr_num]->decimal_int_part());
-  return min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  return MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
 }
 
 
@@ -4647,14 +4647,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) (uchar) text[i + j]] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
@@ -4678,14 +4678,14 @@
       register const int v = plm1 - i;
       turboShift = u - v;
       bcShift    = bmBc[(uint) likeconv(cs, text[i + j])] - plm1 + i;
-      shift      = max(turboShift, bcShift);
-      shift      = max(shift, bmGs[i]);
+      shift      = MYSQL_MAX(turboShift, bcShift);
+      shift      = MYSQL_MAX(shift, bmGs[i]);
       if (shift == bmGs[i])
-	u = min(pattern_len - shift, v);
+	u = MYSQL_MIN(pattern_len - shift, v);
       else
       {
 	if (turboShift < bcShift)
-	  shift = max(shift, u + 1);
+	  shift = MYSQL_MAX(shift, u + 1);
 	u = 0;
       }
       j+= shift;
diff -Nuar --exclude list mysql.orig/libmysqld/item_func.cc mysql/libmysqld/item_func.cc
--- mysql.orig/libmysqld/item_func.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/libmysqld/item_func.cc	2008-01-15 04:58:29.481801779 -0800
@@ -539,7 +539,7 @@
     set_if_bigger(max_int_part, args[i]->decimal_int_part());
     set_if_smaller(unsigned_flag, args[i]->unsigned_flag);
   }
-  int precision= min(max_int_part + decimals, DECIMAL_MAX_PRECISION);
+  int precision= MYSQL_MIN(max_int_part + decimals, DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length(precision, decimals,
                                              unsigned_flag);
 }
@@ -1155,10 +1155,10 @@
 */
 void Item_func_additive_op::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
-  int max_int_part= max(args[0]->decimal_precision() - args[0]->decimals,
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
+  int max_int_part= MYSQL_MAX(args[0]->decimal_precision() - args[0]->decimals,
                         args[1]->decimal_precision() - args[1]->decimals);
-  int precision= min(max_int_part + 1 + decimals, DECIMAL_MAX_PRECISION);
+  int precision= MYSQL_MIN(max_int_part + 1 + decimals, DECIMAL_MAX_PRECISION);
 
   /* Integer operations keep unsigned_flag if one of arguments is unsigned */
   if (result_type() == INT_RESULT)
@@ -1266,8 +1266,8 @@
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
-  int precision= min(args[0]->decimal_precision() + args[1]->decimal_precision(),
+  decimals= MYSQL_MIN(args[0]->decimals + args[1]->decimals, DECIMAL_MAX_SCALE);
+  int precision= MYSQL_MIN(args[0]->decimal_precision() + args[1]->decimal_precision(),
                      DECIMAL_MAX_PRECISION);
   max_length= my_decimal_precision_to_length(precision, decimals,unsigned_flag);
 }
@@ -1315,14 +1315,14 @@
 
 void Item_func_div::result_precision()
 {
-  uint precision=min(args[0]->decimal_precision() + prec_increment,
+  uint precision=MYSQL_MIN(args[0]->decimal_precision() + prec_increment,
                      DECIMAL_MAX_PRECISION);
   /* Integer operations keep unsigned_flag if one of arguments is unsigned */
   if (result_type() == INT_RESULT)
     unsigned_flag= args[0]->unsigned_flag | args[1]->unsigned_flag;
   else
     unsigned_flag= args[0]->unsigned_flag & args[1]->unsigned_flag;
-  decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+  decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
   max_length= my_decimal_precision_to_length(precision, decimals,
                                              unsigned_flag);
 }
@@ -1336,7 +1336,7 @@
   switch(hybrid_type) {
   case REAL_RESULT:
   {
-    decimals=max(args[0]->decimals,args[1]->decimals)+prec_increment;
+    decimals=MYSQL_MAX(args[0]->decimals,args[1]->decimals)+prec_increment;
     set_if_smaller(decimals, NOT_FIXED_DEC);
     max_length=args[0]->max_length - args[0]->decimals + decimals;
     uint tmp=float_length(decimals);
@@ -1458,8 +1458,8 @@
 
 void Item_func_mod::result_precision()
 {
-  decimals= max(args[0]->decimals, args[1]->decimals);
-  max_length= max(args[0]->max_length, args[1]->max_length);
+  decimals= MYSQL_MAX(args[0]->decimals, args[1]->decimals);
+  max_length= MYSQL_MAX(args[0]->max_length, args[1]->max_length);
 }
 
 
@@ -1977,7 +1977,7 @@
   if (args[0]->decimals == NOT_FIXED_DEC)
   {
     max_length= args[0]->max_length;
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     hybrid_type= REAL_RESULT;
     return;
   }
@@ -1986,7 +1986,7 @@
   case REAL_RESULT:
   case STRING_RESULT:
     hybrid_type= REAL_RESULT;
-    decimals= min(decimals_to_set, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(decimals_to_set, NOT_FIXED_DEC);
     max_length= float_length(decimals);
     break;
   case INT_RESULT:
@@ -2003,7 +2003,7 @@
   case DECIMAL_RESULT:
   {
     hybrid_type= DECIMAL_RESULT;
-    decimals_to_set= min(DECIMAL_MAX_SCALE, decimals_to_set);
+    decimals_to_set= MYSQL_MIN(DECIMAL_MAX_SCALE, decimals_to_set);
     int decimals_delta= args[0]->decimals - decimals_to_set;
     int precision= args[0]->decimal_precision();
     int length_increase= ((decimals_delta <= 0) || truncate) ? 0:1;
@@ -2110,7 +2110,7 @@
   longlong dec= args[1]->val_int();
   if (dec > 0 || (dec < 0 && args[1]->unsigned_flag))
   {
-    dec= min((ulonglong) dec, decimals);
+    dec= MYSQL_MIN((ulonglong) dec, decimals);
     decimals= (uint8) dec; // to get correct output
   }
   else if (dec < INT_MIN)
@@ -2965,7 +2965,7 @@
       free_udf(u_d);
       DBUG_RETURN(TRUE);
     }
-    func->max_length=min(initid.max_length,MAX_BLOB_WIDTH);
+    func->max_length=MYSQL_MIN(initid.max_length,MAX_BLOB_WIDTH);
     func->maybe_null=initid.maybe_null;
     const_item_cache=initid.const_item;
     /* 
@@ -2974,7 +2974,7 @@
     */  
     if (!const_item_cache && !used_tables_cache)
       used_tables_cache= RAND_TABLE_BIT;
-    func->decimals=min(initid.decimals,NOT_FIXED_DEC);
+    func->decimals=MYSQL_MIN(initid.decimals,NOT_FIXED_DEC);
   }
   initialized=1;
   if (error)
diff -Nuar --exclude list mysql.orig/libmysqld/item_strfunc.cc mysql/libmysqld/item_strfunc.cc
--- mysql.orig/libmysqld/item_strfunc.cc	2007-12-14 12:43:24.000000000 -0800
+++ mysql/libmysqld/item_strfunc.cc	2008-01-15 04:58:11.691803743 -0800
@@ -1138,7 +1138,7 @@
 
   length= res->charpos((int) length, (uint32) start);
   tmp_length= res->length() - start;
-  length= min(length, tmp_length);
+  length= MYSQL_MIN(length, tmp_length);
 
   if (!start && (longlong) res->length() == length)
     return res;
@@ -1158,7 +1158,7 @@
     if (start < 0)
       max_length= ((uint)(-start) > max_length) ? 0 : (uint)(-start);
     else
-      max_length-= min((uint)(start - 1), max_length);
+      max_length-= MYSQL_MIN((uint)(start - 1), max_length);
   }
   if (arg_count == 3 && args[2]->const_item())
   {
@@ -1832,7 +1832,7 @@
   if ((null_value= args[0]->null_value))
     return 0; /* purecov: inspected */
 
-  if (tmp_value.alloc(max(res->length(), 4 * cs->mbminlen)))
+  if (tmp_value.alloc(MYSQL_MAX(res->length(), 4 * cs->mbminlen)))
     return str; /* purecov: inspected */
   char *to= (char *) tmp_value.ptr();
   char *to_end= to + tmp_value.alloced_length();
@@ -2933,11 +2933,11 @@
 
 void Item_func_export_set::fix_length_and_dec()
 {
-  uint length=max(args[1]->max_length,args[2]->max_length);
+  uint length=MYSQL_MAX(args[1]->max_length,args[2]->max_length);
   uint sep_length=(arg_count > 3 ? args[3]->max_length : 1);
   max_length=length*64+sep_length*63;
 
-  if (agg_arg_charsets(collation, args+1, min(4,arg_count)-1,
+  if (agg_arg_charsets(collation, args+1, MYSQL_MIN(4,arg_count)-1,
                        MY_COLL_ALLOW_CONV, 1))
     return;
 }
diff -Nuar --exclude list mysql.orig/libmysqld/item_sum.cc mysql/libmysqld/item_sum.cc
--- mysql.orig/libmysqld/item_sum.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/libmysqld/item_sum.cc	2008-01-15 04:58:04.956601763 -0800
@@ -1063,7 +1063,7 @@
     AVG() will divide val by count. We need to reserve digits
     after decimal point as the result can be fractional.
   */
-  decimals= min(decimals + prec_increment, NOT_FIXED_DEC);
+  decimals= MYSQL_MIN(decimals + prec_increment, NOT_FIXED_DEC);
 }
 
 
@@ -1126,15 +1126,15 @@
   if (hybrid_type == DECIMAL_RESULT)
   {
     int precision= args[0]->decimal_precision() + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length(precision, decimals,
                                                unsigned_flag);
-    f_precision= min(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
+    f_precision= MYSQL_MIN(precision+DECIMAL_LONGLONG_DIGITS, DECIMAL_MAX_PRECISION);
     f_scale=  args[0]->decimals;
     dec_bin_size= my_decimal_get_binary_size(f_precision, f_scale);
   }
   else {
-    decimals= min(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, NOT_FIXED_DEC);
     max_length= args[0]->max_length + prec_increment;
   }
 }
@@ -1313,13 +1313,13 @@
   switch (args[0]->result_type()) {
   case REAL_RESULT:
   case STRING_RESULT:
-    decimals= min(args[0]->decimals + 4, NOT_FIXED_DEC);
+    decimals= MYSQL_MIN(args[0]->decimals + 4, NOT_FIXED_DEC);
     break;
   case INT_RESULT:
   case DECIMAL_RESULT:
   {
     int precision= args[0]->decimal_precision()*2 + prec_increment;
-    decimals= min(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
+    decimals= MYSQL_MIN(args[0]->decimals + prec_increment, DECIMAL_MAX_SCALE);
     max_length= my_decimal_precision_to_length(precision, decimals,
                                                unsigned_flag);
 
@@ -3380,7 +3380,7 @@
       duplicate values (according to the syntax of this function). If there
       is no DISTINCT or ORDER BY clauses, we don't create this tree.
     */
-    init_tree(tree, (uint) min(thd->variables.max_heap_table_size,
+    init_tree(tree, (uint) MYSQL_MIN(thd->variables.max_heap_table_size,
                                thd->variables.sortbuff_size/16), 0,
               tree_key_length, compare_key, 0, NULL, (void*) this);
   }
diff -Nuar --exclude list mysql.orig/libmysqld/item_timefunc.cc mysql/libmysqld/item_timefunc.cc
--- mysql.orig/libmysqld/item_timefunc.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/libmysqld/item_timefunc.cc	2008-01-15 04:57:57.533455689 -0800
@@ -306,14 +306,14 @@
       switch (*++ptr) {
 	/* Year */
       case 'Y':
-	tmp= (char*) val + min(4, val_len);
+	tmp= (char*) val + MYSQL_MIN(4, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
         if ((int) (tmp-val) <= 2)
           l_time->year= year_2000_handling(l_time->year);
 	val= tmp;
 	break;
       case 'y':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->year= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
         l_time->year= year_2000_handling(l_time->year);
@@ -322,7 +322,7 @@
 	/* Month */
       case 'm':
       case 'c':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->month= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -339,15 +339,15 @@
 	/* Day */
       case 'd':
       case 'e':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
       case 'D':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->day= (int) my_strtoll10(val, &tmp, &error);
 	/* Skip 'st, 'nd, 'th .. */
-	val= tmp + min((int) (val_end-tmp), 2);
+	val= tmp + MYSQL_MIN((int) (val_end-tmp), 2);
 	break;
 
 	/* Hour */
@@ -358,14 +358,14 @@
 	/* fall through */
       case 'k':
       case 'H':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->hour= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
 
 	/* Minute */
       case 'i':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->minute= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -373,7 +373,7 @@
 	/* Second */
       case 's':
       case 'S':
-	tmp= (char*) val + min(2, val_len);
+	tmp= (char*) val + MYSQL_MIN(2, val_len);
 	l_time->second= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -425,7 +425,7 @@
 	val= tmp;
 	break;
       case 'j':
-	tmp= (char*) val + min(val_len, 3);
+	tmp= (char*) val + MYSQL_MIN(val_len, 3);
 	yearday= (int) my_strtoll10(val, &tmp, &error);
 	val= tmp;
 	break;
@@ -437,7 +437,7 @@
       case 'u':
         sunday_first_n_first_week_non_iso= (*ptr=='U' || *ptr== 'V');
         strict_week_number= (*ptr=='V' || *ptr=='v');
-	tmp= (char*) val + min(val_len, 2);
+	tmp= (char*) val + MYSQL_MIN(val_len, 2);
 	if ((week_number= (int) my_strtoll10(val, &tmp, &error)) < 0 ||
             strict_week_number && !week_number ||
             week_number > 53)
@@ -449,7 +449,7 @@
       case 'X':
       case 'x':
         strict_week_number_year_type= (*ptr=='X');
-        tmp= (char*) val + min(4, val_len);
+        tmp= (char*) val + MYSQL_MIN(4, val_len);
         strict_week_number_year= (int) my_strtoll10(val, &tmp, &error);
         val= tmp;
         break;
@@ -594,7 +594,7 @@
 err:
   {
     char buff[128];
-    strmake(buff, val_begin, min(length, sizeof(buff)-1));
+    strmake(buff, val_begin, MYSQL_MIN(length, sizeof(buff)-1));
     push_warning_printf(current_thd, MYSQL_ERROR::WARN_LEVEL_ERROR,
                         ER_WRONG_VALUE_FOR_TYPE, ER(ER_WRONG_VALUE_FOR_TYPE),
                         date_time_type, buff, "str_to_time");
@@ -1731,7 +1731,7 @@
   else
   {
     fixed_length=0;
-    max_length=min(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
+    max_length=MYSQL_MIN(arg1->max_length, MAX_BLOB_WIDTH) * 10 *
                    collation.collation->mbmaxlen;
     set_if_smaller(max_length,MAX_BLOB_WIDTH);
   }
diff -Nuar --exclude list mysql.orig/libmysqld/key.cc mysql/libmysqld/key.cc
--- mysql.orig/libmysqld/key.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/libmysqld/key.cc	2008-01-15 04:57:45.439625295 -0800
@@ -110,13 +110,13 @@
         key_part->key_part_flag & HA_VAR_LENGTH_PART)
     {
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       key_part->field->get_key_image((char*) to_key, length, Field::itRAW);
       to_key+= HA_KEY_BLOB_LENGTH;
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       Field *field= key_part->field;
       CHARSET_INFO *cs= field->charset();
       uint bytes= field->get_key_image((char*) to_key, length, Field::itRAW);
@@ -191,13 +191,13 @@
     else if (key_part->key_part_flag & HA_VAR_LENGTH_PART)
     {
       key_length-= HA_KEY_BLOB_LENGTH;
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       key_part->field->set_key_image((char *) from_key, length);
       from_key+= HA_KEY_BLOB_LENGTH;
     }
     else
     {
-      length= min(key_length, key_part->length);
+      length= MYSQL_MIN(key_length, key_part->length);
       memcpy(to_record + key_part->offset, from_key, (size_t) length);
     }
     from_key+= length;
@@ -257,7 +257,7 @@
 	return 1;
       continue;
     }
-    length= min((uint) (key_end-key), store_length);
+    length= MYSQL_MIN((uint) (key_end-key), store_length);
     if (!(key_part->key_type & (FIELDFLAG_NUMBER+FIELDFLAG_BINARY+
                                 FIELDFLAG_PACK)))
     {
@@ -311,7 +311,7 @@
     {
       field->val_str(&tmp);
       if (key_part->length < field->pack_length())
-	tmp.length(min(tmp.length(),key_part->length));
+	tmp.length(MYSQL_MIN(tmp.length(),key_part->length));
       to->append(tmp);
     }
     else
diff -Nuar --exclude list mysql.orig/libmysqld/libmysql.c mysql/libmysqld/libmysql.c
--- mysql.orig/libmysqld/libmysql.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/libmysql.c	2008-01-15 05:00:13.572819445 -0800
@@ -1558,7 +1558,7 @@
   my_net_set_read_timeout(net, CLIENT_NET_READ_TIMEOUT);
   my_net_set_write_timeout(net, CLIENT_NET_WRITE_TIMEOUT);
   net->retry_count=  1;
-  net->max_packet_size= max(net_buffer_length, max_allowed_packet);
+  net->max_packet_size= MYSQL_MAX(net_buffer_length, max_allowed_packet);
 }
 
 /*
@@ -3562,7 +3562,7 @@
       copy_length= end - start;
       /* We've got some data beyond offset: copy up to buffer_length bytes */
       if (param->buffer_length)
-        memcpy(buffer, start, min(copy_length, param->buffer_length));
+        memcpy(buffer, start, MYSQL_MIN(copy_length, param->buffer_length));
     }
     else
       copy_length= 0;
@@ -3794,9 +3794,9 @@
         precisions. This will ensure that on the same machine you get the
         same value as a string independent of the protocol you use.
       */
-      sprintf(buff, "%-*.*g", (int) min(sizeof(buff)-1,
+      sprintf(buff, "%-*.*g", (int) MYSQL_MIN(sizeof(buff)-1,
                                         param->buffer_length),
-	      min(14,width), value);
+	      MYSQL_MIN(14,width), value);
       end= strcend(buff, ' ');
       *end= 0;
     }
@@ -4113,7 +4113,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   *param->length= length;
   *param->error= copy_length < length;
@@ -4125,7 +4125,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   /* Add an end null if there is room in the buffer */
   if (copy_length != param->buffer_length)
diff -Nuar --exclude list mysql.orig/libmysqld/log.cc mysql/libmysqld/log.cc
--- mysql.orig/libmysqld/log.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/libmysqld/log.cc	2008-01-15 04:57:36.468463518 -0800
@@ -458,7 +458,7 @@
   {
     char *p = fn_ext(log_name);
     uint length=(uint) (p-log_name);
-    strmake(buff,log_name,min(length,FN_REFLEN));
+    strmake(buff,log_name,MYSQL_MIN(length,FN_REFLEN));
     return (const char*)buff;
   }
   return log_name;
@@ -2407,7 +2407,7 @@
   DBUG_ENTER("print_buffer_to_nt_eventlog");
 
   /* Add ending CR/LF's to string, overwrite last chars if necessary */
-  strmov(buffptr+min(length, buffLen-5), "\r\n\r\n");
+  strmov(buffptr+MYSQL_MIN(length, buffLen-5), "\r\n\r\n");
 
   setup_windows_event_source();
   if ((event= RegisterEventSource(NULL,"MySQL")))
diff -Nuar --exclude list mysql.orig/libmysqld/log_event.cc mysql/libmysqld/log_event.cc
--- mysql.orig/libmysqld/log_event.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/libmysqld/log_event.cc	2008-01-15 04:57:31.873287310 -0800
@@ -772,7 +772,7 @@
     of 13 bytes, whereas LOG_EVENT_MINIMAL_HEADER_LEN is 19 bytes (it's
     "minimal" over the set {MySQL >=4.0}).
   */
-  uint header_size= min(description_event->common_header_len,
+  uint header_size= MYSQL_MIN(description_event->common_header_len,
                         LOG_EVENT_MINIMAL_HEADER_LEN);
 
   LOCK_MUTEX;
@@ -1551,7 +1551,7 @@
       be even bigger, but this will suffice to catch most corruption
       errors that can lead to a crash.
     */
-    if (status_vars_len > min(data_len, MAX_SIZE_LOG_EVENT_STATUS))
+    if (status_vars_len > MYSQL_MIN(data_len, MAX_SIZE_LOG_EVENT_STATUS))
     {
       DBUG_PRINT("info", ("status_vars_len (%u) > data_len (%lu); query= 0",
                           status_vars_len, data_len));
@@ -3936,7 +3936,7 @@
   char buf[UV_NAME_LEN_SIZE];
   char buf1[UV_VAL_IS_NULL + UV_VAL_TYPE_SIZE + 
 	    UV_CHARSET_NUMBER_SIZE + UV_VAL_LEN_SIZE];
-  char buf2[max(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
+  char buf2[MYSQL_MAX(8, DECIMAL_MAX_FIELD_SIZE + 2)], *pos= buf2;
   uint buf1_length;
   ulong event_length;
 
diff -Nuar --exclude list mysql.orig/libmysqld/my_time.c mysql/libmysqld/my_time.c
--- mysql.orig/libmysqld/my_time.c	2007-12-14 12:43:13.000000000 -0800
+++ mysql/libmysqld/my_time.c	2008-01-15 05:00:02.886165492 -0800
@@ -251,7 +251,7 @@
     2003-03-03 20:00:20 AM
     20:00:20.000000 AM 03-03-2000
   */
-  i= max((uint) format_position[0], (uint) format_position[1]);
+  i= MYSQL_MAX((uint) format_position[0], (uint) format_position[1]);
   set_if_bigger(i, (uint) format_position[2]);
   allow_space= ((1 << i) | (1 << format_position[6]));
   allow_space&= (1 | 2 | 4 | 8);
diff -Nuar --exclude list mysql.orig/libmysqld/net_serv.cc mysql/libmysqld/net_serv.cc
--- mysql.orig/libmysqld/net_serv.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/net_serv.cc	2008-01-15 04:57:16.804037492 -0800
@@ -759,7 +759,7 @@
   {
     while (remain > 0)
     {
-      uint length= min(remain, net->max_packet);
+      uint length= MYSQL_MIN(remain, net->max_packet);
       if (net_safe_read(net, (char*) net->buff, length, alarmed))
 	DBUG_RETURN(1);
       update_statistics(thd_increment_bytes_received(length));
@@ -930,7 +930,7 @@
 	len=uint3korr(net->buff+net->where_b);
 	if (!len)				/* End of big multi-packet */
 	  goto end;
-	helping = max(len,*complen) + net->where_b;
+	helping = MYSQL_MAX(len,*complen) + net->where_b;
 	/* The necessary size of net->buff */
 	if (helping >= net->max_packet)
 	{
diff -Nuar --exclude list mysql.orig/libmysqld/opt_range.cc mysql/libmysqld/opt_range.cc
--- mysql.orig/libmysqld/opt_range.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/opt_range.cc	2008-01-15 04:57:11.205132367 -0800
@@ -2446,7 +2446,7 @@
     {
       imerge_trp->read_cost= imerge_cost;
       imerge_trp->records= non_cpk_scan_records + cpk_scan_records;
-      imerge_trp->records= min(imerge_trp->records,
+      imerge_trp->records= MYSQL_MIN(imerge_trp->records,
                                param->table->file->records);
       imerge_trp->range_scans= range_scans;
       imerge_trp->range_scans_end= range_scans + n_child_scans;
@@ -5876,7 +5876,7 @@
   char *tmp_min_key, *tmp_max_key;
   uint8 save_first_null_comp= param->first_null_comp;
 
-  param->max_key_part=max(param->max_key_part,key_tree->part);
+  param->max_key_part=MYSQL_MAX(param->max_key_part,key_tree->part);
   if (key_tree->left != &null_element)
   {
     /*
@@ -6765,13 +6765,13 @@
   /* Do not allocate the buffers twice. */
   if (multi_range_length)
   {
-    DBUG_ASSERT(multi_range_length == min(multi_range_count, ranges.elements));
+    DBUG_ASSERT(multi_range_length == MYSQL_MIN(multi_range_count, ranges.elements));
     DBUG_RETURN(0);
   }
 
   /* Allocate the ranges array. */
   DBUG_ASSERT(ranges.elements);
-  multi_range_length= min(multi_range_count, ranges.elements);
+  multi_range_length= MYSQL_MIN(multi_range_count, ranges.elements);
   DBUG_ASSERT(multi_range_length > 0);
   while (multi_range_length && ! (multi_range= (KEY_MULTI_RANGE*)
                                   my_malloc(multi_range_length *
@@ -6790,7 +6790,7 @@
   /* Allocate the handler buffer if necessary.  */
   if (file->table_flags() & HA_NEED_READ_RANGE_BUFFER)
   {
-    mrange_bufsiz= min(multi_range_bufsiz,
+    mrange_bufsiz= MYSQL_MIN(multi_range_bufsiz,
                        ((uint)QUICK_SELECT_I::records + 1)* head->s->reclength);
 
     while (mrange_bufsiz &&
@@ -6858,7 +6858,7 @@
       }
     }
 
-    uint count= min(multi_range_length, ranges.elements -
+    uint count= MYSQL_MIN(multi_range_length, ranges.elements -
                     (cur_range - (QUICK_RANGE**) ranges.buffer));
     if (count == 0)
     {
@@ -6959,12 +6959,12 @@
     last_range= *(cur_range++);
 
     start_key.key=    (const byte*) last_range->min_key;
-    start_key.length= min(last_range->min_length, prefix_length);
+    start_key.length= MYSQL_MIN(last_range->min_length, prefix_length);
     start_key.flag=   ((last_range->flag & NEAR_MIN) ? HA_READ_AFTER_KEY :
 		       (last_range->flag & EQ_RANGE) ?
 		       HA_READ_KEY_EXACT : HA_READ_KEY_OR_NEXT);
     end_key.key=      (const byte*) last_range->max_key;
-    end_key.length=   min(last_range->max_length, prefix_length);
+    end_key.length=   MYSQL_MIN(last_range->max_length, prefix_length);
     /*
       We use READ_AFTER_KEY here because if we are reading on a key
       prefix we want to find all keys with this prefix
@@ -7260,7 +7260,7 @@
   KEY_PART *key_part = key_parts,
            *key_part_end= key_part+used_key_parts;
 
-  for (offset= 0,  end = min(range_arg->min_length, range_arg->max_length) ;
+  for (offset= 0,  end = MYSQL_MIN(range_arg->min_length, range_arg->max_length) ;
        offset < end && key_part != key_part_end ;
        offset+= key_part++->store_length)
   {
@@ -7835,7 +7835,7 @@
         cur_group_prefix_len+= cur_part->store_length;
         cur_used_key_parts.set_bit(key_part_nr);
         ++cur_group_key_parts;
-        max_key_part= max(max_key_part,key_part_nr);
+        max_key_part= MYSQL_MAX(max_key_part,key_part_nr);
       }
       /*
         Check that used key parts forms a prefix of the index.
@@ -8440,9 +8440,9 @@
     {
       double blocks_per_group= (double) num_blocks / (double) num_groups;
       p_overlap= (blocks_per_group * (keys_per_subgroup - 1)) / keys_per_group;
-      p_overlap= min(p_overlap, 1.0);
+      p_overlap= MYSQL_MIN(p_overlap, 1.0);
     }
-    io_cost= (double) min(num_groups * (1 + p_overlap), num_blocks);
+    io_cost= (double) MYSQL_MIN(num_groups * (1 + p_overlap), num_blocks);
   }
   else
     io_cost= (keys_per_group > keys_per_block) ?
diff -Nuar --exclude list mysql.orig/libmysqld/protocol.cc mysql/libmysqld/protocol.cc
--- mysql.orig/libmysqld/protocol.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/protocol.cc	2008-01-15 04:57:24.735204042 -0800
@@ -190,7 +190,7 @@
   length=sizeof(text_pos)-1;
 #endif
   length=my_vsnprintf(my_const_cast(char*) (text_pos),
-                      min(length, sizeof(net->last_error)),
+                      MYSQL_MIN(length, sizeof(net->last_error)),
                       format,args);
   va_end(args);
 
@@ -296,7 +296,7 @@
     pos+=2;
 
     /* We can only return up to 65535 warnings in two bytes */
-    uint tmp= min(thd->total_warn_count, 65535);
+    uint tmp= MYSQL_MIN(thd->total_warn_count, 65535);
     int2store(pos, tmp);
     pos+= 2;
   }
@@ -371,7 +371,7 @@
       Don't send warn count during SP execution, as the warn_list
       is cleared between substatements, and mysqltest gets confused
     */
-    uint tmp= (thd->spcont ? 0 : min(thd->total_warn_count, 65535));
+    uint tmp= (thd->spcont ? 0 : MYSQL_MIN(thd->total_warn_count, 65535));
     buff[0]= 254;
     int2store(buff+1, tmp);
     /*
diff -Nuar --exclude list mysql.orig/libmysqld/set_var.cc mysql/libmysqld/set_var.cc
--- mysql.orig/libmysqld/set_var.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/libmysqld/set_var.cc	2008-01-15 04:55:11.850517748 -0800
@@ -1813,7 +1813,7 @@
 					    &not_used));
     if (error_len)
     {
-      strmake(buff, error, min(sizeof(buff) - 1, error_len));
+      strmake(buff, error, MYSQL_MIN(sizeof(buff) - 1, error_len));
       goto err;
     }
   }
diff -Nuar --exclude list mysql.orig/libmysqld/sp_head.cc mysql/libmysqld/sp_head.cc
--- mysql.orig/libmysqld/sp_head.cc	2007-12-14 12:43:00.000000000 -0800
+++ mysql/libmysqld/sp_head.cc	2008-01-15 04:54:24.706976834 -0800
@@ -2161,7 +2161,7 @@
   field_list.push_back(new Item_empty_string("sql_mode", sql_mode_len));
   // 1024 is for not to confuse old clients
   Item_empty_string *definition=
-    new Item_empty_string("Create Procedure", max(buffer.length(),1024));
+    new Item_empty_string("Create Procedure", MYSQL_MAX(buffer.length(),1024));
   definition->maybe_null= TRUE;
   field_list.push_back(definition);
 
@@ -2231,7 +2231,7 @@
   field_list.push_back(new Item_empty_string("Function",NAME_LEN));
   field_list.push_back(new Item_empty_string("sql_mode", sql_mode_len));
   Item_empty_string *definition=
-    new Item_empty_string("Create Function", max(buffer.length(),1024));
+    new Item_empty_string("Create Function", MYSQL_MAX(buffer.length(),1024));
   definition->maybe_null= TRUE;
   field_list.push_back(definition);
 
@@ -2380,7 +2380,7 @@
   field_list.push_back(new Item_uint("Pos", 9));
   // 1024 is for not to confuse old clients
   field_list.push_back(new Item_empty_string("Instruction",
-					     max(buffer.length(), 1024)));
+					     MYSQL_MAX(buffer.length(), 1024)));
   if (protocol->send_fields(&field_list, Protocol::SEND_NUM_ROWS |
                                          Protocol::SEND_EOF))
     DBUG_RETURN(1);
diff -Nuar --exclude list mysql.orig/libmysqld/sql_acl.cc mysql/libmysqld/sql_acl.cc
--- mysql.orig/libmysqld/sql_acl.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/sql_acl.cc	2008-01-15 04:56:49.898477593 -0800
@@ -676,7 +676,7 @@
         chars= 128;                             // Marker that chars existed
       }
     }
-    sort= (sort << 8) + (wild_pos ? min(wild_pos, 127) : chars);
+    sort= (sort << 8) + (wild_pos ? MYSQL_MIN(wild_pos, 127) : chars);
   }
   va_end(args);
   return sort;
diff -Nuar --exclude list mysql.orig/libmysqld/sql_analyse.cc mysql/libmysqld/sql_analyse.cc
--- mysql.orig/libmysqld/sql_analyse.cc	2007-12-14 12:43:25.000000000 -0800
+++ mysql/libmysqld/sql_analyse.cc	2008-01-15 04:56:42.522668328 -0800
@@ -281,16 +281,16 @@
   {
     if (((longlong) info->ullval) < 0)
       return 0; // Impossible to store as a negative number
-    ev_info->llval =  -(longlong) max((ulonglong) -ev_info->llval, 
+    ev_info->llval =  -(longlong) MYSQL_MAX((ulonglong) -ev_info->llval, 
 				      info->ullval);
-    ev_info->min_dval = (double) -max(-ev_info->min_dval, info->dval);
+    ev_info->min_dval = (double) -MYSQL_MAX(-ev_info->min_dval, info->dval);
   }
   else		// ulonglong is as big as bigint in MySQL
   {
     if ((check_ulonglong(num, info->integers) == DECIMAL_NUM))
       return 0;
-    ev_info->ullval = (ulonglong) max(ev_info->ullval, info->ullval);
-    ev_info->max_dval =  (double) max(ev_info->max_dval, info->dval);
+    ev_info->ullval = (ulonglong) MYSQL_MAX(ev_info->ullval, info->ullval);
+    ev_info->max_dval =  (double) MYSQL_MAX(ev_info->max_dval, info->dval);
   }
   return 1;
 } // get_ev_num_info
@@ -1044,7 +1044,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &avg_val, sum+cur_sum, &num, prec_increment);
   /* TODO remove this after decimal_div returns proper frac */
   my_decimal_round(E_DEC_FATAL_ERROR, &avg_val,
-                   min(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
+                   MYSQL_MIN(sum[cur_sum].frac + prec_increment, DECIMAL_MAX_SCALE),
                    FALSE,&rounded_avg);
   my_decimal2string(E_DEC_FATAL_ERROR, &rounded_avg, 0, 0, '0', s);
   return s;
@@ -1069,7 +1069,7 @@
   my_decimal_div(E_DEC_FATAL_ERROR, &tmp, &sum2, &num, prec_increment);
   my_decimal2double(E_DEC_FATAL_ERROR, &tmp, &std_sqr);
   s->set(((double) std_sqr <= 0.0 ? 0.0 : sqrt(std_sqr)),
-         min(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
+         MYSQL_MIN(item->decimals + prec_increment, NOT_FIXED_DEC), my_thd_charset);
 
   return s;
 }
@@ -1186,7 +1186,7 @@
   func_items[8] = new Item_proc_string("Std", 255);
   func_items[8]->maybe_null = 1;
   func_items[9] = new Item_proc_string("Optimal_fieldtype",
-				       max(64, output_str_length));
+				       MYSQL_MAX(64, output_str_length));
 
   for (uint i = 0; i < array_elements(func_items); i++)
     field_list.push_back(func_items[i]);
diff -Nuar --exclude list mysql.orig/libmysqld/sql_cache.cc mysql/libmysqld/sql_cache.cc
--- mysql.orig/libmysqld/sql_cache.cc	2007-12-14 12:43:33.000000000 -0800
+++ mysql/libmysqld/sql_cache.cc	2008-01-15 04:56:28.868480095 -0800
@@ -753,7 +753,7 @@
 
     last_result_block= header->result()->prev;
     allign_size= ALIGN_SIZE(last_result_block->used);
-    len= max(query_cache.min_allocation_unit, allign_size);
+    len= MYSQL_MAX(query_cache.min_allocation_unit, allign_size);
     if (last_result_block->length >= query_cache.min_allocation_unit + len)
       query_cache.split_block(last_result_block,len);
 
@@ -2076,7 +2076,7 @@
   DBUG_ENTER("Query_cache::write_block_data");
   DBUG_PRINT("qcache", ("data: %ld, header: %ld, all header: %ld",
 		      data_len, header_len, all_headers_len));
-  Query_cache_block *block = allocate_block(max(align_len, 
+  Query_cache_block *block = allocate_block(MYSQL_MAX(align_len, 
 						min_allocation_unit),
 					    1, 0, under_guard);
   if (block != 0)
@@ -2141,7 +2141,7 @@
   ulong append_min = get_min_append_result_data_size();
   if (last_block_free_space < data_len &&
       append_next_free_block(last_block,
-			     max(tail, append_min)))
+			     MYSQL_MAX(tail, append_min)))
     last_block_free_space = last_block->length - last_block->used;
   // If no space in last block (even after join) allocate new block
   if (last_block_free_space < data_len)
@@ -2173,7 +2173,7 @@
   // Now finally write data to the last block
   if (success && last_block_free_space > 0)
   {
-    ulong to_copy = min(data_len,last_block_free_space);
+    ulong to_copy = MYSQL_MIN(data_len,last_block_free_space);
     DBUG_PRINT("qcache", ("use free space %lub at block 0x%lx to copy %lub",
 			last_block_free_space, (ulong)last_block, to_copy));
     memcpy((void*) (((byte*) last_block) + last_block->used), (void*) data,
@@ -2262,8 +2262,8 @@
   if (queries_in_cache < QUERY_CACHE_MIN_ESTIMATED_QUERIES_NUMBER)
     return min_result_data_size;
   ulong avg_result = (query_cache_size - free_memory) / queries_in_cache;
-  avg_result = min(avg_result, query_cache_limit);
-  return max(min_result_data_size, avg_result);
+  avg_result = MYSQL_MIN(avg_result, query_cache_limit);
+  return MYSQL_MAX(min_result_data_size, avg_result);
 }
 
 inline ulong Query_cache::get_min_append_result_data_size()
@@ -2295,7 +2295,7 @@
     ulong len= data_len + all_headers_len;
     ulong align_len= ALIGN_SIZE(len);
 
-    if (!(new_block= allocate_block(max(min_size, align_len),
+    if (!(new_block= allocate_block(MYSQL_MAX(min_size, align_len),
 				    min_result_data_size == 0,
 				    all_headers_len + min_result_data_size,
 				    1)))
@@ -2305,7 +2305,7 @@
     }
 
     new_block->n_tables = 0;
-    new_block->used = min(len, new_block->length);
+    new_block->used = MYSQL_MIN(len, new_block->length);
     new_block->type = Query_cache_block::RES_INCOMPLETE;
     new_block->next = new_block->prev = new_block;
     Query_cache_result *header = new_block->result();
@@ -2630,7 +2630,7 @@
   DBUG_PRINT("qcache", ("len %lu, not less %d, min %lu, uder_guard %d",
 		      len, not_less,min,under_guard));
 
-  if (len >= min(query_cache_size, query_cache_limit))
+  if (len >= MYSQL_MIN(query_cache_size, query_cache_limit))
   {
     DBUG_PRINT("qcache", ("Query cache hase only %lu memory and limit %lu",
 			query_cache_size, query_cache_limit));
diff -Nuar --exclude list mysql.orig/libmysqld/sql_class.cc mysql/libmysqld/sql_class.cc
--- mysql.orig/libmysqld/sql_class.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/libmysqld/sql_class.cc	2008-01-15 04:56:11.311817643 -0800
@@ -1315,7 +1315,7 @@
     else
     {
       if (fixed_row_size)
-	used_length=min(res->length(),item->max_length);
+	used_length=MYSQL_MIN(res->length(),item->max_length);
       else
 	used_length=res->length();
       if ((result_type == STRING_RESULT || is_unsafe_field_sep) &&
diff -Nuar --exclude list mysql.orig/libmysqld/sql_load.cc mysql/libmysqld/sql_load.cc
--- mysql.orig/libmysqld/sql_load.cc	2007-12-14 12:43:32.000000000 -0800
+++ mysql/libmysqld/sql_load.cc	2008-01-15 04:56:45.753606953 -0800
@@ -917,7 +917,7 @@
 
 
   /* Set of a stack for unget if long terminators */
-  uint length=max(field_term_length,line_term_length)+1;
+  uint length=MYSQL_MAX(field_term_length,line_term_length)+1;
   set_if_bigger(length,line_start.length());
   stack=stack_pos=(int*) sql_alloc(sizeof(int)*length);
 
diff -Nuar --exclude list mysql.orig/libmysqld/sql_parse.cc mysql/libmysqld/sql_parse.cc
--- mysql.orig/libmysqld/sql_parse.cc	2007-12-14 12:43:41.000000000 -0800
+++ mysql/libmysqld/sql_parse.cc	2008-01-15 04:56:08.288471890 -0800
@@ -858,7 +858,7 @@
       if (thd->main_security_ctx.host)
       {
         if (thd->main_security_ctx.host != my_localhost)
-          thd->main_security_ctx.host[min(strlen(thd->main_security_ctx.host),
+          thd->main_security_ctx.host[MYSQL_MIN(strlen(thd->main_security_ctx.host),
                                           HOSTNAME_LENGTH)]= 0;
         thd->main_security_ctx.host_or_ip= thd->main_security_ctx.host;
       }
@@ -5804,7 +5804,7 @@
     return 1;
   }
 #ifndef DBUG_OFF
-  max_stack_used= max(max_stack_used, stack_used);
+  max_stack_used= MYSQL_MAX(max_stack_used, stack_used);
 #endif
   return 0;
 }
@@ -7232,7 +7232,7 @@
     char command[80];
     Lex_input_stream *lip= thd->m_lip;
     strmake(command, lip->yylval->symbol.str,
-	    min(lip->yylval->symbol.length, sizeof(command)-1));
+	    MYSQL_MIN(lip->yylval->symbol.length, sizeof(command)-1));
     my_error(ER_CANT_USE_OPTION_HERE, MYF(0), command);
     return 1;
   }
diff -Nuar --exclude list mysql.orig/libmysqld/sql_prepare.cc mysql/libmysqld/sql_prepare.cc
--- mysql.orig/libmysqld/sql_prepare.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/libmysqld/sql_prepare.cc	2008-01-15 04:56:01.889508255 -0800
@@ -228,7 +228,7 @@
   int2store(buff+5, columns);
   int2store(buff+7, stmt->param_count);
   buff[9]= 0;                                   // Guard against a 4.1 client
-  tmp= min(stmt->thd->total_warn_count, 65535);
+  tmp= MYSQL_MIN(stmt->thd->total_warn_count, 65535);
   int2store(buff+10, tmp);
 
   /*
diff -Nuar --exclude list mysql.orig/libmysqld/sql_select.cc mysql/libmysqld/sql_select.cc
--- mysql.orig/libmysqld/sql_select.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/sql_select.cc	2008-01-15 04:55:58.115149679 -0800
@@ -2715,7 +2715,7 @@
       This is can't be to high as otherwise we are likely to use
       table scan.
     */
-    s->worst_seeks= min((double) s->found_records / 10,
+    s->worst_seeks= MYSQL_MIN((double) s->found_records / 10,
 			(double) s->read_time*3);
     if (s->worst_seeks < 2.0)			// Fix for small tables
       s->worst_seeks=2.0;
@@ -3578,7 +3578,7 @@
   uint	and_level,i,found_eq_constant;
   KEY_FIELD *key_fields, *end, *field;
   uint sz;
-  uint m= max(select_lex->max_equal_elems,1);
+  uint m= MYSQL_MAX(select_lex->max_equal_elems,1);
   
   /* 
     We use the same piece of memory to store both  KEY_FIELD 
@@ -3601,7 +3601,7 @@
     can be not more than select_lex->max_equal_elems such 
     substitutions.
   */ 
-  sz= max(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
+  sz= MYSQL_MAX(sizeof(KEY_FIELD),sizeof(SARGABLE_PARAM))*
       (((thd->lex->current_select->cond_count+1)*2 +
 	thd->lex->current_select->between_count)*m+1);
   if (!(key_fields=(KEY_FIELD*)	thd->alloc(sz)))
@@ -3750,7 +3750,7 @@
       if (map == 1)			// Only one table
       {
 	TABLE *tmp_table=join->all_tables[tablenr];
-	keyuse->ref_table_rows= max(tmp_table->file->records, 100);
+	keyuse->ref_table_rows= MYSQL_MAX(tmp_table->file->records, 100);
       }
     }
     /*
@@ -4064,7 +4064,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
         }
         else
@@ -4208,7 +4208,7 @@
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
             else
-              tmp= record_count*min(tmp,s->worst_seeks);
+              tmp= record_count*MYSQL_MIN(tmp,s->worst_seeks);
           }
           else
             tmp= best_time;                    // Do nothing
@@ -5107,7 +5107,7 @@
   {
     uint blob_length=(uint) (join_tab->table->file->mean_rec_length-
 			     (join_tab->table->s->reclength- rec_length));
-    rec_length+=(uint) max(4,blob_length);
+    rec_length+=(uint) MYSQL_MAX(4,blob_length);
   }
   join_tab->used_fields=fields;
   join_tab->used_fieldlength=rec_length;
@@ -9008,7 +9008,7 @@
     {
       signed int overflow;
 
-      dec= min(dec, DECIMAL_MAX_SCALE);
+      dec= MYSQL_MIN(dec, DECIMAL_MAX_SCALE);
 
       /*
         If the value still overflows the field with the corrected dec,
@@ -9021,7 +9021,7 @@
                                                item->unsigned_flag) - len;
 
       if (overflow > 0)
-        dec= max(0, dec - overflow);            // too long, discard fract
+        dec= MYSQL_MAX(0, dec - overflow);            // too long, discard fract
       else
         len -= item->decimals - dec;            // corrected value fits
     }
@@ -9728,7 +9728,7 @@
     table->s->max_rows= ~(ha_rows) 0;
   else
     table->s->max_rows= (ha_rows) (((table->s->db_type == DB_TYPE_HEAP) ?
-                                    min(thd->variables.tmp_table_size,
+                                    MYSQL_MIN(thd->variables.tmp_table_size,
                                         thd->variables.max_heap_table_size) :
                                     thd->variables.tmp_table_size)/
                                    table->s->reclength);
@@ -13109,7 +13109,7 @@
     count++;
   if (!sortorder)
     sortorder= (SORT_FIELD*) sql_alloc(sizeof(SORT_FIELD) *
-                                       (max(count, *length) + 1));
+                                       (MYSQL_MAX(count, *length) + 1));
   pos= sort= sortorder;
 
   if (!pos)
@@ -13227,7 +13227,7 @@
   cache->length=length+blobs*sizeof(char*);
   cache->blobs=blobs;
   *blob_ptr=0;					/* End sequentel */
-  size=max(thd->variables.join_buff_size, cache->length);
+  size=MYSQL_MAX(thd->variables.join_buff_size, cache->length);
   if (!(cache->buff=(uchar*) my_malloc(size,MYF(0))))
     DBUG_RETURN(1);				/* Don't use cache */ /* purecov: inspected */
   cache->end=cache->buff+size;
diff -Nuar --exclude list mysql.orig/libmysqld/sql_show.cc mysql/libmysqld/sql_show.cc
--- mysql.orig/libmysqld/sql_show.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/libmysqld/sql_show.cc	2008-01-15 04:55:18.649317055 -0800
@@ -428,14 +428,14 @@
   {
     field_list.push_back(new Item_empty_string("View",NAME_LEN));
     field_list.push_back(new Item_empty_string("Create View",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
   }
   else
   {
     field_list.push_back(new Item_empty_string("Table",NAME_LEN));
     // 1024 is for not to confuse old clients
     field_list.push_back(new Item_empty_string("Create Table",
-                                               max(buffer.length(),1024)));
+                                               MYSQL_MAX(buffer.length(),1024)));
   }
 
   if (protocol->send_fields(&field_list,
@@ -1390,7 +1390,7 @@
 	    the comment in sql_class.h why this prevents crashes in possible
             races with query_length
           */
-          uint length= min(max_query_length, tmp->query_length);
+          uint length= MYSQL_MIN(max_query_length, tmp->query_length);
           thd_info->query=(char*) thd->strmake(tmp->query,length);
         }
         thread_infos.append(thd_info);
diff -Nuar --exclude list mysql.orig/libmysqld/sql_string.cc mysql/libmysqld/sql_string.cc
--- mysql.orig/libmysqld/sql_string.cc	2007-12-14 12:42:59.000000000 -0800
+++ mysql/libmysqld/sql_string.cc	2008-01-15 04:55:07.147346327 -0800
@@ -662,7 +662,7 @@
 {
   if (Alloced_length < str_length + space_needed)
   {
-    if (realloc(Alloced_length + max(space_needed, grow_by) - 1))
+    if (realloc(Alloced_length + MYSQL_MAX(space_needed, grow_by) - 1))
       return TRUE;
   }
   return FALSE;
@@ -748,7 +748,7 @@
 
 int stringcmp(const String *s,const String *t)
 {
-  uint32 s_len=s->length(),t_len=t->length(),len=min(s_len,t_len);
+  uint32 s_len=s->length(),t_len=t->length(),len=MYSQL_MIN(s_len,t_len);
   int cmp= memcmp(s->ptr(), t->ptr(), len);
   return (cmp) ? cmp : (int) (s_len - t_len);
 }
@@ -765,7 +765,7 @@
   }
   if (to->realloc(from_length))
     return from;				// Actually an error
-  if ((to->str_length=min(from->str_length,from_length)))
+  if ((to->str_length=MYSQL_MIN(from->str_length,from_length)))
     memcpy(to->Ptr,from->Ptr,to->str_length);
   to->str_charset=from->str_charset;
   return to;
@@ -906,7 +906,7 @@
 
     if (to_cs == &my_charset_bin)
     {
-      res= min(min(nchars, to_length), from_length);
+      res= MYSQL_MIN(MYSQL_MIN(nchars, to_length), from_length);
       memmove(to, from, res);
       *from_end_pos= from + res;
       *well_formed_error_pos= NULL;
diff -Nuar --exclude list mysql.orig/libmysqld/sql_table.cc mysql/libmysqld/sql_table.cc
--- mysql.orig/libmysqld/sql_table.cc	2007-12-14 12:43:14.000000000 -0800
+++ mysql/libmysqld/sql_table.cc	2008-01-15 04:54:55.981822019 -0800
@@ -1355,7 +1355,7 @@
 	  if ((length=column->length) > max_key_length ||
 	      length > file->max_key_part_length())
 	  {
-	    length=min(max_key_length, file->max_key_part_length());
+	    length=MYSQL_MIN(max_key_length, file->max_key_part_length());
 	    if (key->type == Key::MULTIPLE)
 	    {
 	      /* not a critical problem */
diff -Nuar --exclude list mysql.orig/libmysqld/sql_yacc.cc mysql/libmysqld/sql_yacc.cc
--- mysql.orig/libmysqld/sql_yacc.cc	2007-12-14 12:56:33.000000000 -0800
+++ mysql/libmysqld/sql_yacc.cc	2008-01-15 04:54:52.908481533 -0800
@@ -14535,7 +14535,7 @@
               from 0" (4 in fact), unspecified means "don't change the position
               (keep the preceding value)").
            */
-           Lex->mi.pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
+           Lex->mi.pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.pos);
          }
     break;
 
@@ -14551,7 +14551,7 @@
     {
            Lex->mi.relay_log_pos = (yyvsp[0].ulong_num);
            /* Adjust if < BIN_LOG_HEADER_SIZE (same comment as Lex->mi.pos) */
-           Lex->mi.relay_log_pos = max(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
+           Lex->mi.relay_log_pos = MYSQL_MAX(BIN_LOG_HEADER_SIZE, Lex->mi.relay_log_pos);
          }
     break;
 
diff -Nuar --exclude list mysql.orig/libmysqld/stacktrace.c mysql/libmysqld/stacktrace.c
--- mysql.orig/libmysqld/stacktrace.c	2007-12-14 12:43:14.000000000 -0800
+++ mysql/libmysqld/stacktrace.c	2008-01-15 04:54:38.816500221 -0800
@@ -146,7 +146,7 @@
 
   if (!stack_bottom || (gptr) stack_bottom > (gptr) &fp)
   {
-    ulong tmp= min(0x10000,thread_stack);
+    ulong tmp= MYSQL_MIN(0x10000,thread_stack);
     /* Assume that the stack starts at the previous even 65K */
     stack_bottom= (gptr) (((ulong) &fp + tmp) &
 			  ~(ulong) 0xFFFF);
diff -Nuar --exclude list mysql.orig/libmysqld/thr_malloc.cc mysql/libmysqld/thr_malloc.cc
--- mysql.orig/libmysqld/thr_malloc.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysqld/thr_malloc.cc	2008-01-15 04:54:48.189313451 -0800
@@ -103,7 +103,7 @@
   if ((from_cs == &my_charset_bin) || (to_cs == &my_charset_bin))
   {
     // Safety if to_cs->mbmaxlen > 0
-    new_length= min(arg_length, max_res_length);
+    new_length= MYSQL_MIN(arg_length, max_res_length);
     memcpy(pos, str, new_length);
   }
   else
diff -Nuar --exclude list mysql.orig/libmysqld/tztime.cc mysql/libmysqld/tztime.cc
--- mysql.orig/libmysqld/tztime.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/libmysqld/tztime.cc	2008-01-15 04:54:35.013363373 -0800
@@ -167,7 +167,7 @@
       char buf[sizeof(struct tzhead) + sizeof(my_time_t) * TZ_MAX_TIMES +
                TZ_MAX_TIMES + sizeof(TRAN_TYPE_INFO) * TZ_MAX_TYPES +
 #ifdef ABBR_ARE_USED
-               max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
+               MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
 #endif
                sizeof(LS_INFO) * TZ_MAX_LEAPS];
     } u;
@@ -396,7 +396,7 @@
       Let us choose end_t as point before next time type change or leap
       second correction.
     */
-    end_t= min((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
+    end_t= MYSQL_MIN((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
                                                 MY_TIME_T_MAX,
                (next_leap_idx < sp->leapcnt) ?
                  sp->lsis[next_leap_idx].ls_trans - 1: MY_TIME_T_MAX);
@@ -1866,7 +1866,7 @@
   unsigned char types[TZ_MAX_TIMES];
   TRAN_TYPE_INFO ttis[TZ_MAX_TYPES];
 #ifdef ABBR_ARE_USED
-  char chars[max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
+  char chars[MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
 #endif
 
   DBUG_ENTER("tz_load_from_open_tables");
diff -Nuar --exclude list mysql.orig/libmysqld/unireg.cc mysql/libmysqld/unireg.cc
--- mysql.orig/libmysqld/unireg.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/libmysqld/unireg.cc	2008-01-15 04:54:43.965979033 -0800
@@ -360,7 +360,7 @@
     }
     cfield->row=(uint8) row;
     cfield->col=(uint8) (length+1);
-    cfield->sc_length=(uint8) min(cfield->length,cols-(length+2));
+    cfield->sc_length=(uint8) MYSQL_MIN(cfield->length,cols-(length+2));
   }
   length=(uint) (pos-start_screen);
   int2store(start_screen,length);
@@ -579,7 +579,7 @@
     DBUG_RETURN(1);
   }
   /* Hack to avoid bugs with small static rows in MySQL */
-  reclength=max(file->min_record_length(table_options),reclength);
+  reclength=MYSQL_MAX(file->min_record_length(table_options),reclength);
   if (info_length+(ulong) create_fields.elements*FCOMP+288+
       n_length+int_length+com_length > 65535L || int_count > 255)
   {
diff -Nuar --exclude list mysql.orig/libmysql_r/libmysql.c mysql/libmysql_r/libmysql.c
--- mysql.orig/libmysql_r/libmysql.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/libmysql_r/libmysql.c	2008-01-15 05:00:22.418590356 -0800
@@ -1558,7 +1558,7 @@
   my_net_set_read_timeout(net, CLIENT_NET_READ_TIMEOUT);
   my_net_set_write_timeout(net, CLIENT_NET_WRITE_TIMEOUT);
   net->retry_count=  1;
-  net->max_packet_size= max(net_buffer_length, max_allowed_packet);
+  net->max_packet_size= MYSQL_MAX(net_buffer_length, max_allowed_packet);
 }
 
 /*
@@ -3562,7 +3562,7 @@
       copy_length= end - start;
       /* We've got some data beyond offset: copy up to buffer_length bytes */
       if (param->buffer_length)
-        memcpy(buffer, start, min(copy_length, param->buffer_length));
+        memcpy(buffer, start, MYSQL_MIN(copy_length, param->buffer_length));
     }
     else
       copy_length= 0;
@@ -3794,9 +3794,9 @@
         precisions. This will ensure that on the same machine you get the
         same value as a string independent of the protocol you use.
       */
-      sprintf(buff, "%-*.*g", (int) min(sizeof(buff)-1,
+      sprintf(buff, "%-*.*g", (int) MYSQL_MIN(sizeof(buff)-1,
                                         param->buffer_length),
-	      min(14,width), value);
+	      MYSQL_MIN(14,width), value);
       end= strcend(buff, ' ');
       *end= 0;
     }
@@ -4113,7 +4113,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   *param->length= length;
   *param->error= copy_length < length;
@@ -4125,7 +4125,7 @@
                              uchar **row)
 {
   ulong length= net_field_length(row);
-  ulong copy_length= min(length, param->buffer_length);
+  ulong copy_length= MYSQL_MIN(length, param->buffer_length);
   memcpy(param->buffer, (char *)*row, copy_length);
   /* Add an end null if there is room in the buffer */
   if (copy_length != param->buffer_length)
diff -Nuar --exclude list mysql.orig/myisam/mi_cache.c mysql/myisam/mi_cache.c
--- mysql.orig/myisam/mi_cache.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/myisam/mi_cache.c	2008-01-15 04:53:28.461310784 -0800
@@ -61,7 +61,7 @@
       (my_off_t) (info->read_end - info->request_pos))
   {
     in_buff_pos=info->request_pos+(uint) offset;
-    in_buff_length= min(length,(uint) (info->read_end-in_buff_pos));
+    in_buff_length= MYSQL_MIN(length,(uint) (info->read_end-in_buff_pos));
     memcpy(buff,info->request_pos+(uint) offset,(size_t) in_buff_length);
     if (!(length-=in_buff_length))
       DBUG_RETURN(0);
diff -Nuar --exclude list mysql.orig/myisam/mi_check.c mysql/myisam/mi_check.c
--- mysql.orig/myisam/mi_check.c	2007-12-14 12:43:42.000000000 -0800
+++ mysql/myisam/mi_check.c	2008-01-15 04:53:12.065157033 -0800
@@ -2163,7 +2163,7 @@
   ulong buff_length;
   DBUG_ENTER("filecopy");
 
-  buff_length=(ulong) min(param->write_buffer_length,length);
+  buff_length=(ulong) MYSQL_MIN(param->write_buffer_length,length);
   if (!(buff=my_malloc(buff_length,MYF(0))))
   {
     buff=tmp_buff; buff_length=IO_SIZE;
@@ -2319,7 +2319,7 @@
   sort_param.wordlist=NULL;
 
   if (share->data_file_type == DYNAMIC_RECORD)
-    length=max(share->base.min_pack_length+1,share->base.min_block_length);
+    length=MYSQL_MAX(share->base.min_pack_length+1,share->base.min_block_length);
   else if (share->data_file_type == COMPRESSED_RECORD)
     length=share->base.min_block_length;
   else
@@ -2746,7 +2746,7 @@
     my_seek(param->read_cache.file,0L,MY_SEEK_END,MYF(0));
 
   if (share->data_file_type == DYNAMIC_RECORD)
-    rec_length=max(share->base.min_pack_length+1,share->base.min_block_length);
+    rec_length=MYSQL_MAX(share->base.min_pack_length+1,share->base.min_block_length);
   else if (share->data_file_type == COMPRESSED_RECORD)
     rec_length=share->base.min_block_length;
   else
@@ -3932,7 +3932,7 @@
   ft_buf->buf=ft_buf->lastkey+a_len;
   /*
     32 is just a safety margin here
-    (at least max(val_len, sizeof(nod_flag)) should be there).
+    (at least MYSQL_MAX(val_len, sizeof(nod_flag)) should be there).
     May be better performance could be achieved if we'd put
       (sort_info->keyinfo->block_length-32)/XXX
       instead.
@@ -4283,7 +4283,7 @@
 
   VOID(mi_close(*org_info));
   bzero((char*) &create_info,sizeof(create_info));
-  create_info.max_rows=max(max_records,share.base.records);
+  create_info.max_rows=MYSQL_MAX(max_records,share.base.records);
   create_info.reloc_rows=share.base.reloc;
   create_info.old_options=(share.options |
 			   (unpack ? HA_OPTION_TEMP_COMPRESS_RECORD : 0));
diff -Nuar --exclude list mysql.orig/myisam/mi_create.c mysql/myisam/mi_create.c
--- mysql.orig/myisam/mi_create.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/myisam/mi_create.c	2008-01-15 04:53:18.555165949 -0800
@@ -517,7 +517,7 @@
     got from MYI file header (see also myisampack.c:save_state)
   */
   share.base.key_reflength=
-    mi_get_pointer_length(max(ci->key_file_length,tmp),3);
+    mi_get_pointer_length(MYSQL_MAX(ci->key_file_length,tmp),3);
   share.base.keys= share.state.header.keys= keys;
   share.state.header.uniques= uniques;
   share.state.header.fulltext_keys= fulltext_keys;
@@ -551,7 +551,7 @@
   share.base.min_block_length=
     (share.base.pack_reclength+3 < MI_EXTEND_BLOCK_LENGTH &&
      ! share.base.blobs) ?
-    max(share.base.pack_reclength,MI_MIN_BLOCK_LENGTH) :
+    MYSQL_MAX(share.base.pack_reclength,MI_MIN_BLOCK_LENGTH) :
     MI_EXTEND_BLOCK_LENGTH;
   if (! (flags & HA_DONT_TOUCH_DATA))
     share.state.create_time= (long) time((time_t*) 0);
diff -Nuar --exclude list mysql.orig/myisam/mi_dynrec.c mysql/myisam/mi_dynrec.c
--- mysql.orig/myisam/mi_dynrec.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/myisam/mi_dynrec.c	2008-01-15 04:53:22.159320450 -0800
@@ -668,7 +668,7 @@
 	uint tmp=MY_ALIGN(reclength - length + 3 +
 			  test(reclength >= 65520L),MI_DYN_ALIGN_SIZE);
 	/* Don't create a block bigger than MI_MAX_BLOCK_LENGTH */
-	tmp= min(length+tmp, MI_MAX_BLOCK_LENGTH)-length;
+	tmp= MYSQL_MIN(length+tmp, MI_MAX_BLOCK_LENGTH)-length;
 	/* Check if we can extend this block */
 	if (block_info.filepos + block_info.block_len ==
 	    info->state->data_file_length &&
diff -Nuar --exclude list mysql.orig/myisam/mi_extra.c mysql/myisam/mi_extra.c
--- mysql.orig/myisam/mi_extra.c	2007-12-14 12:43:25.000000000 -0800
+++ mysql/myisam/mi_extra.c	2008-01-15 04:53:39.755153495 -0800
@@ -120,7 +120,7 @@
       cache_size= (extra_arg ? *(ulong*) extra_arg :
 		   my_default_record_cache_size);
       if (!(init_io_cache(&info->rec_cache,info->dfile,
-			 (uint) min(info->state->data_file_length+1,
+			 (uint) MYSQL_MIN(info->state->data_file_length+1,
 				    cache_size),
 			  READ_CACHE,0L,(pbool) (info->lock_type != F_UNLCK),
 			  MYF(share->write_flag & MY_WAIT_IF_FULL))))
diff -Nuar --exclude list mysql.orig/myisam/mi_key.c mysql/myisam/mi_key.c
--- mysql.orig/myisam/mi_key.c	2007-12-14 12:43:51.000000000 -0800
+++ mysql/myisam/mi_key.c	2008-01-15 04:53:34.287164618 -0800
@@ -228,7 +228,7 @@
        old+=keyseg->length, keyseg++)
   {
     enum ha_base_keytype type=(enum ha_base_keytype) keyseg->type;
-    uint length=min((uint) keyseg->length,(uint) k_length);
+    uint length=MYSQL_MIN((uint) keyseg->length,(uint) k_length);
     uint char_length;
     uchar *pos;
     CHARSET_INFO *cs=keyseg->charset;
diff -Nuar --exclude list mysql.orig/myisam/mi_open.c mysql/myisam/mi_open.c
--- mysql.orig/myisam/mi_open.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/myisam/mi_open.c	2008-01-15 04:53:48.265981858 -0800
@@ -306,7 +306,7 @@
     strmov(share->index_file_name,  index_name);
     strmov(share->data_file_name,   data_name);
 
-    share->blocksize=min(IO_SIZE,myisam_block_size);
+    share->blocksize=MYSQL_MIN(IO_SIZE,myisam_block_size);
     {
       HA_KEYSEG *pos=share->keyparts;
       for (i=0 ; i < keys ; i++)
@@ -475,7 +475,7 @@
     share->base.margin_key_file_length=(share->base.max_key_file_length -
 					(keys ? MI_INDEX_BLOCK_MARGIN *
 					 share->blocksize * keys : 0));
-    share->blocksize=min(IO_SIZE,myisam_block_size);
+    share->blocksize=MYSQL_MIN(IO_SIZE,myisam_block_size);
 
     share->data_file_type=STATIC_RECORD;
     if (share->options & HA_OPTION_COMPRESS_RECORD)
@@ -676,10 +676,10 @@
     if (length == (ulong) -1)
     {
       if (info->s->options & HA_OPTION_COMPRESS_RECORD)
-        length= max(info->s->base.pack_reclength, info->s->max_pack_length);
+        length= MYSQL_MAX(info->s->base.pack_reclength, info->s->max_pack_length);
       else
         length= info->s->base.pack_reclength;
-      length= max(length, info->s->base.max_key_length);
+      length= MYSQL_MAX(length, info->s->base.max_key_length);
       /* Avoid unnecessary realloc */
       if (newptr && length == old_length)
 	return newptr;
diff -Nuar --exclude list mysql.orig/myisam/mi_packrec.c mysql/myisam/mi_packrec.c
--- mysql.orig/myisam/mi_packrec.c	2007-12-14 12:43:25.000000000 -0800
+++ mysql/myisam/mi_packrec.c	2008-01-15 05:00:51.535962630 -0800
@@ -676,7 +676,7 @@
       return OFFSET_TABLE_SIZE;
     }
     length2= find_longest_bitstream(next, end) + 1;
-    length=max(length,length2);
+    length=MYSQL_MAX(length,length2);
   }
   return length;
 }
@@ -1391,7 +1391,7 @@
   info->filepos=filepos+head_length;
   if (file > 0)
   {
-    info->offset=min(info->rec_len, ref_length - head_length);
+    info->offset=MYSQL_MIN(info->rec_len, ref_length - head_length);
     memcpy(*rec_buff_p, header + head_length, info->offset);
   }
   return 0;
diff -Nuar --exclude list mysql.orig/myisam/mi_test1.c mysql/myisam/mi_test1.c
--- mysql.orig/myisam/mi_test1.c	2007-12-14 12:42:50.000000000 -0800
+++ mysql/myisam/mi_test1.c	2008-01-15 04:51:24.163954438 -0800
@@ -433,7 +433,7 @@
     uint tmp;
     char *ptr;;
     sprintf(blob_record,"... row: %d", rownr);
-    strappend(blob_record,max(MAX_REC_LENGTH-rownr,10),' ');
+    strappend(blob_record,MYSQL_MAX(MAX_REC_LENGTH-rownr,10),' ');
     tmp=strlen(blob_record);
     int4store(pos,tmp);
     ptr=blob_record;
diff -Nuar --exclude list mysql.orig/myisam/mi_test2.c mysql/myisam/mi_test2.c
--- mysql.orig/myisam/mi_test2.c	2007-12-14 12:43:24.000000000 -0800
+++ mysql/myisam/mi_test2.c	2008-01-15 04:51:15.429059961 -0800
@@ -591,7 +591,7 @@
     goto err;
 
   bmove(read_record2,read_record,reclength);
-  for (i=min(2,keys) ; i-- > 0 ;)
+  for (i=MYSQL_MIN(2,keys) ; i-- > 0 ;)
   {
     if (mi_rsame(file,read_record2,(int) i)) goto err;
     if (bcmp(read_record,read_record2,reclength) != 0)
diff -Nuar --exclude list mysql.orig/myisam/myisamlog.c mysql/myisam/myisamlog.c
--- mysql.orig/myisam/myisamlog.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/myisam/myisamlog.c	2008-01-15 04:51:05.047004548 -0800
@@ -88,7 +88,7 @@
   log_filename=myisam_log_filename;
   get_options(&argc,&argv);
   /* Number of MyISAM files we can have open at one time */
-  max_files= (my_set_max_open_files(min(max_files,8))-6)/2;
+  max_files= (my_set_max_open_files(MYSQL_MIN(max_files,8))-6)/2;
   if (update)
     printf("Trying to %s MyISAM files according to log '%s'\n",
 	   (recover ? "recover" : "update"),log_filename);
diff -Nuar --exclude list mysql.orig/myisam/myisampack.c mysql/myisam/myisampack.c
--- mysql.orig/myisam/myisampack.c	2007-12-14 12:42:59.000000000 -0800
+++ mysql/myisam/myisampack.c	2008-01-15 05:00:55.035108740 -0800
@@ -1239,7 +1239,7 @@
     {
       if (huff_counts->field_length > 2 &&
 	  huff_counts->empty_fields + (records - huff_counts->empty_fields)*
-	  (1+max_bit(max(huff_counts->max_pre_space,
+	  (1+max_bit(MYSQL_MAX(huff_counts->max_pre_space,
 			 huff_counts->max_end_space))) <
 	  records * max_bit(huff_counts->field_length))
       {
@@ -3001,7 +3001,7 @@
   if (mrg->src_file_has_indexes_disabled)
   {
     isam_file->s->state.state.key_file_length=
-      max(isam_file->s->state.state.key_file_length, new_length);
+      MYSQL_MAX(isam_file->s->state.state.key_file_length, new_length);
   }
   state.dellink= HA_OFFSET_ERROR;
   state.version=(ulong) time((time_t*) 0);
diff -Nuar --exclude list mysql.orig/myisam/rt_mbr.c mysql/myisam/rt_mbr.c
--- mysql.orig/myisam/rt_mbr.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/myisam/rt_mbr.c	2008-01-15 04:52:21.735993423 -0800
@@ -325,8 +325,8 @@
   bmin = korr_func(b); \
   amax = korr_func(a+len); \
   bmax = korr_func(b+len); \
-  amin = min(amin, bmin); \
-  amax = max(amax, bmax); \
+  amin = MYSQL_MIN(amin, bmin); \
+  amax = MYSQL_MAX(amax, bmax); \
   store_func(c, amin); \
   store_func(c+len, amax); \
 }
@@ -338,8 +338,8 @@
   get_func(bmin, b); \
   get_func(amax, a+len); \
   get_func(bmax, b+len); \
-  amin = min(amin, bmin); \
-  amax = max(amax, bmax); \
+  amin = MYSQL_MIN(amin, bmin); \
+  amax = MYSQL_MAX(amax, bmax); \
   store_func(c, amin); \
   store_func(c+len, amax); \
 }
@@ -417,8 +417,8 @@
   bmin = korr_func(b); \
   amax = korr_func(a+len); \
   bmax = korr_func(b+len); \
-  amin = max(amin, bmin); \
-  amax = min(amax, bmax); \
+  amin = MYSQL_MAX(amin, bmin); \
+  amax = MYSQL_MIN(amax, bmax); \
   if (amin >= amax) \
     return 0; \
   res *= amax - amin; \
@@ -431,8 +431,8 @@
   get_func(bmin, b); \
   get_func(amax, a+len); \
   get_func(bmax, b+len); \
-  amin = max(amin, bmin); \
-  amax = min(amax, bmax); \
+  amin = MYSQL_MAX(amin, bmin); \
+  amax = MYSQL_MIN(amax, bmax); \
   if (amin >= amax)  \
     return 0; \
   res *= amax - amin; \
@@ -508,7 +508,7 @@
    amax = korr_func(a+len); \
    bmax = korr_func(b+len); \
    a_area *= (((double)amax) - ((double)amin)); \
-   loc_ab_area *= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   loc_ab_area *= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 #define RT_AREA_INC_GET(type, get_func, len)\
@@ -519,7 +519,7 @@
    get_func(amax, a+len); \
    get_func(bmax, b+len); \
    a_area *= (((double)amax) - ((double)amin)); \
-   loc_ab_area *= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   loc_ab_area *= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 /*
@@ -604,7 +604,7 @@
    amax = korr_func(a+len); \
    bmax = korr_func(b+len); \
    a_perim+= (((double)amax) - ((double)amin)); \
-   *ab_perim+= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   *ab_perim+= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 #define RT_PERIM_INC_GET(type, get_func, len)\
@@ -615,7 +615,7 @@
    get_func(amax, a+len); \
    get_func(bmax, b+len); \
    a_perim+= (((double)amax) - ((double)amin)); \
-   *ab_perim+= ((double)max(amax, bmax) - (double)min(amin, bmin)); \
+   *ab_perim+= ((double)MYSQL_MAX(amax, bmax) - (double)MYSQL_MIN(amin, bmin)); \
 }
 
 /*
diff -Nuar --exclude list mysql.orig/myisam/sort.c mysql/myisam/sort.c
--- mysql.orig/myisam/sort.c	2007-12-14 12:42:51.000000000 -0800
+++ mysql/myisam/sort.c	2008-01-15 04:52:42.581836127 -0800
@@ -131,7 +131,7 @@
   sort_keys= (uchar **) NULL; error= 1;
   maxbuffer=1;
 
-  memavl=max(sortbuff_size,MIN_SORT_MEMORY);
+  memavl=MYSQL_MAX(sortbuff_size,MIN_SORT_MEMORY);
   records=	info->sort_info->max_records;
   sort_length=	info->key_length;
   LINT_INIT(keys);
@@ -348,7 +348,7 @@
     bzero((char*) &sort_param->unique,  sizeof(sort_param->unique));
     sort_keys= (uchar **) NULL;
 
-    memavl=       max(sort_param->sortbuff_size, MIN_SORT_MEMORY);
+    memavl=       MYSQL_MAX(sort_param->sortbuff_size, MIN_SORT_MEMORY);
     idx=          (uint)sort_param->sort_info->max_records;
     sort_length=  sort_param->key_length;
     maxbuffer=    1;
@@ -813,7 +813,7 @@
   register uint count;
   uint length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(byte*) buffpek->base,
                  (length= sort_length*count),buffpek->file_pos,MYF_RW))
@@ -834,7 +834,7 @@
   uint idx;
   uchar *buffp;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(uint) MYSQL_MIN((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     buffp = buffpek->base;
 
diff -Nuar --exclude list mysql.orig/mysys/my_conio.c mysql/mysys/my_conio.c
--- mysql.orig/mysys/my_conio.c	2007-12-14 12:43:00.000000000 -0800
+++ mysql/mysys/my_conio.c	2008-01-15 05:16:58.673301325 -0800
@@ -167,10 +167,10 @@
     later we may want to cycle from min(clen, 65535) to allowed size
     with small decrement to determine exact allowed buffer           
   */
-  clen= min(clen, 65535);
+  clen= MYSQL_MIN(clen, 65535);
   do
   {
-    clen= min(clen, (unsigned long)csbi.dwSize.X*csbi.dwSize.Y);
+    clen= MYSQL_MIN(clen, (unsigned long)csbi.dwSize.X*csbi.dwSize.Y);
     if (!ReadConsole((HANDLE)my_coninpfh, (LPVOID)buffer, clen - 1, plen, NULL))
     {
       result= NULL;
diff -Nuar --exclude list mysql.orig/mysys/my_static.h mysql/mysys/my_static.h
--- mysql.orig/mysys/my_static.h	2007-12-14 12:42:51.000000000 -0800
+++ mysql/mysys/my_static.h	2008-01-15 05:17:08.126484924 -0800
@@ -22,7 +22,7 @@
 #include <signal.h>
 
 #define MAX_SIGNALS	10		/* Max signals under a dont-allow */
-#define MIN_KEYBLOCK	(min(IO_SIZE,1024))
+#define MIN_KEYBLOCK	(MYSQL_MIN(IO_SIZE,1024))
 #define MAX_KEYBLOCK	8192		/* Max keyblocklength == 8*IO_SIZE */
 #define MAX_BLOCK_TYPES MAX_KEYBLOCK/MIN_KEYBLOCK
 
diff -Nuar --exclude list mysql.orig/mysys/raid.cc mysql/mysys/raid.cc
--- mysql.orig/mysys/raid.cc	2007-12-14 12:42:50.000000000 -0800
+++ mysql/mysys/raid.cc	2008-01-15 05:17:16.075010698 -0800
@@ -558,7 +558,7 @@
 	DBUG_RETURN(-1);
       _seek_vector[_this_block]=RAID_SEEK_DONE;
     }
-    ReadNowCount = min(Count, _remaining_bytes);
+    ReadNowCount = MYSQL_MIN(Count, _remaining_bytes);
     GotBytes = my_write(_fd_vector[_this_block], bufptr, ReadNowCount,
 			MyFlags);
     DBUG_PRINT("loop",("Wrote bytes: %d", GotBytes));
@@ -599,7 +599,7 @@
       _seek_vector[_this_block]=RAID_SEEK_DONE;
     }
     // and read
-    ReadNowCount = min(Count, _remaining_bytes);
+    ReadNowCount = MYSQL_MIN(Count, _remaining_bytes);
     GotBytes = my_read(_fd_vector[_this_block], bufptr, ReadNowCount,
 		       MyFlags & ~(MY_NABP | MY_FNABP));
     DBUG_PRINT("loop",("Got bytes: %u", GotBytes));
@@ -631,7 +631,7 @@
     Calculate();
     for (uint i = _this_block ; (i < _raid_chunks) && length ; i++ )
     {
-       uint ReadNowCount = min(length, _remaining_bytes);
+       uint ReadNowCount = MYSQL_MIN(length, _remaining_bytes);
        uint GotBytes = my_lock(_fd_vector[i], locktype, bufptr, ReadNowCount,
 			MyFlags);
        if ((int) GotBytes == -1)
diff -Nuar --exclude list mysql.orig/sql/ha_berkeley.cc mysql/sql/ha_berkeley.cc
--- mysql.orig/sql/ha_berkeley.cc	2007-12-14 12:43:32.000000000 -0800
+++ mysql/sql/ha_berkeley.cc	2008-01-15 05:18:05.347377416 -0800
@@ -159,7 +159,7 @@
   */
   if (!berkeley_log_buffer_size)
   {
-    berkeley_log_buffer_size= max(table_cache_size*512,32*1024);
+    berkeley_log_buffer_size= MYSQL_MAX(table_cache_size*512,32*1024);
   }
   /*
     Berkeley DB require that
@@ -167,7 +167,7 @@
   */
   berkeley_log_file_size= berkeley_log_buffer_size*4;
   berkeley_log_file_size= MY_ALIGN(berkeley_log_file_size,1024*1024L);
-  berkeley_log_file_size= max(berkeley_log_file_size, 10*1024*1024L);
+  berkeley_log_file_size= MYSQL_MAX(berkeley_log_file_size, 10*1024*1024L);
 
   if (db_env_create(&db_env,0))
     goto error;
diff -Nuar --exclude list mysql.orig/sql/ha_federated.cc mysql/sql/ha_federated.cc
--- mysql.orig/sql/ha_federated.cc	2007-12-14 12:42:51.000000000 -0800
+++ mysql/sql/ha_federated.cc	2008-01-15 05:18:11.602504971 -0800
@@ -511,7 +511,7 @@
     my_free((gptr) share->scheme, MYF(0));
     share->scheme= 0;
   }
-  buf_len= min(table->s->connect_string.length,
+  buf_len= MYSQL_MIN(table->s->connect_string.length,
                FEDERATED_QUERY_BUFFER_SIZE-1);
   strmake(buf, table->s->connect_string.str, buf_len);
   my_error(error_num, MYF(0), buf);
@@ -1086,7 +1086,7 @@
     {
       Field *field= key_part->field;
       uint store_length= key_part->store_length;
-      uint part_length= min(store_length, length);
+      uint part_length= MYSQL_MIN(store_length, length);
       needs_quotes= 1;
       DBUG_DUMP("key, start of loop", (char *) ptr, length);
 
diff -Nuar --exclude list mysql.orig/sql/ha_innodb.cc mysql/sql/ha_innodb.cc
--- mysql.orig/sql/ha_innodb.cc	2007-12-14 12:43:42.000000000 -0800
+++ mysql/sql/ha_innodb.cc	2008-01-15 05:18:16.465356748 -0800
@@ -627,7 +627,7 @@
 			max_query_len = 300;
 		}
 
-		len = min(thd->query_length, max_query_len);
+		len = MYSQL_MIN(thd->query_length, max_query_len);
 
 		if (len > (sizeof(buf) - 1))
 		{
diff -Nuar --exclude list mysql.orig/sql/ha_myisam.cc mysql/sql/ha_myisam.cc
--- mysql.orig/sql/ha_myisam.cc	2007-12-14 12:43:13.000000000 -0800
+++ mysql/sql/ha_myisam.cc	2008-01-15 05:18:19.521682056 -0800
@@ -1411,7 +1411,7 @@
 {
   DBUG_ENTER("ha_myisam::start_bulk_insert");
   THD *thd= current_thd;
-  ulong size= min(thd->variables.read_buff_size,
+  ulong size= MYSQL_MIN(thd->variables.read_buff_size,
                   (ulong) (table->s->avg_row_length*rows));
   DBUG_PRINT("info",("start_bulk_insert: rows %lu size %lu",
                      (ulong) rows, size));
diff -Nuar --exclude list mysql.orig/sql/ha_myisammrg.cc mysql/sql/ha_myisammrg.cc
--- mysql.orig/sql/ha_myisammrg.cc	2007-12-14 12:43:15.000000000 -0800
+++ mysql/sql/ha_myisammrg.cc	2008-01-15 05:18:21.855015186 -0800
@@ -407,7 +407,7 @@
       memcpy((char*) table->key_info[0].rec_per_key,
 	     (char*) mrg_info.rec_per_key,
              sizeof(table->key_info[0].rec_per_key) *
-             min(file->keys, table->s->key_parts));
+             MYSQL_MIN(file->keys, table->s->key_parts));
     }
   }
   return 0;
diff -Nuar --exclude list mysql.orig/sql/ha_ndbcluster.cc mysql/sql/ha_ndbcluster.cc
--- mysql.orig/sql/ha_ndbcluster.cc	2008-01-15 04:39:41.921904000 -0800
+++ mysql/sql/ha_ndbcluster.cc	2008-01-15 05:18:28.705535179 -0800
@@ -6248,10 +6248,10 @@
      sql_print_error("unpackfrm: ver != 1");
      DBUG_RETURN(1);
    }
-   if (!(data= my_malloc(max(orglen, complen), MYF(MY_WME))))
+   if (!(data= my_malloc(MYSQL_MAX(orglen, complen), MYF(MY_WME))))
    {
      sql_print_error("unpackfrm: my_malloc(%u)",
-                     (unsigned int)max(orglen, complen));
+                     (unsigned int)MYSQL_MAX(orglen, complen));
      DBUG_RETURN(HA_ERR_OUT_OF_MEM);
    }
    memcpy(data, blob->data, complen);
diff -Nuar --exclude list mysql.orig/sql/item.cc mysql/sql/item.cc
--- mysql.orig/sql/item.cc	2008-01-15 04:39:41.921904000 -0800
+++ mysql/sql/item.cc	2008-01-15 05:18:30.751681400 -0800
@@ -4826,7 +4826,7 @@
 void Item_hex_string::print(String *str)
 {
   char *end= (char*) str_value.ptr() + str_value.length(),
-       *ptr= end - min(str_value.length(), sizeof(longlong));
+       *ptr= end - MYSQL_MIN(str_value.length(), sizeof(longlong));
   str->append("0x");
   for (; ptr != end ; ptr++)
   {
diff -Nuar --exclude list mysql.orig/sql/log_event.cc mysql/sql/log_event.cc
--- mysql.orig/sql/log_event.cc	2008-01-15 04:39:41.931903000 -0800
+++ mysql/sql/log_event.cc	2008-01-15 05:18:33.198338005 -0800
@@ -1551,7 +1551,7 @@
       be even bigger, but this will suffice to catch most corruption
       errors that can lead to a crash.
     */
-    if (status_vars_len > min(data_len, MAX_SIZE_LOG_EVENT_STATUS))
+    if (status_vars_len > MYSQL_MIN(data_len, MAX_SIZE_LOG_EVENT_STATUS))
     {
       DBUG_PRINT("info", ("status_vars_len (%u) > data_len (%lu); query= 0",
                           status_vars_len, data_len));
diff -Nuar --exclude list mysql.orig/sql/mysql_tzinfo_to_sql.cc mysql/sql/mysql_tzinfo_to_sql.cc
--- mysql.orig/sql/mysql_tzinfo_to_sql.cc	2007-12-14 12:43:51.000000000 -0800
+++ mysql/sql/mysql_tzinfo_to_sql.cc	2008-01-15 05:18:38.366693436 -0800
@@ -167,7 +167,7 @@
       char buf[sizeof(struct tzhead) + sizeof(my_time_t) * TZ_MAX_TIMES +
                TZ_MAX_TIMES + sizeof(TRAN_TYPE_INFO) * TZ_MAX_TYPES +
 #ifdef ABBR_ARE_USED
-               max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
+               MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1))) +
 #endif
                sizeof(LS_INFO) * TZ_MAX_LEAPS];
     } u;
@@ -396,7 +396,7 @@
       Let us choose end_t as point before next time type change or leap
       second correction.
     */
-    end_t= min((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
+    end_t= MYSQL_MIN((next_trans_idx < sp->timecnt) ? sp->ats[next_trans_idx] - 1:
                                                 MY_TIME_T_MAX,
                (next_leap_idx < sp->leapcnt) ?
                  sp->lsis[next_leap_idx].ls_trans - 1: MY_TIME_T_MAX);
@@ -1866,7 +1866,7 @@
   unsigned char types[TZ_MAX_TIMES];
   TRAN_TYPE_INFO ttis[TZ_MAX_TYPES];
 #ifdef ABBR_ARE_USED
-  char chars[max(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
+  char chars[MYSQL_MAX(TZ_MAX_CHARS + 1, (2 * (MY_TZNAME_MAX + 1)))];
 #endif
 
   DBUG_ENTER("tz_load_from_open_tables");
diff -Nuar --exclude list mysql.orig/sql/slave.cc mysql/sql/slave.cc
--- mysql.orig/sql/slave.cc	2008-01-15 04:39:41.938571000 -0800
+++ mysql/sql/slave.cc	2008-01-15 05:18:41.308901512 -0800
@@ -2723,7 +2723,7 @@
   ulong log_name_extension;
   char log_name_tmp[FN_REFLEN]; //make a char[] from String
 
-  strmake(log_name_tmp, log_name->ptr(), min(log_name->length(), FN_REFLEN-1));
+  strmake(log_name_tmp, log_name->ptr(), MYSQL_MIN(log_name->length(), FN_REFLEN-1));
 
   char *p= fn_ext(log_name_tmp);
   char *p_end;
@@ -2733,7 +2733,7 @@
     goto err;
   }
   // Convert 0-3 to 4
-  log_pos= max(log_pos, BIN_LOG_HEADER_SIZE);
+  log_pos= MYSQL_MAX(log_pos, BIN_LOG_HEADER_SIZE);
   /* p points to '.' */
   log_name_extension= strtoul(++p, &p_end, 10);
   /*
diff -Nuar --exclude list mysql.orig/sql/sql_parse.cc mysql/sql/sql_parse.cc
--- mysql.orig/sql/sql_parse.cc	2008-01-15 04:39:41.945237000 -0800
+++ mysql/sql/sql_parse.cc	2008-01-15 05:20:25.791685282 -0800
@@ -858,7 +858,7 @@
       if (thd->main_security_ctx.host)
       {
         if (thd->main_security_ctx.host != my_localhost)
-          thd->main_security_ctx.host[min(strlen(thd->main_security_ctx.host),
+          thd->main_security_ctx.host[MYSQL_MIN(strlen(thd->main_security_ctx.host),
                                           HOSTNAME_LENGTH)]= 0;
         thd->main_security_ctx.host_or_ip= thd->main_security_ctx.host;
       }
diff -Nuar --exclude list mysql.orig/sql/sql_select.cc mysql/sql/sql_select.cc
--- mysql.orig/sql/sql_select.cc	2008-01-15 04:39:41.951904000 -0800
+++ mysql/sql/sql_select.cc	2008-01-15 05:18:56.591678282 -0800
@@ -6371,7 +6371,7 @@
         a correlated subquery itself, but has subqueries, we can free it
         fully and also free JOINs of all its subqueries. The exception
         is a subquery in SELECT list, e.g:
-        SELECT a, (select max(b) from t1) group by c
+        SELECT a, (select MYSQLMYSQL__MAX(b) from t1) group by c
         This subquery will not be evaluated at first sweep and its value will
         not be inserted into the temporary table. Instead, it's evaluated
         when selecting from the temporary table. Therefore, it can't be freed
@@ -9008,7 +9008,7 @@
     {
       signed int overflow;
 
-      dec= min(dec, DECIMAL_MAX_SCALE);
+      dec= MYSQL_MIN(dec, DECIMAL_MAX_SCALE);
 
       /*
         If the value still overflows the field with the corrected dec,
@@ -9728,7 +9728,7 @@
     table->s->max_rows= ~(ha_rows) 0;
   else
     table->s->max_rows= (ha_rows) (((table->s->db_type == DB_TYPE_HEAP) ?
-                                    min(thd->variables.tmp_table_size,
+                                    MYSQL_MIN(thd->variables.tmp_table_size,
                                         thd->variables.max_heap_table_size) :
                                     thd->variables.tmp_table_size)/
                                    table->s->reclength);
diff -Nuar mysql.orig/ndb/src/common/portlib/NdbTCP.cpp mysql/ndb/src/common/portlib/NdbTCP.cpp
--- mysql.orig/ndb/src/common/portlib/NdbTCP.cpp	2007-12-14 12:43:00.000000000 -0800
+++ mysql/ndb/src/common/portlib/NdbTCP.cpp	2008-01-15 06:17:04.021329045 -0800
@@ -30,7 +30,7 @@
 			    &tmp_errno);
     if (hp)
     {
-      memcpy(dst, hp->h_addr, min(sizeof(*dst), (size_t) hp->h_length));
+      memcpy(dst, hp->h_addr, MYSQL_MIN(sizeof(*dst), (size_t) hp->h_length));
       my_gethostbyname_r_free();
       return 0; //DBUG_RETURN(0);
     }
diff -Nuar mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp mysql/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp
--- mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp	2007-12-14 12:43:00.000000000 -0800
+++ mysql/ndb/src/kernel/blocks/dbtux/DbtuxCmp.cpp	2008-01-15 06:16:30.076634382 -0800
@@ -54,7 +54,7 @@
         ndbrequire(ah(entryData).getAttributeId() == descAttr.m_primaryAttrId);
         // sizes
         const unsigned size1 = ah(searchKey).getDataSize();
-        const unsigned size2 = min(ah(entryData).getDataSize(), len2);
+        const unsigned size2 = MYSQL_MIN(ah(entryData).getDataSize(), len2);
         len2 -= size2;
         // compare
         NdbSqlUtil::Cmp* const cmp = c_sqlCmp[start];
@@ -139,7 +139,7 @@
         ndbrequire(ah(entryData).getAttributeId() == descAttr.m_primaryAttrId);
         // sizes
         const unsigned size1 = ah(boundInfo).getDataSize();
-        const unsigned size2 = min(ah(entryData).getDataSize(), len2);
+        const unsigned size2 = MYSQL_MIN(ah(entryData).getDataSize(), len2);
         len2 -= size2;
         // compare
         NdbSqlUtil::Cmp* const cmp = c_sqlCmp[index];
diff -Nuar mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp mysql/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp
--- mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp	2007-12-14 12:43:42.000000000 -0800
+++ mysql/ndb/src/kernel/blocks/dbtux/DbtuxDebug.cpp	2008-01-15 06:16:35.579748782 -0800
@@ -242,7 +242,7 @@
     }
   }
   // return values
-  par.m_depth = 1 + max(cpar[0].m_depth, cpar[1].m_depth);
+  par.m_depth = 1 + MYSQL_MAX(cpar[0].m_depth, cpar[1].m_depth);
   par.m_occup = node.getOccup();
   for (unsigned i = 0; i <= 1; i++) {
     if (node.getLink(i) == NullTupLoc)
diff -Nuar mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp mysql/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp
--- mysql.orig/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp	2007-12-14 12:43:24.000000000 -0800
+++ mysql/ndb/src/kernel/blocks/dbtux/DbtuxTree.cpp	2008-01-15 06:17:09.381704725 -0800
@@ -251,7 +251,7 @@
   selectNode(leafNode, leafLoc);
   if (semiNode.getOccup() < tree.m_minOccup) {
     jam();
-    unsigned cnt = min(leafNode.getOccup(), tree.m_minOccup - semiNode.getOccup());
+    unsigned cnt = MYSQL_MIN(leafNode.getOccup(), tree.m_minOccup - semiNode.getOccup());
     nodeSlide(semiNode, leafNode, cnt, i);
     if (leafNode.getOccup() == 0) {
       // remove empty leaf
@@ -281,7 +281,7 @@
       jam();
       if (parentNode.getOccup() < tree.m_minOccup) {
         jam();
-        unsigned cnt = min(leafNode.getOccup(), tree.m_minOccup - parentNode.getOccup());
+        unsigned cnt = MYSQL_MIN(leafNode.getOccup(), tree.m_minOccup - parentNode.getOccup());
         nodeSlide(parentNode, leafNode, cnt, i);
       }
     }
